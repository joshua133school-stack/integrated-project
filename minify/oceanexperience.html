<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ocean - Coral Reef</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            overflow: hidden;
            background: #006994;
            font-family: 'Georgia', serif;
        }
        #canvas-container {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 1;
        }

        .prompt-overlay {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-size: 1.8rem; text-align: center;
            pointer-events: none; z-index: 50; opacity: 0; transition: opacity 0.8s ease;
            text-shadow: 0 0 20px rgba(255,255,255,0.5);
            max-width: 80%;
        }
        .prompt-overlay.visible { opacity: 1; }

        #crosshair {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 20px; height: 20px; z-index: 40; pointer-events: none;
            opacity: 0.5;
        }
        #crosshair::before, #crosshair::after {
            content: ''; position: absolute; background: rgba(255,255,255,0.6);
        }
        #crosshair::before { width: 2px; height: 20px; left: 9px; }
        #crosshair::after { width: 20px; height: 2px; top: 9px; }

        #depth-indicator {
            position: fixed; top: 30px; right: 30px;
            color: rgba(255,255,255,0.8); font-size: 1.2rem; z-index: 50;
            text-shadow: 0 0 10px rgba(0,0,0,0.8);
        }

        #controls-hint {
            position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%);
            color: rgba(255,255,255,0.7); font-size: 0.9rem; z-index: 50;
            text-shadow: 0 0 10px rgba(0,0,0,0.8);
            transition: opacity 1s;
        }

        #fade-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: black; z-index: 100; opacity: 0; pointer-events: none;
            transition: opacity 2s ease;
        }
        #fade-overlay.visible { opacity: 1; pointer-events: all; }

        #warning-text {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #ff6b6b; font-size: 1.5rem; z-index: 60;
            opacity: 0; transition: opacity 0.5s;
            text-shadow: 0 0 20px rgba(255,0,0,0.5);
        }
        #warning-text.visible { opacity: 1; }

        .bubble {
            position: fixed;
            background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.8), rgba(255,255,255,0.2));
            border-radius: 50%;
            pointer-events: none;
            z-index: 30;
            animation: bubble-rise 4s ease-in forwards;
        }

        @keyframes bubble-rise {
            0% { transform: translateY(0) scale(1); opacity: 0.7; }
            100% { transform: translateY(-100vh) scale(1.5); opacity: 0; }
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    <div id="crosshair"></div>
    <div class="prompt-overlay" id="intro-text">Explore the coral reef...</div>
    <div id="depth-indicator">Depth: 5m</div>
    <div id="controls-hint">WASD to swim | Mouse to look | SPACE to swim up</div>
    <div id="warning-text">The edge...</div>
    <div id="fade-overlay"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // ============== SCENE SETUP ==============
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x006994);
        scene.fog = new THREE.FogExp2(0x006994, 0.02);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 3, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // ============== LIGHTING ==============
        // Bright sunlight from above (shallow water)
        const sunLight = new THREE.DirectionalLight(0xffffcc, 1.5);
        sunLight.position.set(10, 50, 10);
        sunLight.castShadow = true;
        scene.add(sunLight);

        // Ambient light for tropical feel
        const ambientLight = new THREE.AmbientLight(0x88ccff, 0.6);
        scene.add(ambientLight);

        // God rays effect light
        const godRayLight = new THREE.SpotLight(0xffffaa, 0.8, 100, Math.PI / 6, 0.5);
        godRayLight.position.set(0, 40, 0);
        scene.add(godRayLight);

        // ============== WATER SURFACE (visible from below) ==============
        const waterSurfaceGeometry = new THREE.PlaneGeometry(200, 200, 50, 50);
        const waterSurfaceMaterial = new THREE.MeshPhongMaterial({
            color: 0x40e0d0,
            transparent: true,
            opacity: 0.3,
            side: THREE.DoubleSide
        });
        const waterSurface = new THREE.Mesh(waterSurfaceGeometry, waterSurfaceMaterial);
        waterSurface.rotation.x = Math.PI / 2;
        waterSurface.position.y = 15;
        scene.add(waterSurface);

        // ============== SANDY BOTTOM ==============
        const sandGeometry = new THREE.PlaneGeometry(100, 100, 20, 20);
        // Add some variation to sand
        const sandVertices = sandGeometry.attributes.position.array;
        for (let i = 0; i < sandVertices.length; i += 3) {
            sandVertices[i + 2] += Math.random() * 0.3;
        }
        sandGeometry.computeVertexNormals();

        const sandMaterial = new THREE.MeshLambertMaterial({ color: 0xf4d03f });
        const sand = new THREE.Mesh(sandGeometry, sandMaterial);
        sand.rotation.x = -Math.PI / 2;
        sand.position.y = 0;
        sand.receiveShadow = true;
        scene.add(sand);

        // ============== CORAL CREATION ==============
        const corals = [];
        const coralColors = [0xff6b6b, 0xff8e72, 0xffa07a, 0xff7f50, 0xe74c3c, 0xf1c40f, 0x9b59b6, 0x1abc9c];

        function createBranchCoral(x, z, color) {
            const group = new THREE.Group();
            const height = 1 + Math.random() * 2;

            // Main trunk
            const trunkGeo = new THREE.CylinderGeometry(0.1, 0.2, height, 8);
            const trunkMat = new THREE.MeshLambertMaterial({ color: color });
            const trunk = new THREE.Mesh(trunkGeo, trunkMat);
            trunk.position.y = height / 2;
            group.add(trunk);

            // Branches
            for (let i = 0; i < 5; i++) {
                const branchHeight = 0.5 + Math.random() * 0.8;
                const branchGeo = new THREE.CylinderGeometry(0.03, 0.08, branchHeight, 6);
                const branch = new THREE.Mesh(branchGeo, trunkMat);
                branch.position.y = height * 0.4 + Math.random() * height * 0.5;
                branch.position.x = (Math.random() - 0.5) * 0.5;
                branch.position.z = (Math.random() - 0.5) * 0.5;
                branch.rotation.x = (Math.random() - 0.5) * 0.8;
                branch.rotation.z = (Math.random() - 0.5) * 0.8;
                group.add(branch);
            }

            group.position.set(x, 0, z);
            return group;
        }

        function createBrainCoral(x, z, color) {
            const geometry = new THREE.SphereGeometry(0.5 + Math.random() * 0.5, 16, 16);
            const vertices = geometry.attributes.position.array;
            for (let i = 0; i < vertices.length; i += 3) {
                vertices[i] += (Math.random() - 0.5) * 0.2;
                vertices[i + 1] += (Math.random() - 0.5) * 0.2;
                vertices[i + 2] += (Math.random() - 0.5) * 0.2;
            }
            geometry.computeVertexNormals();

            const material = new THREE.MeshLambertMaterial({ color: color });
            const coral = new THREE.Mesh(geometry, material);
            coral.position.set(x, 0.4, z);
            coral.scale.y = 0.6;
            return coral;
        }

        function createFanCoral(x, z, color) {
            const group = new THREE.Group();
            const shape = new THREE.Shape();
            shape.moveTo(0, 0);
            shape.quadraticCurveTo(0.8, 1.5, 0, 2.5);
            shape.quadraticCurveTo(-0.8, 1.5, 0, 0);

            const geometry = new THREE.ShapeGeometry(shape);
            const material = new THREE.MeshLambertMaterial({ color: color, side: THREE.DoubleSide });
            const fan = new THREE.Mesh(geometry, material);
            fan.rotation.y = Math.random() * Math.PI * 2;
            group.add(fan);
            group.position.set(x, 0, z);
            return group;
        }

        // Create coral reef area
        for (let i = 0; i < 40; i++) {
            const x = (Math.random() - 0.5) * 40;
            const z = (Math.random() - 0.5) * 30 - 5;
            const color = coralColors[Math.floor(Math.random() * coralColors.length)];
            const type = Math.floor(Math.random() * 3);

            let coral;
            if (type === 0) coral = createBranchCoral(x, z, color);
            else if (type === 1) coral = createBrainCoral(x, z, color);
            else coral = createFanCoral(x, z, color);

            coral.castShadow = true;
            scene.add(coral);
            corals.push(coral);
        }

        // ============== CUTE FISH ==============
        const fishSchools = [];

        function createFish(color, size = 0.3) {
            const group = new THREE.Group();

            // Body
            const bodyGeo = new THREE.SphereGeometry(size, 8, 6);
            bodyGeo.scale(1.5, 0.8, 0.5);
            const bodyMat = new THREE.MeshLambertMaterial({ color: color });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            group.add(body);

            // Tail
            const tailGeo = new THREE.ConeGeometry(size * 0.5, size * 0.8, 4);
            const tail = new THREE.Mesh(tailGeo, bodyMat);
            tail.rotation.z = Math.PI / 2;
            tail.position.x = -size * 1.2;
            group.add(tail);

            // Eye
            const eyeGeo = new THREE.SphereGeometry(size * 0.15, 8, 8);
            const eyeMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
            const eye = new THREE.Mesh(eyeGeo, eyeMat);
            eye.position.set(size * 0.5, size * 0.1, size * 0.2);
            group.add(eye);

            const eye2 = eye.clone();
            eye2.position.z = -size * 0.2;
            group.add(eye2);

            // Dorsal fin
            const finGeo = new THREE.ConeGeometry(size * 0.2, size * 0.4, 3);
            const fin = new THREE.Mesh(finGeo, bodyMat);
            fin.position.y = size * 0.5;
            fin.rotation.x = -0.2;
            group.add(fin);

            return group;
        }

        // Create schools of fish
        const fishColors = [0xffeb3b, 0x03a9f4, 0xff9800, 0x4caf50, 0xe91e63, 0x00bcd4];

        for (let school = 0; school < 6; school++) {
            const schoolGroup = new THREE.Group();
            const fishColor = fishColors[school % fishColors.length];
            const schoolCenter = new THREE.Vector3(
                (Math.random() - 0.5) * 30,
                2 + Math.random() * 5,
                (Math.random() - 0.5) * 20 - 5
            );

            const fishInSchool = [];
            for (let i = 0; i < 8; i++) {
                const fish = createFish(fishColor, 0.2 + Math.random() * 0.15);
                fish.position.set(
                    schoolCenter.x + (Math.random() - 0.5) * 3,
                    schoolCenter.y + (Math.random() - 0.5) * 2,
                    schoolCenter.z + (Math.random() - 0.5) * 3
                );
                fish.userData = {
                    offset: Math.random() * Math.PI * 2,
                    speed: 0.5 + Math.random() * 0.5,
                    radius: 2 + Math.random() * 3
                };
                scene.add(fish);
                fishInSchool.push(fish);
            }
            fishSchools.push({ center: schoolCenter, fish: fishInSchool });
        }

        // ============== THE CLIFF ==============
        // Cliff is at the edge of the coral reef area
        const cliffZ = -25;

        // Cliff wall
        const cliffGeo = new THREE.BoxGeometry(60, 50, 5);
        const cliffMat = new THREE.MeshLambertMaterial({ color: 0x4a4a4a });
        const cliff = new THREE.Mesh(cliffGeo, cliffMat);
        cliff.position.set(0, -25, cliffZ - 2.5);
        scene.add(cliff);

        // Cliff edge sand
        const cliffEdgeGeo = new THREE.PlaneGeometry(60, 10);
        const cliffEdge = new THREE.Mesh(cliffEdgeGeo, sandMaterial);
        cliffEdge.rotation.x = -Math.PI / 2;
        cliffEdge.position.set(0, 0.1, cliffZ + 2.5);
        scene.add(cliffEdge);

        // Dark abyss below
        const abyssGeo = new THREE.PlaneGeometry(60, 60);
        const abyssMat = new THREE.MeshBasicMaterial({ color: 0x000510 });
        const abyss = new THREE.Mesh(abyssGeo, abyssMat);
        abyss.rotation.x = -Math.PI / 2;
        abyss.position.set(0, -50, cliffZ - 30);
        scene.add(abyss);

        // Dark fog in the abyss
        const darkFogGeo = new THREE.PlaneGeometry(60, 30);
        const darkFogMat = new THREE.MeshBasicMaterial({
            color: 0x000000,
            transparent: true,
            opacity: 0.8,
            side: THREE.DoubleSide
        });
        const darkFog = new THREE.Mesh(darkFogGeo, darkFogMat);
        darkFog.rotation.x = -Math.PI / 2;
        darkFog.position.set(0, -5, cliffZ - 15);
        scene.add(darkFog);

        // ============== PLAYER CONTROLS ==============
        const State = {
            phase: 'exploring', // exploring, nearEdge, falling, ended
            playerY: 3,
            isFalling: false,
            fallSpeed: 0,
            keys: { w: false, a: false, s: false, d: false, space: false },
            velocity: new THREE.Vector3(),
            canMove: true
        };

        // Euler for camera rotation
        const euler = new THREE.Euler(0, 0, 0, 'YXZ');
        let isPointerLocked = false;

        document.addEventListener('click', () => {
            if (!isPointerLocked && State.phase === 'exploring') {
                renderer.domElement.requestPointerLock();
            }
        });

        document.addEventListener('pointerlockchange', () => {
            isPointerLocked = document.pointerLockElement === renderer.domElement;
        });

        document.addEventListener('mousemove', (e) => {
            if (!isPointerLocked || !State.canMove) return;

            euler.setFromQuaternion(camera.quaternion);
            euler.y -= e.movementX * 0.002;
            euler.x -= e.movementY * 0.002;
            euler.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, euler.x));
            camera.quaternion.setFromEuler(euler);
        });

        document.addEventListener('keydown', (e) => {
            if (e.key.toLowerCase() === 'w') State.keys.w = true;
            if (e.key.toLowerCase() === 'a') State.keys.a = true;
            if (e.key.toLowerCase() === 's') State.keys.s = true;
            if (e.key.toLowerCase() === 'd') State.keys.d = true;
            if (e.key === ' ') State.keys.space = true;
        });

        document.addEventListener('keyup', (e) => {
            if (e.key.toLowerCase() === 'w') State.keys.w = false;
            if (e.key.toLowerCase() === 'a') State.keys.a = false;
            if (e.key.toLowerCase() === 's') State.keys.s = false;
            if (e.key.toLowerCase() === 'd') State.keys.d = false;
            if (e.key === ' ') State.keys.space = false;
        });

        // ============== PARTICLE EFFECTS ==============
        // Floating particles in water
        const particleCount = 200;
        const particleGeo = new THREE.BufferGeometry();
        const particlePositions = new Float32Array(particleCount * 3);

        for (let i = 0; i < particleCount * 3; i += 3) {
            particlePositions[i] = (Math.random() - 0.5) * 60;
            particlePositions[i + 1] = Math.random() * 15;
            particlePositions[i + 2] = (Math.random() - 0.5) * 60;
        }
        particleGeo.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));

        const particleMat = new THREE.PointsMaterial({
            color: 0xffffff,
            size: 0.1,
            transparent: true,
            opacity: 0.6
        });
        const particles = new THREE.Points(particleGeo, particleMat);
        scene.add(particles);

        // ============== UI ELEMENTS ==============
        const introText = document.getElementById('intro-text');
        const depthIndicator = document.getElementById('depth-indicator');
        const warningText = document.getElementById('warning-text');
        const fadeOverlay = document.getElementById('fade-overlay');
        const controlsHint = document.getElementById('controls-hint');

        // Show intro
        setTimeout(() => {
            introText.classList.add('visible');
            setTimeout(() => {
                introText.classList.remove('visible');
            }, 4000);
        }, 1000);

        // Hide controls hint after a while
        setTimeout(() => {
            controlsHint.style.opacity = '0';
        }, 8000);

        // ============== ANIMATION LOOP ==============
        const clock = new THREE.Clock();
        let time = 0;

        function updateFish(delta) {
            fishSchools.forEach(school => {
                school.fish.forEach(fish => {
                    const data = fish.userData;
                    time += delta * 0.1;

                    // Circular swimming pattern
                    const angle = time * data.speed + data.offset;
                    fish.position.x = school.center.x + Math.cos(angle) * data.radius;
                    fish.position.z = school.center.z + Math.sin(angle) * data.radius;
                    fish.position.y = school.center.y + Math.sin(angle * 2) * 0.5;

                    // Face swimming direction
                    fish.rotation.y = -angle + Math.PI / 2;

                    // Tail wiggle
                    if (fish.children[1]) {
                        fish.children[1].rotation.y = Math.sin(time * 10 + data.offset) * 0.3;
                    }
                });
            });
        }

        function updateWaterSurface(time) {
            const positions = waterSurface.geometry.attributes.position.array;
            for (let i = 0; i < positions.length; i += 3) {
                const x = positions[i];
                const z = positions[i + 1];
                positions[i + 2] = Math.sin(x * 0.1 + time) * 0.5 + Math.cos(z * 0.1 + time * 0.8) * 0.5;
            }
            waterSurface.geometry.attributes.position.needsUpdate = true;
        }

        function updateParticles(time) {
            const positions = particles.geometry.attributes.position.array;
            for (let i = 0; i < positions.length; i += 3) {
                positions[i + 1] += 0.01;
                if (positions[i + 1] > 15) positions[i + 1] = 0;
            }
            particles.geometry.attributes.position.needsUpdate = true;
        }

        function updatePlayer(delta) {
            if (!State.canMove) return;

            const moveSpeed = 5 * delta;
            const direction = new THREE.Vector3();

            // Get forward/right vectors
            const forward = new THREE.Vector3();
            camera.getWorldDirection(forward);
            forward.y = 0;
            forward.normalize();

            const right = new THREE.Vector3();
            right.crossVectors(forward, new THREE.Vector3(0, 1, 0));

            // Apply movement
            if (State.keys.w) direction.add(forward);
            if (State.keys.s) direction.sub(forward);
            if (State.keys.d) direction.add(right);
            if (State.keys.a) direction.sub(right);

            if (direction.length() > 0) {
                direction.normalize();
                camera.position.x += direction.x * moveSpeed;
                camera.position.z += direction.z * moveSpeed;
            }

            // Vertical movement
            if (State.keys.space) {
                camera.position.y += moveSpeed * 0.8;
            } else if (!State.isFalling) {
                // Gentle sink
                camera.position.y -= moveSpeed * 0.1;
            }

            // Clamp height in exploring phase
            if (State.phase === 'exploring') {
                camera.position.y = Math.max(1.5, Math.min(12, camera.position.y));
                camera.position.x = Math.max(-25, Math.min(25, camera.position.x));
            }

            // Update depth indicator
            const depth = Math.round(15 - camera.position.y + 5);
            depthIndicator.textContent = `Depth: ${depth}m`;
        }

        function checkCliffEdge() {
            if (State.phase !== 'exploring') return;

            const distanceToEdge = cliffZ - camera.position.z;

            if (distanceToEdge < 8 && distanceToEdge > 0) {
                // Near the edge - show warning
                if (State.phase === 'exploring') {
                    warningText.classList.add('visible');
                    scene.fog = new THREE.FogExp2(0x003355, 0.03);
                }
            } else {
                warningText.classList.remove('visible');
            }

            if (camera.position.z < cliffZ) {
                // Crossed the edge - start falling!
                triggerFall();
            }
        }

        function triggerFall() {
            State.phase = 'falling';
            State.isFalling = true;
            State.canMove = false;
            State.fallSpeed = 0;

            warningText.textContent = "You're falling...";
            warningText.classList.add('visible');

            document.exitPointerLock();

            // Darken the scene
            scene.fog = new THREE.FogExp2(0x000510, 0.05);
            scene.background = new THREE.Color(0x000510);

            // Remove the bright lights
            sunLight.intensity = 0.2;
            ambientLight.intensity = 0.1;

            // Create bubbles effect
            createBubbles();
        }

        function createBubbles() {
            for (let i = 0; i < 20; i++) {
                setTimeout(() => {
                    const bubble = document.createElement('div');
                    bubble.className = 'bubble';
                    bubble.style.left = (Math.random() * 100) + '%';
                    bubble.style.bottom = '0';
                    bubble.style.width = (10 + Math.random() * 20) + 'px';
                    bubble.style.height = bubble.style.width;
                    document.body.appendChild(bubble);

                    setTimeout(() => bubble.remove(), 4000);
                }, i * 200);
            }
        }

        function updateFalling(delta) {
            if (State.phase !== 'falling') return;

            State.fallSpeed += delta * 2;
            camera.position.y -= State.fallSpeed;
            camera.position.z -= delta * 3;

            // Camera shake
            camera.rotation.z = Math.sin(time * 10) * 0.02;

            // Update depth dramatically
            const depth = Math.round(15 - camera.position.y + 5);
            depthIndicator.textContent = `Depth: ${depth}m`;

            // Fog gets thicker
            scene.fog.density = 0.05 + (Math.abs(camera.position.y) / 100);

            if (camera.position.y < -40) {
                // Reached the bottom
                endExperience();
            }
        }

        function endExperience() {
            State.phase = 'ended';
            warningText.textContent = "The deep ocean...";

            setTimeout(() => {
                fadeOverlay.classList.add('visible');

                setTimeout(() => {
                    warningText.style.zIndex = '101';
                    warningText.style.color = '#ffffff';
                    warningText.textContent = "You faced the abyss.";
                }, 2000);
            }, 2000);
        }

        function animate() {
            requestAnimationFrame(animate);

            const delta = Math.min(clock.getDelta(), 0.1);
            time += delta;

            updateFish(delta);
            updateWaterSurface(time);
            updateParticles(time);
            updatePlayer(delta);
            checkCliffEdge();
            updateFalling(delta);

            // Gentle camera sway (underwater feel)
            if (State.phase === 'exploring') {
                camera.position.y += Math.sin(time * 0.5) * 0.002;
            }

            renderer.render(scene, camera);
        }

        // Handle resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
