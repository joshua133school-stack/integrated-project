<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ocean - Coral Reef</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; background: #006994; font-family: 'Georgia', serif; }
        #canvas-container { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        .prompt-overlay { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; font-size: 1.8rem; text-align: center; pointer-events: none; z-index: 50; opacity: 0; transition: opacity 0.8s ease; text-shadow: 0 0 20px rgba(255,255,255,0.5); max-width: 80%; }
        .prompt-overlay.visible { opacity: 1; }
        #crosshair { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 20px; height: 20px; z-index: 40; pointer-events: none; opacity: 0.5; }
        #crosshair::before, #crosshair::after { content: ''; position: absolute; background: rgba(255,255,255,0.6); }
        #crosshair::before { width: 2px; height: 20px; left: 9px; }
        #crosshair::after { width: 20px; height: 2px; top: 9px; }
        #depth-indicator { position: fixed; top: 30px; right: 30px; color: rgba(255,255,255,0.8); font-size: 1.2rem; z-index: 50; text-shadow: 0 0 10px rgba(0,0,0,0.8); }
        #controls-hint { position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%); color: rgba(255,255,255,0.7); font-size: 0.9rem; z-index: 50; text-shadow: 0 0 10px rgba(0,0,0,0.8); transition: opacity 1s; }
        #fade-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: black; z-index: 100; opacity: 0; pointer-events: none; transition: opacity 2s ease; }
        #fade-overlay.visible { opacity: 1; pointer-events: all; }
        #warning-text { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #ff6b6b; font-size: 1.5rem; z-index: 60; opacity: 0; transition: opacity 0.5s; text-shadow: 0 0 20px rgba(255,0,0,0.5); }
        #warning-text.visible { opacity: 1; }
        .bubble { position: fixed; background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.8), rgba(255,255,255,0.2)); border-radius: 50%; pointer-events: none; z-index: 30; animation: bubble-rise 4s ease-in forwards; }
        @keyframes bubble-rise { 0% { transform: translateY(0) scale(1); opacity: 0.7; } 100% { transform: translateY(-100vh) scale(1.5); opacity: 0; } }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    <div id="crosshair"></div>
    <div class="prompt-overlay" id="intro-text">Explore the coral reef...</div>
    <div id="depth-indicator">Depth: 5m</div>
    <div id="controls-hint">WASD to swim | Mouse to look | SPACE to swim up</div>
    <div id="warning-text">The edge...</div>
    <div id="fade-overlay"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // ============== SCENE SETUP ==============
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0088aa);
        scene.fog = new THREE.FogExp2(0x0088aa, 0.015);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 500);
        camera.position.set(0, 4, 20);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // ============== LIGHTING ==============
        const sunLight = new THREE.DirectionalLight(0xffffcc, 1.2);
        sunLight.position.set(20, 60, 20);
        sunLight.castShadow = true;
        scene.add(sunLight);

        const ambientLight = new THREE.AmbientLight(0x88ddff, 0.6);
        scene.add(ambientLight);

        // Light rays from surface
        for (let i = 0; i < 4; i++) {
            const ray = new THREE.SpotLight(0xffffdd, 0.3, 50, Math.PI / 10, 0.9);
            ray.position.set(-20 + i * 15, 35, Math.random() * 20);
            scene.add(ray);
        }

        // ============== WATER SURFACE ==============
        const waterGeo = new THREE.PlaneGeometry(200, 200, 50, 50);
        const waterMat = new THREE.MeshPhongMaterial({ color: 0x40e0d0, transparent: true, opacity: 0.2, side: THREE.DoubleSide });
        const waterSurface = new THREE.Mesh(waterGeo, waterMat);
        waterSurface.rotation.x = Math.PI / 2;
        waterSurface.position.y = 18;
        scene.add(waterSurface);

        // ============== CLIFF POSITION ==============
        const cliffEdgeZ = -30; // Where the cliff drop starts

        // ============== TERRAIN - SAND THAT STOPS AT CLIFF ==============
        // Main sandy area - positioned BEHIND the player, away from cliff
        const sandGeo = new THREE.PlaneGeometry(120, 80, 40, 30);
        const sandVerts = sandGeo.attributes.position.array;
        for (let i = 0; i < sandVerts.length; i += 3) {
            const localZ = sandVerts[i + 1]; // In plane coords, Y is our Z
            // Add gentle undulation
            sandVerts[i + 2] = Math.sin(sandVerts[i] * 0.1) * 0.3 + Math.random() * 0.2;
        }
        sandGeo.computeVertexNormals();
        const sandMat = new THREE.MeshLambertMaterial({ color: 0xf5d56a });
        const sand = new THREE.Mesh(sandGeo, sandMat);
        sand.rotation.x = -Math.PI / 2;
        sand.position.set(0, 0, 30); // Centered behind player start
        sand.receiveShadow = true;
        scene.add(sand);

        // ============== ROCKY REEF PLATFORM ==============
        // This is where corals grow - a rocky elevated area
        const reefRocks = [];
        const rockMat = new THREE.MeshLambertMaterial({ color: 0x5a5a5a });
        const darkRockMat = new THREE.MeshLambertMaterial({ color: 0x3a3a3a });

        // Create main reef rock formations - elevated rocky platform
        function createReefBase() {
            const reefGroup = new THREE.Group();

            // Large base rocks forming the reef foundation
            for (let i = 0; i < 25; i++) {
                const size = 2 + Math.random() * 4;
                const rockGeo = new THREE.DodecahedronGeometry(size, 1);
                const verts = rockGeo.attributes.position.array;
                for (let j = 0; j < verts.length; j += 3) {
                    verts[j] += (Math.random() - 0.5) * size * 0.3;
                    verts[j + 1] += (Math.random() - 0.5) * size * 0.3;
                    verts[j + 2] += (Math.random() - 0.5) * size * 0.3;
                }
                rockGeo.computeVertexNormals();

                const rock = new THREE.Mesh(rockGeo, Math.random() > 0.5 ? rockMat : darkRockMat);
                const angle = Math.random() * Math.PI * 2;
                const dist = 5 + Math.random() * 25;
                rock.position.set(
                    Math.cos(angle) * dist,
                    -size * 0.3 + Math.random() * 0.5,
                    Math.sin(angle) * dist - 5
                );
                rock.rotation.set(Math.random() * 0.5, Math.random() * Math.PI, Math.random() * 0.5);
                rock.scale.y = 0.4 + Math.random() * 0.3;
                reefGroup.add(rock);
                reefRocks.push(rock);
            }

            // Medium accent rocks
            for (let i = 0; i < 40; i++) {
                const size = 0.8 + Math.random() * 1.5;
                const rockGeo = new THREE.DodecahedronGeometry(size, 0);
                const rock = new THREE.Mesh(rockGeo, Math.random() > 0.3 ? rockMat : darkRockMat);
                const angle = Math.random() * Math.PI * 2;
                const dist = Math.random() * 35;
                rock.position.set(
                    Math.cos(angle) * dist,
                    size * 0.2,
                    Math.sin(angle) * dist - 5
                );
                // Keep rocks away from cliff edge for now
                if (rock.position.z < cliffEdgeZ + 5) continue;
                rock.rotation.set(Math.random(), Math.random(), Math.random());
                rock.scale.y = 0.5 + Math.random() * 0.4;
                reefGroup.add(rock);
            }

            return reefGroup;
        }

        const reefBase = createReefBase();
        scene.add(reefBase);

        // ============== THE CLIFF - DRAMATIC DROP ==============
        function createCliff() {
            const cliffGroup = new THREE.Group();
            const cliffMat = new THREE.MeshLambertMaterial({ color: 0x2d2d2d, side: THREE.DoubleSide });
            const cliffLightMat = new THREE.MeshLambertMaterial({ color: 0x4a4a4a, side: THREE.DoubleSide });

            // Cliff edge - rocky lip you can see
            for (let i = 0; i < 20; i++) {
                const size = 1.5 + Math.random() * 3;
                const rockGeo = new THREE.DodecahedronGeometry(size, 0);
                const rock = new THREE.Mesh(rockGeo, cliffLightMat);
                rock.position.set(
                    -50 + i * 5 + (Math.random() - 0.5) * 3,
                    -size * 0.5,
                    cliffEdgeZ + (Math.random() - 0.5) * 2
                );
                rock.rotation.set(Math.random(), Math.random(), Math.random());
                rock.scale.set(1 + Math.random() * 0.5, 0.5 + Math.random() * 0.3, 1 + Math.random() * 0.5);
                cliffGroup.add(rock);
            }

            // Main cliff wall - vertical face going down
            const wallGeo = new THREE.PlaneGeometry(120, 80, 20, 15);
            const wallVerts = wallGeo.attributes.position.array;
            for (let i = 0; i < wallVerts.length; i += 3) {
                wallVerts[i + 2] += Math.random() * 3 - 1; // Rocky surface
            }
            wallGeo.computeVertexNormals();
            const cliffWall = new THREE.Mesh(wallGeo, cliffMat);
            cliffWall.position.set(0, -40, cliffEdgeZ - 1);
            cliffGroup.add(cliffWall);

            // Rocky outcrops on cliff face
            for (let i = 0; i < 30; i++) {
                const size = 1 + Math.random() * 2.5;
                const rockGeo = new THREE.DodecahedronGeometry(size, 0);
                const rock = new THREE.Mesh(rockGeo, i % 2 === 0 ? cliffMat : cliffLightMat);
                rock.position.set(
                    (Math.random() - 0.5) * 100,
                    -5 - Math.random() * 60,
                    cliffEdgeZ - 0.5 + Math.random() * 2
                );
                rock.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                rock.scale.z = 0.4;
                cliffGroup.add(rock);
            }

            // Ledges jutting out from cliff
            for (let i = 0; i < 10; i++) {
                const ledgeGeo = new THREE.BoxGeometry(5 + Math.random() * 8, 0.8, 2 + Math.random() * 2);
                const ledge = new THREE.Mesh(ledgeGeo, cliffLightMat);
                ledge.position.set(
                    (Math.random() - 0.5) * 80,
                    -8 - i * 6,
                    cliffEdgeZ + 0.5
                );
                cliffGroup.add(ledge);
            }

            // Deep abyss floor (far below)
            const abyssGeo = new THREE.PlaneGeometry(150, 80);
            const abyssMat = new THREE.MeshBasicMaterial({ color: 0x000205 });
            const abyss = new THREE.Mesh(abyssGeo, abyssMat);
            abyss.rotation.x = -Math.PI / 2;
            abyss.position.set(0, -80, cliffEdgeZ - 40);
            cliffGroup.add(abyss);

            return cliffGroup;
        }

        const cliff = createCliff();
        scene.add(cliff);

        // ============== CORAL - GROWING ON ROCKS ==============
        const corals = [];
        const coralColors = [0xff6b6b, 0xff8e72, 0xffa07a, 0xff7f50, 0xe74c3c, 0xf1c40f, 0x9b59b6, 0x1abc9c, 0xff69b4, 0x00ced1, 0xffb347];

        function createBranchCoral(color, scale = 1) {
            const group = new THREE.Group();
            const height = (1.2 + Math.random() * 1.8) * scale;
            const mat = new THREE.MeshLambertMaterial({ color: color });

            const trunkGeo = new THREE.CylinderGeometry(0.06 * scale, 0.14 * scale, height, 6);
            const trunk = new THREE.Mesh(trunkGeo, mat);
            trunk.position.y = height / 2;
            group.add(trunk);

            const branchCount = 4 + Math.floor(Math.random() * 5);
            for (let i = 0; i < branchCount; i++) {
                const bHeight = (0.3 + Math.random() * 0.6) * scale;
                const branchGeo = new THREE.CylinderGeometry(0.02 * scale, 0.05 * scale, bHeight, 5);
                const branch = new THREE.Mesh(branchGeo, mat);
                branch.position.y = height * 0.4 + Math.random() * height * 0.5;
                branch.position.x = (Math.random() - 0.5) * 0.4 * scale;
                branch.position.z = (Math.random() - 0.5) * 0.4 * scale;
                branch.rotation.x = (Math.random() - 0.5) * 1.0;
                branch.rotation.z = (Math.random() - 0.5) * 1.0;
                group.add(branch);
            }
            return group;
        }

        function createBrainCoral(color, scale = 1) {
            const geo = new THREE.SphereGeometry((0.4 + Math.random() * 0.4) * scale, 12, 12);
            const verts = geo.attributes.position.array;
            for (let i = 0; i < verts.length; i += 3) {
                verts[i] += (Math.random() - 0.5) * 0.1 * scale;
                verts[i + 1] += (Math.random() - 0.5) * 0.1 * scale;
                verts[i + 2] += (Math.random() - 0.5) * 0.1 * scale;
            }
            geo.computeVertexNormals();
            const mat = new THREE.MeshLambertMaterial({ color: color });
            const coral = new THREE.Mesh(geo, mat);
            coral.scale.y = 0.6;
            return coral;
        }

        function createFanCoral(color, scale = 1) {
            const group = new THREE.Group();
            const shape = new THREE.Shape();
            shape.moveTo(0, 0);
            shape.quadraticCurveTo(0.7 * scale, 1.5 * scale, 0, 2.2 * scale);
            shape.quadraticCurveTo(-0.7 * scale, 1.5 * scale, 0, 0);
            const geo = new THREE.ShapeGeometry(shape);
            const mat = new THREE.MeshLambertMaterial({ color: color, side: THREE.DoubleSide });
            const fan = new THREE.Mesh(geo, mat);
            fan.rotation.y = Math.random() * Math.PI * 2;
            group.add(fan);
            return group;
        }

        function createTubeCoral(color, scale = 1) {
            const group = new THREE.Group();
            const mat = new THREE.MeshLambertMaterial({ color: color });
            const count = 2 + Math.floor(Math.random() * 4);
            for (let i = 0; i < count; i++) {
                const h = (0.5 + Math.random() * 0.8) * scale;
                const tubeGeo = new THREE.CylinderGeometry(0.08 * scale, 0.12 * scale, h, 6, 1, true);
                const tube = new THREE.Mesh(tubeGeo, mat);
                tube.position.set((Math.random() - 0.5) * 0.3 * scale, h / 2, (Math.random() - 0.5) * 0.3 * scale);
                group.add(tube);
            }
            return group;
        }

        // Place corals on the reef rocks - clustered naturally
        function placeCoralsOnReef() {
            // Create coral clusters around rock formations
            const clusterCenters = [];

            // Define cluster areas on the reef
            for (let i = 0; i < 15; i++) {
                const angle = Math.random() * Math.PI * 2;
                const dist = 3 + Math.random() * 28;
                const cx = Math.cos(angle) * dist;
                const cz = Math.sin(angle) * dist - 3;
                // Don't place clusters past the cliff
                if (cz < cliffEdgeZ + 4) continue;
                clusterCenters.push({ x: cx, z: cz, size: 3 + Math.random() * 5 });
            }

            // Add corals in each cluster
            clusterCenters.forEach(cluster => {
                const coralCount = 8 + Math.floor(Math.random() * 12);
                const clusterColor = coralColors[Math.floor(Math.random() * coralColors.length)];

                for (let i = 0; i < coralCount; i++) {
                    const offsetAngle = Math.random() * Math.PI * 2;
                    const offsetDist = Math.random() * cluster.size;
                    const x = cluster.x + Math.cos(offsetAngle) * offsetDist;
                    const z = cluster.z + Math.sin(offsetAngle) * offsetDist;

                    if (z < cliffEdgeZ + 3) continue;

                    // Use cluster color with some variation
                    const useClusterColor = Math.random() > 0.3;
                    const color = useClusterColor ? clusterColor : coralColors[Math.floor(Math.random() * coralColors.length)];
                    const scale = 0.6 + Math.random() * 0.7;
                    const type = Math.floor(Math.random() * 4);

                    let coral;
                    if (type === 0) coral = createBranchCoral(color, scale);
                    else if (type === 1) coral = createBrainCoral(color, scale);
                    else if (type === 2) coral = createFanCoral(color, scale);
                    else coral = createTubeCoral(color, scale);

                    // Place on elevated reef area
                    coral.position.set(x, 0.3 + Math.random() * 0.3, z);
                    coral.rotation.y = Math.random() * Math.PI * 2;
                    scene.add(coral);
                    corals.push(coral);
                }
            });

            // Add some scattered individual corals for variety
            for (let i = 0; i < 25; i++) {
                const angle = Math.random() * Math.PI * 2;
                const dist = Math.random() * 35;
                const x = Math.cos(angle) * dist;
                const z = Math.sin(angle) * dist - 2;
                if (z < cliffEdgeZ + 4) continue;

                const color = coralColors[Math.floor(Math.random() * coralColors.length)];
                const scale = 0.5 + Math.random() * 0.5;
                const type = Math.floor(Math.random() * 4);

                let coral;
                if (type === 0) coral = createBranchCoral(color, scale);
                else if (type === 1) coral = createBrainCoral(color, scale);
                else if (type === 2) coral = createFanCoral(color, scale);
                else coral = createTubeCoral(color, scale);

                coral.position.set(x, 0.2, z);
                scene.add(coral);
                corals.push(coral);
            }
        }

        placeCoralsOnReef();

        // ============== SEAWEED ON SANDY AREAS ==============
        for (let i = 0; i < 30; i++) {
            const x = (Math.random() - 0.5) * 60;
            const z = 15 + Math.random() * 40; // On the sandy area behind player

            const seaweedGroup = new THREE.Group();
            const strandCount = 2 + Math.floor(Math.random() * 3);
            const seaweedMat = new THREE.MeshLambertMaterial({ color: 0x228b22 });

            for (let s = 0; s < strandCount; s++) {
                const h = 0.8 + Math.random() * 1.5;
                const geo = new THREE.CylinderGeometry(0.015, 0.03, h, 4);
                const strand = new THREE.Mesh(geo, seaweedMat);
                strand.position.set((Math.random() - 0.5) * 0.2, h / 2, (Math.random() - 0.5) * 0.2);
                seaweedGroup.add(strand);
            }
            seaweedGroup.position.set(x, 0, z);
            scene.add(seaweedGroup);
        }

        // ============== REALISTIC FISH ==============
        const allFish = [];
        const fishSchools = [];

        function createFish(color, accentColor, size = 0.25) {
            const group = new THREE.Group();
            const mat = new THREE.MeshLambertMaterial({ color: color });

            // Body - tapered ellipsoid
            const bodyGeo = new THREE.SphereGeometry(size, 10, 7);
            const bodyVerts = bodyGeo.attributes.position.array;
            for (let i = 0; i < bodyVerts.length; i += 3) {
                const taper = 1 - Math.pow(Math.abs(bodyVerts[i]) / size, 2) * 0.25;
                bodyVerts[i] *= 2;
                bodyVerts[i + 1] *= 0.65 * taper;
                bodyVerts[i + 2] *= 0.35 * taper;
            }
            bodyGeo.computeVertexNormals();
            group.add(new THREE.Mesh(bodyGeo, mat));

            // Tail
            const tailGroup = new THREE.Group();
            const tailShape = new THREE.Shape();
            tailShape.moveTo(0, 0);
            tailShape.lineTo(-size * 0.7, size * 0.5);
            tailShape.lineTo(-size * 0.25, 0);
            tailShape.lineTo(-size * 0.7, -size * 0.5);
            tailShape.lineTo(0, 0);
            const tail = new THREE.Mesh(new THREE.ShapeGeometry(tailShape), mat);
            tail.rotation.y = Math.PI / 2;
            tailGroup.position.x = -size * 1.6;
            tailGroup.add(tail);
            group.add(tailGroup);
            group.userData.tail = tailGroup;

            // Dorsal fin
            const dorsalShape = new THREE.Shape();
            dorsalShape.moveTo(0, 0);
            dorsalShape.lineTo(size * 0.4, size * 0.4);
            dorsalShape.lineTo(size * 0.6, size * 0.2);
            dorsalShape.lineTo(size * 0.5, 0);
            const dorsal = new THREE.Mesh(new THREE.ShapeGeometry(dorsalShape), new THREE.MeshLambertMaterial({ color: accentColor || color }));
            dorsal.position.set(-size * 0.1, size * 0.4, 0);
            dorsal.rotation.y = Math.PI / 2;
            group.add(dorsal);

            // Side fins
            const finShape = new THREE.Shape();
            finShape.moveTo(0, 0);
            finShape.quadraticCurveTo(size * 0.3, -size * 0.15, size * 0.4, -size * 0.4);
            finShape.lineTo(0, -size * 0.08);
            const finGeo = new THREE.ShapeGeometry(finShape);

            const finL = new THREE.Mesh(finGeo, mat);
            finL.position.set(size * 0.2, -size * 0.05, size * 0.15);
            finL.rotation.x = -0.25;
            group.add(finL);
            group.userData.finL = finL;

            const finR = new THREE.Mesh(finGeo, mat);
            finR.position.set(size * 0.2, -size * 0.05, -size * 0.15);
            finR.rotation.x = 0.25;
            finR.scale.z = -1;
            group.add(finR);
            group.userData.finR = finR;

            // Eyes
            const eyeGeo = new THREE.SphereGeometry(size * 0.1, 6, 6);
            const eyeWhite = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const eyeBlack = new THREE.MeshBasicMaterial({ color: 0x000000 });

            const eyeL = new THREE.Mesh(eyeGeo, eyeWhite);
            eyeL.position.set(size * 1.2, size * 0.12, size * 0.18);
            group.add(eyeL);
            const pupilL = new THREE.Mesh(new THREE.SphereGeometry(size * 0.05, 5, 5), eyeBlack);
            pupilL.position.set(size * 1.28, size * 0.12, size * 0.22);
            group.add(pupilL);

            const eyeR = new THREE.Mesh(eyeGeo, eyeWhite);
            eyeR.position.set(size * 1.2, size * 0.12, -size * 0.18);
            group.add(eyeR);
            const pupilR = new THREE.Mesh(new THREE.SphereGeometry(size * 0.05, 5, 5), eyeBlack);
            pupilR.position.set(size * 1.28, size * 0.12, -size * 0.22);
            group.add(pupilR);

            return group;
        }

        const fishColors = [
            [0xffeb3b, 0xff9800],
            [0x03a9f4, 0x0277bd],
            [0xff9800, 0xffffff],
            [0x4caf50, 0x8bc34a],
            [0xe91e63, 0xf48fb1],
            [0x00bcd4, 0x26c6da],
            [0x9c27b0, 0xce93d8],
            [0xff5722, 0xffab91]
        ];

        // Create fish schools swimming around the reef
        for (let s = 0; s < 10; s++) {
            const colors = fishColors[s % fishColors.length];
            const center = new THREE.Vector3(
                (Math.random() - 0.5) * 50,
                2 + Math.random() * 7,
                (Math.random() - 0.5) * 35
            );
            if (center.z < cliffEdgeZ + 8) center.z = cliffEdgeZ + 8 + Math.random() * 15;

            const school = { center: center, fish: [], dir: Math.random() * Math.PI * 2 };
            const count = 5 + Math.floor(Math.random() * 7);

            for (let i = 0; i < count; i++) {
                const fish = createFish(colors[0], colors[1], 0.12 + Math.random() * 0.1);
                fish.position.set(
                    center.x + (Math.random() - 0.5) * 4,
                    center.y + (Math.random() - 0.5) * 2,
                    center.z + (Math.random() - 0.5) * 4
                );
                fish.userData.offset = Math.random() * Math.PI * 2;
                fish.userData.speed = 0.25 + Math.random() * 0.35;
                fish.userData.radius = 2 + Math.random() * 4;
                fish.userData.baseY = fish.position.y;
                scene.add(fish);
                school.fish.push(fish);
                allFish.push(fish);
            }
            fishSchools.push(school);
        }

        // Solo fish
        for (let i = 0; i < 12; i++) {
            const colors = fishColors[Math.floor(Math.random() * fishColors.length)];
            const fish = createFish(colors[0], colors[1], 0.18 + Math.random() * 0.15);
            fish.position.set(
                (Math.random() - 0.5) * 55,
                1.5 + Math.random() * 9,
                (Math.random() - 0.5) * 40
            );
            if (fish.position.z < cliffEdgeZ + 6) fish.position.z = cliffEdgeZ + 6 + Math.random() * 12;
            fish.userData.offset = Math.random() * Math.PI * 2;
            fish.userData.speed = 0.15 + Math.random() * 0.25;
            fish.userData.radius = 4 + Math.random() * 8;
            fish.userData.baseY = fish.position.y;
            fish.userData.solo = true;
            scene.add(fish);
            allFish.push(fish);
        }

        // ============== PARTICLES ==============
        const particleGeo = new THREE.BufferGeometry();
        const particlePos = new Float32Array(300 * 3);
        for (let i = 0; i < 300 * 3; i += 3) {
            particlePos[i] = (Math.random() - 0.5) * 80;
            particlePos[i + 1] = Math.random() * 16;
            particlePos[i + 2] = (Math.random() - 0.5) * 80;
        }
        particleGeo.setAttribute('position', new THREE.BufferAttribute(particlePos, 3));
        const particleMat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.06, transparent: true, opacity: 0.4 });
        const particles = new THREE.Points(particleGeo, particleMat);
        scene.add(particles);

        // ============== PLAYER STATE ==============
        const State = {
            phase: 'exploring',
            keys: { w: false, a: false, s: false, d: false, space: false },
            canMove: true,
            isFalling: false,
            fallSpeed: 0
        };

        const euler = new THREE.Euler(0, 0, 0, 'YXZ');
        let isPointerLocked = false;

        document.addEventListener('click', () => {
            if (!isPointerLocked && State.phase === 'exploring') {
                renderer.domElement.requestPointerLock();
            }
        });
        document.addEventListener('pointerlockchange', () => {
            isPointerLocked = document.pointerLockElement === renderer.domElement;
        });
        document.addEventListener('mousemove', (e) => {
            if (!isPointerLocked || !State.canMove) return;
            euler.setFromQuaternion(camera.quaternion);
            euler.y -= e.movementX * 0.002;
            euler.x -= e.movementY * 0.002;
            euler.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, euler.x));
            camera.quaternion.setFromEuler(euler);
        });
        document.addEventListener('keydown', (e) => {
            const k = e.key.toLowerCase();
            if (k === 'w') State.keys.w = true;
            if (k === 'a') State.keys.a = true;
            if (k === 's') State.keys.s = true;
            if (k === 'd') State.keys.d = true;
            if (e.key === ' ') State.keys.space = true;
        });
        document.addEventListener('keyup', (e) => {
            const k = e.key.toLowerCase();
            if (k === 'w') State.keys.w = false;
            if (k === 'a') State.keys.a = false;
            if (k === 's') State.keys.s = false;
            if (k === 'd') State.keys.d = false;
            if (e.key === ' ') State.keys.space = false;
        });

        // ============== UI ==============
        const introText = document.getElementById('intro-text');
        const depthIndicator = document.getElementById('depth-indicator');
        const warningText = document.getElementById('warning-text');
        const fadeOverlay = document.getElementById('fade-overlay');
        const controlsHint = document.getElementById('controls-hint');

        setTimeout(() => { introText.classList.add('visible'); setTimeout(() => introText.classList.remove('visible'), 4000); }, 1000);
        setTimeout(() => { controlsHint.style.opacity = '0'; }, 8000);

        // ============== ANIMATION ==============
        const clock = new THREE.Clock();
        let time = 0;

        function updateFish(delta) {
            time += delta;

            fishSchools.forEach(school => {
                school.dir += (Math.random() - 0.5) * 0.015;
                school.center.x += Math.cos(school.dir) * delta * 0.4;
                school.center.z += Math.sin(school.dir) * delta * 0.4;

                if (school.center.x < -30) school.dir = 0;
                if (school.center.x > 30) school.dir = Math.PI;
                if (school.center.z < cliffEdgeZ + 10) school.dir = Math.PI / 2;
                if (school.center.z > 35) school.dir = -Math.PI / 2;

                school.fish.forEach(fish => {
                    const d = fish.userData;
                    const angle = time * d.speed + d.offset;
                    fish.position.x += (school.center.x + Math.cos(angle) * d.radius - fish.position.x) * delta * 0.4;
                    fish.position.z += (school.center.z + Math.sin(angle) * d.radius - fish.position.z) * delta * 0.4;
                    fish.position.y = d.baseY + Math.sin(time * 0.7 + d.offset) * 0.6;

                    const targetAngle = Math.atan2(
                        school.center.z + Math.sin(angle + 0.1) * d.radius - fish.position.z,
                        school.center.x + Math.cos(angle + 0.1) * d.radius - fish.position.x
                    );
                    fish.rotation.y = -targetAngle;

                    if (fish.userData.tail) fish.userData.tail.rotation.y = Math.sin(time * 10 + d.offset) * 0.35;
                    if (fish.userData.finL) {
                        fish.userData.finL.rotation.x = -0.25 + Math.sin(time * 5 + d.offset) * 0.15;
                        fish.userData.finR.rotation.x = 0.25 - Math.sin(time * 5 + d.offset) * 0.15;
                    }
                });
            });

            allFish.filter(f => f.userData.solo).forEach(fish => {
                const d = fish.userData;
                const angle = time * d.speed + d.offset;
                fish.position.x += Math.cos(angle) * delta * 1.5;
                fish.position.z += Math.sin(angle * 0.6) * delta * 1.2;
                fish.position.y = d.baseY + Math.sin(time * 0.4 + d.offset) * 0.8;

                if (fish.position.x > 40) fish.position.x = -40;
                if (fish.position.x < -40) fish.position.x = 40;
                if (fish.position.z > 35) fish.position.z = cliffEdgeZ + 10;
                if (fish.position.z < cliffEdgeZ + 6) fish.position.z = 35;

                fish.rotation.y = -Math.atan2(Math.sin(angle * 0.6) * 1.2, Math.cos(angle) * 1.5);
                if (fish.userData.tail) fish.userData.tail.rotation.y = Math.sin(time * 8 + d.offset) * 0.4;
            });
        }

        function updateWater() {
            const pos = waterSurface.geometry.attributes.position.array;
            for (let i = 0; i < pos.length; i += 3) {
                pos[i + 2] = Math.sin(pos[i] * 0.04 + time * 0.7) * 0.6 + Math.cos(pos[i + 1] * 0.04 + time * 0.5) * 0.5;
            }
            waterSurface.geometry.attributes.position.needsUpdate = true;
        }

        function updateParticles() {
            const pos = particles.geometry.attributes.position.array;
            for (let i = 0; i < pos.length; i += 3) {
                pos[i + 1] += 0.012;
                if (pos[i + 1] > 16) pos[i + 1] = 0;
            }
            particles.geometry.attributes.position.needsUpdate = true;
        }

        function updatePlayer(delta) {
            if (!State.canMove) return;

            const speed = 5 * delta;
            const dir = new THREE.Vector3();
            const forward = new THREE.Vector3();
            camera.getWorldDirection(forward);
            forward.y = 0;
            forward.normalize();
            const right = new THREE.Vector3().crossVectors(forward, new THREE.Vector3(0, 1, 0));

            if (State.keys.w) dir.add(forward);
            if (State.keys.s) dir.sub(forward);
            if (State.keys.d) dir.add(right);
            if (State.keys.a) dir.sub(right);

            if (dir.length() > 0) {
                dir.normalize();
                camera.position.x += dir.x * speed;
                camera.position.z += dir.z * speed;
            }

            if (State.keys.space) camera.position.y += speed * 0.6;
            else if (!State.isFalling) camera.position.y -= speed * 0.06;

            if (State.phase === 'exploring') {
                camera.position.y = Math.max(1.5, Math.min(13, camera.position.y));
                camera.position.x = Math.max(-30, Math.min(30, camera.position.x));
                camera.position.z = Math.min(45, camera.position.z);
            }

            const depth = Math.round(18 - camera.position.y + 5);
            depthIndicator.textContent = `Depth: ${depth}m`;
        }

        function checkCliff() {
            if (State.phase !== 'exploring') return;

            const distToEdge = cliffEdgeZ - camera.position.z;

            if (distToEdge < 12 && distToEdge > 0) {
                warningText.classList.add('visible');
                const dark = 1 - distToEdge / 12;
                scene.fog = new THREE.FogExp2(new THREE.Color(0.0, 0.35 - dark * 0.25, 0.55 - dark * 0.4), 0.015 + dark * 0.025);
                scene.background = new THREE.Color(0.0, 0.35 - dark * 0.2, 0.55 - dark * 0.3);
            } else if (distToEdge >= 12) {
                warningText.classList.remove('visible');
                scene.fog = new THREE.FogExp2(0x0088aa, 0.015);
                scene.background = new THREE.Color(0x0088aa);
            }

            if (camera.position.z < cliffEdgeZ) triggerFall();
        }

        function triggerFall() {
            State.phase = 'falling';
            State.isFalling = true;
            State.canMove = false;
            State.fallSpeed = 0;
            warningText.textContent = "You're falling...";
            warningText.classList.add('visible');
            document.exitPointerLock();
            scene.fog = new THREE.FogExp2(0x000408, 0.035);
            scene.background = new THREE.Color(0x000408);
            sunLight.intensity = 0.1;
            ambientLight.intensity = 0.05;
            createBubbles();
        }

        function createBubbles() {
            for (let i = 0; i < 20; i++) {
                setTimeout(() => {
                    const b = document.createElement('div');
                    b.className = 'bubble';
                    b.style.left = (Math.random() * 100) + '%';
                    b.style.bottom = '0';
                    const sz = (8 + Math.random() * 20) + 'px';
                    b.style.width = sz;
                    b.style.height = sz;
                    document.body.appendChild(b);
                    setTimeout(() => b.remove(), 4000);
                }, i * 180);
            }
        }

        function updateFalling(delta) {
            if (State.phase !== 'falling') return;
            State.fallSpeed += delta * 2;
            camera.position.y -= State.fallSpeed;
            camera.position.z -= delta * 3;
            camera.rotation.z = Math.sin(time * 7) * 0.025;
            camera.rotation.x = Math.sin(time * 4) * 0.015 - 0.25;
            const depth = Math.round(18 - camera.position.y + 5);
            depthIndicator.textContent = `Depth: ${depth}m`;
            scene.fog.density = 0.035 + (Math.abs(camera.position.y) / 60);
            if (camera.position.y < -55) endExperience();
        }

        function endExperience() {
            State.phase = 'ended';
            warningText.textContent = "The deep ocean...";
            setTimeout(() => {
                fadeOverlay.classList.add('visible');
                setTimeout(() => {
                    warningText.style.zIndex = '101';
                    warningText.style.color = '#ffffff';
                    warningText.textContent = "You faced the abyss.";
                }, 2000);
            }, 2000);
        }

        function animate() {
            requestAnimationFrame(animate);
            const delta = Math.min(clock.getDelta(), 0.1);
            time += delta;

            updateFish(delta);
            updateWater();
            updateParticles();
            updatePlayer(delta);
            checkCliff();
            updateFalling(delta);

            if (State.phase === 'exploring') camera.position.y += Math.sin(time * 0.45) * 0.002;

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
