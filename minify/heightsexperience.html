<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Heights - Glass Skywalk</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; background: #1a2a3a; font-family: 'Georgia', serif; }
        #canvas-container { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        .prompt-overlay {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-size: 1.8rem; text-align: center;
            pointer-events: none; z-index: 50; opacity: 0; transition: opacity 1s ease;
            text-shadow: 0 2px 20px rgba(0,0,0,0.8); max-width: 80%; line-height: 1.6;
        }
        .prompt-overlay.visible { opacity: 1; }
        #crosshair { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 20px; height: 20px; z-index: 40; pointer-events: none; opacity: 0.4; }
        #crosshair::before, #crosshair::after { content: ''; position: absolute; background: rgba(255,255,255,0.5); }
        #crosshair::before { width: 2px; height: 20px; left: 9px; }
        #crosshair::after { width: 20px; height: 2px; top: 9px; }
        #height-indicator {
            position: fixed; top: 30px; right: 30px;
            color: rgba(255,255,255,0.9); font-size: 1.1rem; z-index: 50;
            font-family: 'Courier New', monospace;
            text-shadow: 0 0 10px rgba(0,0,0,0.8);
            background: rgba(0,0,0,0.3); padding: 8px 16px; border-radius: 6px;
        }
        #controls-hint {
            position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%);
            color: rgba(255,255,255,0.6); font-size: 0.9rem; z-index: 50;
            text-shadow: 0 0 10px rgba(0,0,0,0.8); transition: opacity 1s;
        }
        #fade-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: black; z-index: 100; opacity: 0;
            pointer-events: none; transition: opacity 2s ease;
        }
        #fade-overlay.visible { opacity: 1; pointer-events: all; }
        #phase-label {
            position: fixed; top: 20px; left: 20px;
            color: #fff; font-size: 13px; z-index: 50;
            background: rgba(0,0,0,0.4); padding: 6px 14px; border-radius: 5px;
            text-transform: uppercase; letter-spacing: 2px;
            pointer-events: none; opacity: 0; transition: opacity 0.8s;
        }
        #phase-label.visible { opacity: 1; }
        #wind-indicator {
            position: fixed; top: 70px; right: 30px;
            color: rgba(255,255,255,0.6); font-size: 0.85rem; z-index: 50;
            font-family: 'Courier New', monospace;
            opacity: 0; transition: opacity 0.8s;
        }
        #wind-indicator.visible { opacity: 1; }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    <div id="crosshair"></div>
    <div class="prompt-overlay" id="intro-text"></div>
    <div id="height-indicator">Floor: Lobby</div>
    <div id="controls-hint">WASD to walk | Mouse to look</div>
    <div id="phase-label"></div>
    <div id="wind-indicator"></div>
    <div id="fade-overlay"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
    (function() {
        'use strict';

        // ═══════════════════════════════════════════════════
        //  SCENE SETUP
        // ═══════════════════════════════════════════════════
        var scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 200, 1200);

        var camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 2000);
        camera.position.set(0, 1.7, 0); // Eye height

        var renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        var clock = new THREE.Clock();
        var time = 0;

        // ═══════════════════════════════════════════════════
        //  GAME STATE
        // ═══════════════════════════════════════════════════
        var State = {
            phase: 'lobby',       // lobby, elevator_up, observation, glass_floor, skywalk, edge, return, ended
            playerHeight: 0,      // Ground level floor number (in meters above ground)
            elevatorFloor: 0,     // Current elevator floor display
            targetFloor: 250,     // 250 meters = ~83 floors
            elevatorSpeed: 0,
            elevatorAccel: 0.08,
            elevatorMaxSpeed: 2.5,
            playerOnGlass: false,
            windStrength: 0,
            swayAmount: 0,
            lookingDown: false,
            walkSpeed: 3.0,
            mouseSensitivity: 0.002,
            canMove: false,
            canClick: false,
            transitioning: false
        };

        // Mouse / keyboard
        var mouse = { x: 0, y: 0 };
        var keys = {};
        var euler = new THREE.Euler(0, 0, 0, 'YXZ');
        var isPointerLocked = false;

        // DOM refs
        var introText = document.getElementById('intro-text');
        var heightIndicator = document.getElementById('height-indicator');
        var controlsHint = document.getElementById('controls-hint');
        var fadeOverlay = document.getElementById('fade-overlay');
        var phaseLabel = document.getElementById('phase-label');
        var windIndicator = document.getElementById('wind-indicator');

        // ═══════════════════════════════════════════════════
        //  AUDIO
        // ═══════════════════════════════════════════════════
        var audioCtx = null;
        var masterGain = null;
        var windNode = null;
        var elevatorHum = null;

        function initAudio() {
            if (audioCtx) return;
            try {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                masterGain = audioCtx.createGain();
                masterGain.gain.value = 0.3;
                masterGain.connect(audioCtx.destination);
            } catch (e) {}
        }

        function startWindSound() {
            if (!audioCtx || windNode) return;
            var buf = audioCtx.createBuffer(1, audioCtx.sampleRate * 4, audioCtx.sampleRate);
            var d = buf.getChannelData(0);
            for (var i = 0; i < d.length; i++) d[i] = (Math.random() * 2 - 1);
            windNode = audioCtx.createBufferSource();
            windNode.buffer = buf;
            windNode.loop = true;
            var filter = audioCtx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.value = 400;
            var g = audioCtx.createGain();
            g.gain.value = 0;
            windNode.connect(filter);
            filter.connect(g);
            g.connect(masterGain);
            windNode.start();
            windNode._gain = g;
            windNode._filter = filter;
        }

        function updateWindVolume(vol) {
            if (windNode && windNode._gain) {
                windNode._gain.gain.setTargetAtTime(Math.min(vol, 0.6), audioCtx.currentTime, 0.5);
            }
        }

        function playDing() {
            if (!audioCtx) return;
            var osc = audioCtx.createOscillator();
            var g = audioCtx.createGain();
            osc.type = 'sine';
            osc.frequency.value = 1400;
            g.gain.setValueAtTime(0.15, audioCtx.currentTime);
            g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 1.0);
            osc.connect(g);
            g.connect(masterGain);
            osc.start();
            osc.stop(audioCtx.currentTime + 1.0);
        }

        function startElevatorHum() {
            if (!audioCtx || elevatorHum) return;
            var osc = audioCtx.createOscillator();
            osc.type = 'sawtooth';
            osc.frequency.value = 55;
            var g = audioCtx.createGain();
            g.gain.value = 0;
            var filter = audioCtx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.value = 120;
            osc.connect(filter);
            filter.connect(g);
            g.connect(masterGain);
            osc.start();
            elevatorHum = { osc: osc, gain: g };
        }

        function stopElevatorHum() {
            if (elevatorHum) {
                elevatorHum.gain.gain.setTargetAtTime(0, audioCtx.currentTime, 0.3);
                var h = elevatorHum;
                setTimeout(function() { h.osc.stop(); }, 1000);
                elevatorHum = null;
            }
        }

        // ═══════════════════════════════════════════════════
        //  MATERIALS
        // ═══════════════════════════════════════════════════
        var MAT = {
            concrete: new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 0.9 }),
            marble: new THREE.MeshStandardMaterial({ color: 0xe8e0d0, roughness: 0.3, metalness: 0.05 }),
            metal: new THREE.MeshStandardMaterial({ color: 0xaaaaaa, roughness: 0.2, metalness: 0.9 }),
            darkMetal: new THREE.MeshStandardMaterial({ color: 0x444444, roughness: 0.3, metalness: 0.85 }),
            glass: new THREE.MeshPhysicalMaterial({ color: 0xddeeff, transparent: true, opacity: 0.12, roughness: 0.0, metalness: 0.1, transmission: 0.95, thickness: 0.5, ior: 1.5, reflectivity: 0.5, envMapIntensity: 1.0, side: THREE.DoubleSide }),
            glassPanel: new THREE.MeshPhysicalMaterial({ color: 0xeef4ff, transparent: true, opacity: 0.06, roughness: 0.0, metalness: 0.0, transmission: 0.97, thickness: 0.3, ior: 1.52, reflectivity: 0.4, envMapIntensity: 0.8, side: THREE.DoubleSide }),
            glassFence: new THREE.MeshPhysicalMaterial({ color: 0xddeeff, transparent: true, opacity: 0.1, roughness: 0.0, metalness: 0.05, transmission: 0.93, thickness: 0.4, ior: 1.5, reflectivity: 0.45, envMapIntensity: 0.9, side: THREE.DoubleSide }),
            building: new THREE.MeshStandardMaterial({ color: 0x556677, roughness: 0.7 }),
            buildingDark: new THREE.MeshStandardMaterial({ color: 0x334455, roughness: 0.8 }),
            sky: new THREE.MeshBasicMaterial({ color: 0x87CEEB }),
            white: new THREE.MeshStandardMaterial({ color: 0xf0f0f0, roughness: 0.6 }),
            carpet: new THREE.MeshStandardMaterial({ color: 0x2a2a3a, roughness: 0.95 }),
            wood: new THREE.MeshStandardMaterial({ color: 0x8b6b3d, roughness: 0.8 }),
            railing: new THREE.MeshStandardMaterial({ color: 0xcccccc, roughness: 0.15, metalness: 0.95 }),
            ground: new THREE.MeshStandardMaterial({ color: 0x3a3a3a, roughness: 0.9 }),
            road: new THREE.MeshStandardMaterial({ color: 0x2a2a2a, roughness: 0.95 }),
            grass: new THREE.MeshStandardMaterial({ color: 0x3d7a1a, roughness: 0.95 })
        };

        // ═══════════════════════════════════════════════════
        //  SCENE GROUPS
        // ═══════════════════════════════════════════════════
        var lobbyGroup = new THREE.Group();
        var elevatorGroup = new THREE.Group();
        var observationGroup = new THREE.Group();
        var skywalkGroup = new THREE.Group();
        var cityGroup = new THREE.Group();
        var cloudsGroup = new THREE.Group();
        scene.add(lobbyGroup, elevatorGroup, observationGroup, skywalkGroup, cityGroup, cloudsGroup);

        // ═══════════════════════════════════════════════════
        //  LIGHTING
        // ═══════════════════════════════════════════════════
        var ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        var sunLight = new THREE.DirectionalLight(0xfffff0, 1.0);
        sunLight.position.set(50, 300, 80);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 2048;
        sunLight.shadow.mapSize.height = 2048;
        sunLight.shadow.camera.near = 0.5;
        sunLight.shadow.camera.far = 1200;
        sunLight.shadow.camera.left = -100;
        sunLight.shadow.camera.right = 100;
        sunLight.shadow.camera.top = 100;
        sunLight.shadow.camera.bottom = -100;
        scene.add(sunLight);

        var hemiLight = new THREE.HemisphereLight(0x87ceeb, 0x444444, 0.4);
        scene.add(hemiLight);

        // ═══════════════════════════════════════════════════
        //  CITY (visible below from observation deck)
        // ═══════════════════════════════════════════════════
        function buildCity() {
            // Ground plane far below
            var groundGeo = new THREE.PlaneGeometry(2000, 2000);
            var ground = new THREE.Mesh(groundGeo, MAT.ground);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = 0;
            ground.receiveShadow = true;
            cityGroup.add(ground);

            // Grid of roads
            var roadMat = MAT.road;
            for (var rx = -400; rx <= 400; rx += 80) {
                var road = new THREE.Mesh(new THREE.PlaneGeometry(12, 800), roadMat);
                road.rotation.x = -Math.PI / 2;
                road.position.set(rx, 0.05, 0);
                cityGroup.add(road);
            }
            for (var rz = -400; rz <= 400; rz += 80) {
                var roadZ = new THREE.Mesh(new THREE.PlaneGeometry(800, 12), roadMat);
                roadZ.rotation.x = -Math.PI / 2;
                roadZ.position.set(0, 0.05, rz);
                cityGroup.add(roadZ);
            }

            // Buildings (varied heights with some supertall skyscrapers)
            var buildingColors = [0x556677, 0x667788, 0x445566, 0x778899, 0x5a6a7a, 0x4a5a6a, 0x3d4d5d, 0x6a7a8a];
            var glassColors = [0x88bbdd, 0x77aacc, 0x99ccee, 0x6699bb];
            var winGeo = new THREE.PlaneGeometry(1.2, 1.8);
            var winLitColors = [0xffffcc, 0xaaccff, 0xffeedd, 0xccddff];

            for (var bx = -380; bx <= 380; bx += 40) {
                for (var bz = -380; bz <= 380; bz += 40) {
                    // Skip the center where our tower is
                    if (Math.abs(bx) < 35 && Math.abs(bz) < 35) continue;

                    var dist = Math.sqrt(bx * bx + bz * bz);
                    // Buildings near center are taller (downtown effect)
                    var maxH = dist < 120 ? 350 : dist < 250 ? 200 : 100;
                    var minH = dist < 120 ? 40 : 15;
                    var bHeight = minH + Math.random() * (maxH - minH);
                    var bWidth = 10 + Math.random() * 22;
                    var bDepth = 10 + Math.random() * 22;
                    var offX = (Math.random() - 0.5) * 15;
                    var offZ = (Math.random() - 0.5) * 15;

                    var colorIdx = Math.floor(Math.random() * buildingColors.length);
                    var bMat = new THREE.MeshStandardMaterial({
                        color: buildingColors[colorIdx],
                        roughness: 0.5 + Math.random() * 0.3,
                        metalness: 0.1 + Math.random() * 0.2
                    });
                    var bGeo = new THREE.BoxGeometry(bWidth, bHeight, bDepth);
                    var bMesh = new THREE.Mesh(bGeo, bMat);
                    var bPosX = bx + offX, bPosZ = bz + offZ;
                    bMesh.position.set(bPosX, bHeight / 2, bPosZ);
                    bMesh.castShadow = true;
                    bMesh.receiveShadow = true;
                    cityGroup.add(bMesh);

                    // Tall buildings get a narrower upper section (setback)
                    var hasSetback = bHeight > 150 && Math.random() > 0.4;
                    var baseHeight = bHeight; // save for window placement
                    var upperW, upperD, upperH;
                    if (hasSetback) {
                        upperH = bHeight * 0.3;
                        upperW = bWidth * 0.65;
                        upperD = bDepth * 0.65;
                        var upper = new THREE.Mesh(
                            new THREE.BoxGeometry(upperW, upperH, upperD),
                            new THREE.MeshStandardMaterial({ color: buildingColors[(colorIdx + 1) % buildingColors.length], roughness: 0.4, metalness: 0.25 })
                        );
                        upper.position.set(bPosX, bHeight + upperH / 2, bPosZ);
                        upper.castShadow = true;
                        cityGroup.add(upper);
                        bHeight += upperH; // total height for rooftop features
                    }

                    // Rooftop details for tall buildings
                    if (bHeight > 80) {
                        var roofRand = Math.random();
                        if (roofRand > 0.6) {
                            // Antenna/spire
                            var antH = 8 + Math.random() * 15;
                            var ant = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.4, antH, 6), MAT.metal);
                            ant.position.set(bPosX, bHeight + antH / 2, bPosZ);
                            cityGroup.add(ant);
                        } else if (roofRand > 0.35) {
                            // Rooftop mechanical box
                            var mechW = bWidth * 0.3, mechH = 3 + Math.random() * 4;
                            var mech = new THREE.Mesh(
                                new THREE.BoxGeometry(mechW, mechH, mechW),
                                new THREE.MeshStandardMaterial({ color: 0x555555, roughness: 0.8 })
                            );
                            mech.position.set(bPosX, bHeight + mechH / 2, bPosZ);
                            cityGroup.add(mech);
                        } else {
                            // Helipad (flat circle on roof)
                            var pad = new THREE.Mesh(new THREE.CylinderGeometry(bWidth * 0.3, bWidth * 0.3, 0.2, 16), new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 0.6 }));
                            pad.position.set(bPosX, bHeight + 0.1, bPosZ);
                            cityGroup.add(pad);
                            // H marking
                            var hMark = new THREE.Mesh(new THREE.PlaneGeometry(bWidth * 0.15, bWidth * 0.2), new THREE.MeshBasicMaterial({ color: 0xffff00 }));
                            hMark.rotation.x = -Math.PI / 2;
                            hMark.position.set(bPosX, bHeight + 0.22, bPosZ);
                            cityGroup.add(hMark);
                        }
                    }

                    // Helper to add windows to a building section
                    function addWindows(cx, cz, secW, secD, secH, yStart) {
                        var wRows = Math.min(Math.floor(secH / 5), 40);
                        var wColsW = Math.floor(secW / 3.5);
                        var wColsD = Math.floor(secD / 3.5);
                        var secFaces = [
                            { axis: 'x', offset: secW / 2 + 0.05, cols: wColsD, span: secD, rotY: Math.PI / 2 },
                            { axis: 'x', offset: -(secW / 2 + 0.05), cols: wColsD, span: secD, rotY: -Math.PI / 2 },
                            { axis: 'z', offset: secD / 2 + 0.05, cols: wColsW, span: secW, rotY: 0 },
                            { axis: 'z', offset: -(secD / 2 + 0.05), cols: wColsW, span: secW, rotY: Math.PI }
                        ];
                        for (var fi = 0; fi < secFaces.length; fi++) {
                            var face = secFaces[fi];
                            for (var wr = 0; wr < wRows; wr++) {
                                for (var wc = 0; wc < face.cols; wc++) {
                                    if (Math.random() > 0.45) continue;
                                    var wMat = new THREE.MeshBasicMaterial({ color: winLitColors[Math.floor(Math.random() * winLitColors.length)] });
                                    var w = new THREE.Mesh(winGeo, wMat);
                                    var wy = yStart + 3 + wr * 5;
                                    var wOff = -face.span / 2 + 2 + wc * 3.5;
                                    if (face.axis === 'x') {
                                        w.position.set(cx + face.offset, wy, cz + wOff);
                                    } else {
                                        w.position.set(cx + wOff, wy, cz + face.offset);
                                    }
                                    w.rotation.y = face.rotY;
                                    cityGroup.add(w);
                                }
                            }
                        }
                    }

                    // Windows on base section
                    if (baseHeight > 25) {
                        addWindows(bPosX, bPosZ, bWidth, bDepth, baseHeight, 0);
                    }
                    // Windows on upper setback section (narrower dimensions)
                    if (hasSetback) {
                        addWindows(bPosX, bPosZ, upperW, upperD, upperH, baseHeight);
                    }
                }
            }

            // Small cars on roads (colored boxes)
            var carColors = [0xff3333, 0x3333ff, 0xffff33, 0x33ff33, 0xffffff, 0x333333];
            for (var ci = 0; ci < 100; ci++) {
                var carGeo = new THREE.BoxGeometry(2, 1.2, 4);
                var carMat = new THREE.MeshStandardMaterial({
                    color: carColors[Math.floor(Math.random() * carColors.length)],
                    roughness: 0.4, metalness: 0.3
                });
                var car = new THREE.Mesh(carGeo, carMat);
                var cx, cz;
                var onRoadX = Math.random() > 0.5;
                if (onRoadX) {
                    var roadIdx = Math.floor(Math.random() * 11) - 5;
                    cx = roadIdx * 80 + (Math.random() - 0.5) * 4;
                    cz = (Math.random() - 0.5) * 700;
                    car.rotation.y = 0;
                } else {
                    var roadIdxZ = Math.floor(Math.random() * 11) - 5;
                    cx = (Math.random() - 0.5) * 700;
                    cz = roadIdxZ * 80 + (Math.random() - 0.5) * 4;
                    car.rotation.y = Math.PI / 2;
                }
                // Skip cars inside tower footprint
                if (Math.abs(cx) < 20 && Math.abs(cz) < 20) continue;
                car.position.set(cx, 0.6, cz);
                cityGroup.add(car);
            }

            // Parks (green patches)
            for (var pi = 0; pi < 8; pi++) {
                var px = (Math.random() - 0.5) * 500;
                var pz = (Math.random() - 0.5) * 500;
                // Skip parks inside tower/lobby footprint
                if (Math.abs(px) < 30 && Math.abs(pz) < 30) continue;
                var parkGeo = new THREE.PlaneGeometry(25 + Math.random() * 20, 25 + Math.random() * 20);
                var park = new THREE.Mesh(parkGeo, MAT.grass);
                park.rotation.x = -Math.PI / 2;
                park.position.set(px, 0.1, pz);
                cityGroup.add(park);
            }
        }

        // ═══════════════════════════════════════════════════
        //  OUR SKYSCRAPER (center of the city)
        // ═══════════════════════════════════════════════════
        var TOWER_HEIGHT = 550; // meters (supertall skyscraper)
        var TOWER_WIDTH = 30;
        var OBS = { w: 22, d: 22, h: 4 };
        var OBSERVATION_Y = TOWER_HEIGHT - OBS.h - 2; // observation deck inside the crown (544m)

        function buildTower() {
            var towerMat = new THREE.MeshStandardMaterial({ color: 0x6688aa, roughness: 0.3, metalness: 0.4 });
            var towerAccent = new THREE.MeshStandardMaterial({ color: 0x556688, roughness: 0.2, metalness: 0.5 });

            // Elevator shaft gap (slightly larger than elevator for clearance)
            var SHAFT = 4;

            // Helper: build a tower section as 4 walls (hollow with shaft gap)
            function addTowerSection(secW, secH, yOff, mat, customShaft) {
                var halfW = secW / 2;
                var halfS = (customShaft || SHAFT) / 2;
                // Front wall (full width, from shaft edge to building edge in Z)
                var frontDepth = halfW - halfS;
                if (frontDepth > 0) {
                    var front = new THREE.Mesh(new THREE.BoxGeometry(secW, secH, frontDepth), mat);
                    front.position.set(0, yOff + secH / 2, halfS + frontDepth / 2);
                    front.castShadow = true;
                    cityGroup.add(front);
                    var back = new THREE.Mesh(new THREE.BoxGeometry(secW, secH, frontDepth), mat);
                    back.position.set(0, yOff + secH / 2, -(halfS + frontDepth / 2));
                    back.castShadow = true;
                    cityGroup.add(back);
                }
                // Side walls (only spanning the shaft gap in Z, from shaft edge to building edge in X)
                var sideWidth = halfW - halfS;
                if (sideWidth > 0) {
                    var left = new THREE.Mesh(new THREE.BoxGeometry(sideWidth, secH, SHAFT), mat);
                    left.position.set(-(halfS + sideWidth / 2), yOff + secH / 2, 0);
                    left.castShadow = true;
                    cityGroup.add(left);
                    var right = new THREE.Mesh(new THREE.BoxGeometry(sideWidth, secH, SHAFT), mat);
                    right.position.set(halfS + sideWidth / 2, yOff + secH / 2, 0);
                    right.castShadow = true;
                    cityGroup.add(right);
                }
            }

            // Lower section — split into ground floor (lobby cutout) and upper shaft
            var sec1H = 350;
            var LOBBY_H = 7; // lobby ceiling + margin
            var LOBBY_GAP = 22; // lobby-sized opening at ground floor

            // Ground floor base (0 to LOBBY_H) — large opening for lobby
            addTowerSection(TOWER_WIDTH, LOBBY_H, 0, towerMat, LOBBY_GAP);

            // Tower shaft above lobby (LOBBY_H to 350m) — narrow elevator shaft
            addTowerSection(TOWER_WIDTH, sec1H - LOBBY_H, LOBBY_H, towerMat);

            // Middle setback (350-460m) — narrower with shaft
            var sec2H = 110, sec2W = TOWER_WIDTH - 6;
            addTowerSection(sec2W, sec2H, sec1H, towerAccent);

            // Upper setback (460-520m) — narrower still with shaft
            var sec3H = 60, sec3W = TOWER_WIDTH - 14;
            addTowerSection(sec3W, sec3H, sec1H + sec2H, towerMat);

            // Crown (520-TOWER_HEIGHT) — glass crown wrapping the observation deck
            var crownH = TOWER_HEIGHT - (sec1H + sec2H + sec3H); // 520 to 550 = 30m
            var crownW = OBS.w + 4; // 26m — wide enough to frame the 22m observation deck
            var crownMat = new THREE.MeshPhysicalMaterial({ color: 0xaaccee, transparent: true, opacity: 0.5, roughness: 0.05, metalness: 0.3, transmission: 0.4 });
            addTowerSection(crownW, crownH, sec1H + sec2H + sec3H, crownMat);

            // Structural bands at observation deck floor and ceiling for visual integration
            var ringMat = new THREE.MeshStandardMaterial({ color: 0x445566, roughness: 0.15, metalness: 0.7 });
            var ringW = crownW + 1;
            var ringDepth = 1.5; // thickness of the band
            var ringLevels = [OBSERVATION_Y - 0.25, OBSERVATION_Y + OBS.h - 0.25];
            for (var ri = 0; ri < ringLevels.length; ri++) {
                var ry = ringLevels[ri];
                // 4 edge bars forming a frame (no center fill)
                var barF = new THREE.Mesh(new THREE.BoxGeometry(ringW, 0.5, ringDepth), ringMat);
                barF.position.set(0, ry, ringW / 2 - ringDepth / 2);
                cityGroup.add(barF);
                var barB = new THREE.Mesh(new THREE.BoxGeometry(ringW, 0.5, ringDepth), ringMat);
                barB.position.set(0, ry, -(ringW / 2 - ringDepth / 2));
                cityGroup.add(barB);
                var barL = new THREE.Mesh(new THREE.BoxGeometry(ringDepth, 0.5, ringW - ringDepth * 2), ringMat);
                barL.position.set(-(ringW / 2 - ringDepth / 2), ry, 0);
                cityGroup.add(barL);
                var barR = new THREE.Mesh(new THREE.BoxGeometry(ringDepth, 0.5, ringW - ringDepth * 2), ringMat);
                barR.position.set(ringW / 2 - ringDepth / 2, ry, 0);
                cityGroup.add(barR);
            }

            // Horizontal band details at setback transitions (with shaft gap)
            var bandMat = new THREE.MeshStandardMaterial({ color: 0x445566, roughness: 0.15, metalness: 0.7 });
            var bands = [
                { y: sec1H, w: TOWER_WIDTH + 2 },
                { y: sec1H + sec2H, w: sec2W + 2 },
                { y: sec1H + sec2H + sec3H, w: sec3W + 2 }
            ];
            for (var bi = 0; bi < bands.length; bi++) {
                var bw = bands[bi].w;
                var by = bands[bi].y;
                var halfB = bw / 2;
                var halfS2 = SHAFT / 2;
                var segDepth = halfB - halfS2;
                if (segDepth > 0) {
                    // Front/back segments
                    var bf = new THREE.Mesh(new THREE.BoxGeometry(bw, 2, segDepth), bandMat);
                    bf.position.set(0, by, halfS2 + segDepth / 2);
                    cityGroup.add(bf);
                    var bb = new THREE.Mesh(new THREE.BoxGeometry(bw, 2, segDepth), bandMat);
                    bb.position.set(0, by, -(halfS2 + segDepth / 2));
                    cityGroup.add(bb);
                    // Side segments
                    var sideLen = halfB - halfS2;
                    var bsl = new THREE.Mesh(new THREE.BoxGeometry(sideLen, 2, SHAFT), bandMat);
                    bsl.position.set(-(halfS2 + sideLen / 2), by, 0);
                    cityGroup.add(bsl);
                    var bsr = new THREE.Mesh(new THREE.BoxGeometry(sideLen, 2, SHAFT), bandMat);
                    bsr.position.set(halfS2 + sideLen / 2, by, 0);
                    cityGroup.add(bsr);
                }
            }

            // Window strips on all sections and all 4 faces
            var stripMat = new THREE.MeshPhysicalMaterial({ color: 0x88bbdd, transparent: true, opacity: 0.4, roughness: 0.05, metalness: 0.2 });
            var sections = [
                { h: sec1H, w: TOWER_WIDTH, yOff: 0 },
                { h: sec2H, w: sec2W, yOff: sec1H },
                { h: sec3H, w: sec3W, yOff: sec1H + sec2H }
            ];
            for (var si = 0; si < sections.length; si++) {
                var sec = sections[si];
                var numStrips = Math.floor(sec.w / 4);
                for (var side = 0; side < 4; side++) {
                    for (var s = 0; s < numStrips; s++) {
                        var stripGeo = new THREE.PlaneGeometry(1.5, sec.h - 6);
                        var strip = new THREE.Mesh(stripGeo, stripMat);
                        var sx = (s - (numStrips - 1) / 2) * 3.5;
                        var sy = sec.yOff + sec.h / 2;
                        switch (side) {
                            case 0: strip.position.set(sx, sy, sec.w / 2 + 0.05); break;
                            case 1: strip.position.set(sx, sy, -sec.w / 2 - 0.05); strip.rotation.y = Math.PI; break;
                            case 2: strip.position.set(sec.w / 2 + 0.05, sy, sx); strip.rotation.y = Math.PI / 2; break;
                            case 3: strip.position.set(-sec.w / 2 - 0.05, sy, sx); strip.rotation.y = -Math.PI / 2; break;
                        }
                        cityGroup.add(strip);
                    }
                }
            }

            // Spire (above crown)
            var spireBase = sec1H + sec2H + sec3H + crownH;
            var spire = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 1.5, 40, 8), MAT.metal);
            spire.position.set(0, spireBase + 20, 0);
            cityGroup.add(spire);

            // Antenna light
            var antLight = new THREE.Mesh(new THREE.SphereGeometry(0.6, 8, 8), new THREE.MeshBasicMaterial({ color: 0xff0000 }));
            antLight.position.set(0, spireBase + 40, 0);
            cityGroup.add(antLight);

            // Secondary blinking light mid-spire
            var midLight = new THREE.Mesh(new THREE.SphereGeometry(0.3, 6, 6), new THREE.MeshBasicMaterial({ color: 0xff4444 }));
            midLight.position.set(0, spireBase + 20, 0);
            cityGroup.add(midLight);
        }

        // ═══════════════════════════════════════════════════
        //  LOBBY (ground floor interior)
        // ═══════════════════════════════════════════════════
        function buildLobby() {
            var LW = 20, LD = 20, LH = 6; // lobby dimensions

            // Floor (raised above city ground to avoid z-fighting)
            var floor = new THREE.Mesh(new THREE.PlaneGeometry(LW, LD), MAT.marble);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = 0.1;
            lobbyGroup.add(floor);

            // Ceiling
            var ceiling = new THREE.Mesh(new THREE.PlaneGeometry(LW, LD), MAT.white);
            ceiling.rotation.x = Math.PI / 2;
            ceiling.position.y = LH;
            lobbyGroup.add(ceiling);

            // Walls (3 sides, front is open/glass)
            var wallMat = MAT.marble;
            // Back wall
            var backWall = new THREE.Mesh(new THREE.PlaneGeometry(LW, LH), wallMat);
            backWall.position.set(0, LH / 2, -LD / 2);
            lobbyGroup.add(backWall);
            // Side walls
            var leftWall = new THREE.Mesh(new THREE.PlaneGeometry(LD, LH), wallMat);
            leftWall.position.set(-LW / 2, LH / 2, 0);
            leftWall.rotation.y = Math.PI / 2;
            lobbyGroup.add(leftWall);
            var rightWall = new THREE.Mesh(new THREE.PlaneGeometry(LD, LH), wallMat);
            rightWall.position.set(LW / 2, LH / 2, 0);
            rightWall.rotation.y = -Math.PI / 2;
            lobbyGroup.add(rightWall);

            // Front wall (solid, behind player's starting position)
            var frontWall = new THREE.Mesh(new THREE.PlaneGeometry(LW, LH), wallMat);
            frontWall.position.set(0, LH / 2, LD / 2);
            frontWall.rotation.y = Math.PI;
            lobbyGroup.add(frontWall);

            // Elevator doors (on back wall)
            var doorMat = MAT.darkMetal;
            var doorL = new THREE.Mesh(new THREE.PlaneGeometry(1.2, 3), doorMat);
            doorL.position.set(-0.62, 1.5, -LD / 2 + 0.05);
            lobbyGroup.add(doorL);
            var doorR = new THREE.Mesh(new THREE.PlaneGeometry(1.2, 3), doorMat);
            doorR.position.set(0.62, 1.5, -LD / 2 + 0.05);
            lobbyGroup.add(doorR);

            // "Elevator" label
            var elevLabel = new THREE.Mesh(new THREE.PlaneGeometry(2.5, 0.4), new THREE.MeshBasicMaterial({ color: 0x333333 }));
            elevLabel.position.set(0, 3.3, -LD / 2 + 0.05);
            lobbyGroup.add(elevLabel);

            // Reception desk
            var deskGeo = new THREE.BoxGeometry(5, 1.1, 1.5);
            var desk = new THREE.Mesh(deskGeo, MAT.wood);
            desk.position.set(5, 0.55, 0);
            lobbyGroup.add(desk);

            // Potted plants
            for (var pp = -1; pp <= 1; pp += 2) {
                var pot = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.25, 0.5, 12), MAT.concrete);
                pot.position.set(pp * 3, 0.25, -LD / 2 + 2);
                lobbyGroup.add(pot);
                var plant = new THREE.Mesh(new THREE.SphereGeometry(0.5, 8, 8), new THREE.MeshStandardMaterial({ color: 0x2d6b2d }));
                plant.position.set(pp * 3, 0.8, -LD / 2 + 2);
                lobbyGroup.add(plant);
            }

            // Ceiling lights
            for (var lx = -6; lx <= 6; lx += 6) {
                var light = new THREE.Mesh(new THREE.BoxGeometry(2, 0.1, 2), new THREE.MeshBasicMaterial({ color: 0xffffee }));
                light.position.set(lx, LH - 0.05, 0);
                lobbyGroup.add(light);
                var pl = new THREE.PointLight(0xffffee, 0.5, 10);
                pl.position.set(lx, LH - 0.5, 0);
                lobbyGroup.add(pl);
            }
        }

        // ═══════════════════════════════════════════════════
        //  ELEVATOR (glass box that rises)
        // ═══════════════════════════════════════════════════
        var ELEV = { w: 3, d: 3, h: 3.2 };

        function buildElevator() {
            // Floor
            var eFloor = new THREE.Mesh(new THREE.PlaneGeometry(ELEV.w, ELEV.d), MAT.darkMetal);
            eFloor.rotation.x = -Math.PI / 2;
            eFloor.position.y = 0.01;
            elevatorGroup.add(eFloor);

            // Ceiling
            var eCeil = new THREE.Mesh(new THREE.PlaneGeometry(ELEV.w, ELEV.d), MAT.metal);
            eCeil.rotation.x = Math.PI / 2;
            eCeil.position.y = ELEV.h;
            elevatorGroup.add(eCeil);

            // Back wall (glass — view outward behind player)
            var backW = new THREE.Mesh(new THREE.PlaneGeometry(ELEV.w, ELEV.h), MAT.glass);
            backW.position.set(0, ELEV.h / 2, -ELEV.d / 2);
            elevatorGroup.add(backW);

            // Side glass walls
            var sideL = new THREE.Mesh(new THREE.PlaneGeometry(ELEV.d, ELEV.h), MAT.glass);
            sideL.position.set(-ELEV.w / 2, ELEV.h / 2, 0);
            sideL.rotation.y = Math.PI / 2;
            elevatorGroup.add(sideL);

            var sideR = new THREE.Mesh(new THREE.PlaneGeometry(ELEV.d, ELEV.h), MAT.glass);
            sideR.position.set(ELEV.w / 2, ELEV.h / 2, 0);
            sideR.rotation.y = -Math.PI / 2;
            elevatorGroup.add(sideR);

            // Front wall (door side — solid dark metal frame, no glass)
            var frontFrame = new THREE.Mesh(new THREE.PlaneGeometry(ELEV.w, ELEV.h), MAT.darkMetal);
            frontFrame.position.set(0, ELEV.h / 2, ELEV.d / 2);
            frontFrame.rotation.y = Math.PI;
            elevatorGroup.add(frontFrame);

            // ── Elevator doors (on front wall, split left/right) ──
            var doorW = ELEV.w / 2 - 0.05;
            var doorH = ELEV.h - 0.3;
            var doorMat = new THREE.MeshStandardMaterial({ color: 0x888899, roughness: 0.2, metalness: 0.9 });
            var doorL = new THREE.Mesh(new THREE.BoxGeometry(doorW, doorH, 0.04), doorMat);
            doorL.position.set(-doorW / 2 - 0.02, doorH / 2 + 0.1, ELEV.d / 2 - 0.03);
            elevatorGroup.add(doorL);
            var doorR = new THREE.Mesh(new THREE.BoxGeometry(doorW, doorH, 0.04), doorMat);
            doorR.position.set(doorW / 2 + 0.02, doorH / 2 + 0.1, ELEV.d / 2 - 0.03);
            elevatorGroup.add(doorR);

            // Door frame
            var frameMat = MAT.darkMetal;
            var frameTop = new THREE.Mesh(new THREE.BoxGeometry(ELEV.w + 0.1, 0.15, 0.08), frameMat);
            frameTop.position.set(0, ELEV.h - 0.1, ELEV.d / 2 - 0.02);
            elevatorGroup.add(frameTop);
            for (var fs = -1; fs <= 1; fs += 2) {
                var frameSide = new THREE.Mesh(new THREE.BoxGeometry(0.08, ELEV.h, 0.08), frameMat);
                frameSide.position.set(fs * (ELEV.w / 2 + 0.02), ELEV.h / 2, ELEV.d / 2 - 0.02);
                elevatorGroup.add(frameSide);
            }

            // ── Handrails (three sides: left, right, and back) ──
            // Side rails (along Z)
            for (var hs = -1; hs <= 1; hs += 2) {
                var sideRail = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.02, ELEV.d - 0.4, 8), MAT.railing);
                sideRail.rotation.x = Math.PI / 2;
                sideRail.position.set(hs * (ELEV.w / 2 - 0.1), 1.0, 0);
                elevatorGroup.add(sideRail);
                // Vertical supports for side rails
                for (var sv = -1; sv <= 1; sv += 2) {
                    var support = new THREE.Mesh(new THREE.CylinderGeometry(0.015, 0.015, 1.0, 6), MAT.railing);
                    support.position.set(hs * (ELEV.w / 2 - 0.1), 0.5, sv * (ELEV.d / 2 - 0.3));
                    elevatorGroup.add(support);
                }
            }
            // Back rail (along X)
            var backRail = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.02, ELEV.w - 0.4, 8), MAT.railing);
            backRail.rotation.z = Math.PI / 2;
            backRail.position.set(0, 1.0, -ELEV.d / 2 + 0.1);
            elevatorGroup.add(backRail);
            // Back rail vertical supports
            for (var bs = -1; bs <= 1; bs += 2) {
                var bSupport = new THREE.Mesh(new THREE.CylinderGeometry(0.015, 0.015, 1.0, 6), MAT.railing);
                bSupport.position.set(bs * (ELEV.w / 2 - 0.3), 0.5, -ELEV.d / 2 + 0.1);
                elevatorGroup.add(bSupport);
            }

            // ── Control panel (on right side wall, near door) ──
            var panel = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.6, 0.4), MAT.metal);
            panel.position.set(ELEV.w / 2 - 0.03, 1.3, ELEV.d / 2 - 0.4);
            elevatorGroup.add(panel);
            // Buttons on panel
            for (var btn = 0; btn < 4; btn++) {
                var button = new THREE.Mesh(new THREE.CircleGeometry(0.03, 8),
                    new THREE.MeshBasicMaterial({ color: btn === 3 ? 0xff4444 : 0xffffcc }));
                button.position.set(ELEV.w / 2 - 0.055, 1.1 + btn * 0.12, ELEV.d / 2 - 0.4);
                button.rotation.y = -Math.PI / 2;
                elevatorGroup.add(button);
            }

            // Ceiling light
            var eLight = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.05, 1.5), new THREE.MeshBasicMaterial({ color: 0xffffee }));
            eLight.position.set(0, ELEV.h - 0.05, 0);
            elevatorGroup.add(eLight);
            var ePL = new THREE.PointLight(0xffffee, 0.6, 5);
            ePL.position.set(0, ELEV.h - 0.3, 0);
            elevatorGroup.add(ePL);

            elevatorGroup.visible = false;
        }

        // ═══════════════════════════════════════════════════
        //  OBSERVATION DECK (top floor, inside the crown)
        // ═══════════════════════════════════════════════════
        function buildObservationDeck() {
            // Glass floor section positions
            var glassFloorSize = 5;
            var glassPositions = [
                { x: 0, z: OBS.d / 2 - glassFloorSize / 2 - 1 },   // front
                { x: 0, z: -OBS.d / 2 + glassFloorSize / 2 + 1 },  // back
                { x: OBS.w / 2 - glassFloorSize / 2 - 1, z: 0 },   // right
                { x: -OBS.w / 2 + glassFloorSize / 2 + 1, z: 0 }   // left
            ];

            // Solid floor with holes cut out for glass panels (Shape on XZ plane)
            var floorShape = new THREE.Shape();
            var hw = OBS.w / 2, hd = OBS.d / 2;
            floorShape.moveTo(-hw, -hd);
            floorShape.lineTo(hw, -hd);
            floorShape.lineTo(hw, hd);
            floorShape.lineTo(-hw, hd);
            floorShape.lineTo(-hw, -hd);
            // Cut rectangular holes for each glass section
            var gs = glassFloorSize / 2;
            for (var gi = 0; gi < glassPositions.length; gi++) {
                var gp = glassPositions[gi];
                var hole = new THREE.Path();
                hole.moveTo(gp.x - gs, gp.z - gs);
                hole.lineTo(gp.x + gs, gp.z - gs);
                hole.lineTo(gp.x + gs, gp.z + gs);
                hole.lineTo(gp.x - gs, gp.z + gs);
                hole.lineTo(gp.x - gs, gp.z - gs);
                floorShape.holes.push(hole);
            }
            var solidFloor = new THREE.Mesh(new THREE.ShapeGeometry(floorShape), MAT.carpet);
            solidFloor.rotation.x = -Math.PI / 2;
            solidFloor.position.y = OBSERVATION_Y + 0.01;
            observationGroup.add(solidFloor);

            // Glass floor panels (in the holes)
            for (var gi = 0; gi < glassPositions.length; gi++) {
                var gf = new THREE.Mesh(new THREE.PlaneGeometry(glassFloorSize, glassFloorSize), MAT.glassPanel);
                gf.rotation.x = -Math.PI / 2;
                gf.position.set(glassPositions[gi].x, OBSERVATION_Y + 0.02, glassPositions[gi].z);
                observationGroup.add(gf);
                // Faint edge outline
                var edge = new THREE.Mesh(new THREE.PlaneGeometry(glassFloorSize + 0.1, glassFloorSize + 0.1),
                    new THREE.MeshBasicMaterial({ color: 0x66aacc, transparent: true, opacity: 0.15 }));
                edge.rotation.x = -Math.PI / 2;
                edge.position.set(glassPositions[gi].x, OBSERVATION_Y + 0.015, glassPositions[gi].z);
                observationGroup.add(edge);
            }

            // Ceiling
            var ceil = new THREE.Mesh(new THREE.PlaneGeometry(OBS.w, OBS.d), MAT.white);
            ceil.rotation.x = Math.PI / 2;
            ceil.position.y = OBSERVATION_Y + OBS.h;
            observationGroup.add(ceil);

            // Glass walls (all 4 sides - floor to ceiling)
            var wallSpecs = [
                { pos: [0, OBSERVATION_Y + OBS.h / 2, OBS.d / 2], rot: [0, Math.PI, 0], size: [OBS.w, OBS.h] },
                { pos: [0, OBSERVATION_Y + OBS.h / 2, -OBS.d / 2], rot: [0, 0, 0], size: [OBS.w, OBS.h] },
                { pos: [OBS.w / 2, OBSERVATION_Y + OBS.h / 2, 0], rot: [0, -Math.PI / 2, 0], size: [OBS.d, OBS.h] },
                { pos: [-OBS.w / 2, OBSERVATION_Y + OBS.h / 2, 0], rot: [0, Math.PI / 2, 0], size: [OBS.d, OBS.h] }
            ];
            for (var wi = 0; wi < wallSpecs.length; wi++) {
                var ws = wallSpecs[wi];
                var wall = new THREE.Mesh(new THREE.PlaneGeometry(ws.size[0], ws.size[1]), MAT.glass);
                wall.position.set(ws.pos[0], ws.pos[1], ws.pos[2]);
                wall.rotation.set(ws.rot[0], ws.rot[1], ws.rot[2]);
                observationGroup.add(wall);
            }

            // Metal frame beams
            var beamMat = MAT.darkMetal;
            // Vertical corner beams
            var corners = [
                [-OBS.w / 2, OBS.d / 2], [OBS.w / 2, OBS.d / 2],
                [-OBS.w / 2, -OBS.d / 2], [OBS.w / 2, -OBS.d / 2]
            ];
            for (var ci = 0; ci < corners.length; ci++) {
                var beam = new THREE.Mesh(new THREE.BoxGeometry(0.3, OBS.h, 0.3), beamMat);
                beam.position.set(corners[ci][0], OBSERVATION_Y + OBS.h / 2, corners[ci][1]);
                observationGroup.add(beam);
            }

            // Ceiling lights
            for (var lx = -6; lx <= 6; lx += 6) {
                for (var lz = -6; lz <= 6; lz += 6) {
                    var lt = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.08, 1.5), new THREE.MeshBasicMaterial({ color: 0xffffee }));
                    lt.position.set(lx, OBSERVATION_Y + OBS.h - 0.04, lz);
                    observationGroup.add(lt);
                    var ptLight = new THREE.PointLight(0xffffee, 0.3, 12);
                    ptLight.position.set(lx, OBSERVATION_Y + OBS.h - 0.5, lz);
                    observationGroup.add(ptLight);
                }
            }

            // Info signs / displays along walls
            for (var si = -1; si <= 1; si += 2) {
                var sign = new THREE.Mesh(new THREE.PlaneGeometry(3, 1.5),
                    new THREE.MeshBasicMaterial({ color: 0x111122 }));
                sign.position.set(si * 8, OBSERVATION_Y + 2.5, -OBS.d / 2 + 0.05);
                observationGroup.add(sign);
            }

            observationGroup.visible = false;
        }

        // ═══════════════════════════════════════════════════
        //  GLASS SKYWALK (extends from observation deck)
        // ═══════════════════════════════════════════════════
        var SKYWALK = { length: 20, width: 3 };

        function buildSkywalk() {
            // Glass floor (the main terrifying element)
            var swFloor = new THREE.Mesh(
                new THREE.PlaneGeometry(SKYWALK.width, SKYWALK.length),
                MAT.glassPanel
            );
            swFloor.rotation.x = -Math.PI / 2;
            swFloor.position.set(0, OBSERVATION_Y + 0.02, OBS.d / 2 + SKYWALK.length / 2);
            skywalkGroup.add(swFloor);

            // Glass side barriers
            for (var side = -1; side <= 1; side += 2) {
                var barrier = new THREE.Mesh(
                    new THREE.PlaneGeometry(SKYWALK.length, 1.5),
                    MAT.glassFence
                );
                barrier.position.set(side * SKYWALK.width / 2, OBSERVATION_Y + 0.75, OBS.d / 2 + SKYWALK.length / 2);
                barrier.rotation.y = side * (-Math.PI / 2);
                skywalkGroup.add(barrier);

                // Metal railing on top of glass barrier
                var railGeo = new THREE.CylinderGeometry(0.025, 0.025, SKYWALK.length, 8);
                var rail = new THREE.Mesh(railGeo, MAT.railing);
                rail.rotation.x = Math.PI / 2;
                rail.position.set(side * SKYWALK.width / 2, OBSERVATION_Y + 1.5, OBS.d / 2 + SKYWALK.length / 2);
                skywalkGroup.add(rail);

                // Vertical supports for railing
                for (var vs = 0; vs < SKYWALK.length; vs += 2.5) {
                    var support = new THREE.Mesh(new THREE.CylinderGeometry(0.015, 0.015, 1.5, 6), MAT.railing);
                    support.position.set(side * SKYWALK.width / 2, OBSERVATION_Y + 0.75, OBS.d / 2 + 1 + vs);
                    skywalkGroup.add(support);
                }
            }

            // End platform (the furthest point - "the edge")
            var endPlatform = new THREE.Mesh(
                new THREE.CircleGeometry(2.5, 24),
                MAT.glassPanel
            );
            endPlatform.rotation.x = -Math.PI / 2;
            endPlatform.position.set(0, OBSERVATION_Y + 0.02, OBS.d / 2 + SKYWALK.length + 2.5);
            skywalkGroup.add(endPlatform);

            // End railing (semicircle)
            var endRailGeo = new THREE.TorusGeometry(2.5, 0.025, 8, 24, Math.PI);
            var endRail = new THREE.Mesh(endRailGeo, MAT.railing);
            endRail.position.set(0, OBSERVATION_Y + 1.5, OBS.d / 2 + SKYWALK.length + 2.5);
            endRail.rotation.x = -Math.PI / 2;
            endRail.rotation.z = -Math.PI / 2;
            skywalkGroup.add(endRail);

            // Semicircle glass barrier
            var endBarrier = new THREE.Mesh(
                new THREE.TorusGeometry(2.5, 0.75, 4, 24, Math.PI),
                MAT.glassFence
            );
            endBarrier.position.set(0, OBSERVATION_Y + 0.75, OBS.d / 2 + SKYWALK.length + 2.5);
            endBarrier.rotation.x = -Math.PI / 2;
            endBarrier.rotation.z = -Math.PI / 2;
            skywalkGroup.add(endBarrier);

            // Support beams underneath (structural steel)
            for (var bi = 0; bi < 4; bi++) {
                var supportBeam = new THREE.Mesh(
                    new THREE.BoxGeometry(0.15, 0.15, SKYWALK.length + 5),
                    MAT.darkMetal
                );
                var bx = (bi % 2 === 0 ? -1 : 1) * (SKYWALK.width / 2 - 0.2);
                var by = bi < 2 ? -0.5 : -1.5;
                supportBeam.position.set(bx, OBSERVATION_Y + by, OBS.d / 2 + SKYWALK.length / 2);
                skywalkGroup.add(supportBeam);
            }

            skywalkGroup.visible = false;
        }

        // ═══════════════════════════════════════════════════
        //  CLOUDS (at altitude)
        // ═══════════════════════════════════════════════════
        var cloudMeshes = [];
        function buildClouds() {
            var cloudMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.7 });
            for (var i = 0; i < 30; i++) {
                var cGroup = new THREE.Group();
                var numPuffs = 3 + Math.floor(Math.random() * 4);
                for (var p = 0; p < numPuffs; p++) {
                    var puffSize = 8 + Math.random() * 15;
                    var puff = new THREE.Mesh(new THREE.SphereGeometry(puffSize, 8, 6), cloudMat);
                    puff.position.set(
                        (Math.random() - 0.5) * puffSize * 2,
                        (Math.random() - 0.5) * puffSize * 0.5,
                        (Math.random() - 0.5) * puffSize * 2
                    );
                    puff.scale.y = 0.4;
                    cGroup.add(puff);
                }
                cGroup.position.set(
                    (Math.random() - 0.5) * 800,
                    180 + Math.random() * 120,
                    (Math.random() - 0.5) * 800
                );
                cGroup.userData = { speed: 0.5 + Math.random() * 1.0 };
                cloudsGroup.add(cGroup);
                cloudMeshes.push(cGroup);
            }
        }

        // ═══════════════════════════════════════════════════
        //  BUILD EVERYTHING
        // ═══════════════════════════════════════════════════
        buildCity();
        buildTower();
        buildLobby();
        buildElevator();
        buildObservationDeck();
        buildSkywalk();
        buildClouds();

        // ═══════════════════════════════════════════════════
        //  HELPERS
        // ═══════════════════════════════════════════════════
        function showPrompt(text, duration) {
            introText.textContent = text;
            introText.classList.add('visible');
            if (duration) {
                setTimeout(function() { introText.classList.remove('visible'); }, duration);
            }
        }

        function setPhaseLabel(text) {
            phaseLabel.textContent = text;
            phaseLabel.classList.add('visible');
        }

        function fadeIn(dur) {
            fadeOverlay.style.transition = 'opacity ' + dur + 's ease';
            fadeOverlay.classList.add('visible');
        }

        function fadeOut(dur) {
            fadeOverlay.style.transition = 'opacity ' + dur + 's ease';
            fadeOverlay.classList.remove('visible');
        }

        function pt(fn, delay) { setTimeout(fn, delay); }

        // ═══════════════════════════════════════════════════
        //  PHASE SYSTEM
        // ═══════════════════════════════════════════════════
        function goPhase(phase) {
            if (State.transitioning) return;
            State.transitioning = true;
            State.phase = phase;
            State.canClick = false;
            State.canMove = false;

            switch (phase) {

            // ─── LOBBY ───
            case 'lobby':
                setPhaseLabel('Lobby');
                lobbyGroup.visible = true;
                elevatorGroup.visible = false;
                observationGroup.visible = false;
                skywalkGroup.visible = false;
                cityGroup.visible = true;
                camera.position.set(0, 1.7, 5);
                euler.set(0, 0, 0); // face -Z toward the back wall (elevator)
                camera.quaternion.setFromEuler(euler);
                heightIndicator.textContent = 'Floor: Lobby';
                showPrompt('Welcome to Skyline Tower.', 3000);
                pt(function() {
                    showPrompt('Walk toward the elevator.', 3000);
                    State.canMove = true;
                    State.canClick = true;
                    State.transitioning = false;
                }, 3500);
                break;

            // ─── ELEVATOR RIDE ───
            case 'elevator_up':
                initAudio();
                setPhaseLabel('Elevator');
                fadeIn(1);
                pt(function() {
                    lobbyGroup.visible = false;
                    elevatorGroup.visible = true;
                    elevatorGroup.position.y = 0;
                    camera.position.set(0, 1.7, -0.5);
                    euler.set(0, Math.PI, 0); // facing +Z through glass front wall (outward view)
                    camera.quaternion.setFromEuler(euler);
                    State.canMove = false;
                    State.elevatorFloor = 0;
                    State.elevatorSpeed = 0;
                    fadeOut(1);
                    startElevatorHum();
                    startWindSound();
                    pt(function() {
                        showPrompt('Going up...', 2000);
                        playDing();
                        // Let the player look around
                        euler.set(-0.15, Math.PI, 0); // slightly looking down to see city falling away
                        camera.quaternion.setFromEuler(euler);
                        State.transitioning = false;
                    }, 1500);
                }, 1500);
                break;

            // ─── OBSERVATION DECK ───
            case 'observation':
                setPhaseLabel('Observation Deck');
                fadeIn(1.2);
                stopElevatorHum();
                playDing();
                pt(function() {
                    elevatorGroup.visible = false;
                    observationGroup.visible = true;
                    skywalkGroup.visible = true;
                    camera.position.set(0, OBSERVATION_Y + 1.7, -OBS.d / 2 + 2);
                    euler.set(0, 0, 0);
                    camera.quaternion.setFromEuler(euler);
                    State.playerHeight = OBSERVATION_Y;
                    heightIndicator.textContent = TOWER_HEIGHT + 'm — Floor ' + Math.floor(TOWER_HEIGHT / 3);
                    controlsHint.textContent = 'WASD to walk | Mouse to look around';
                    fadeOut(1.2);
                    showPrompt('Observation Deck — ' + TOWER_HEIGHT + ' meters above the city.', 4000);
                    pt(function() {
                        showPrompt('Explore the deck. Walk toward the glass floor sections.', 4000);
                        State.canMove = true;
                        State.transitioning = false;
                        updateWindVolume(0.15);
                    }, 4500);
                }, 1500);
                break;

            // ─── GLASS FLOOR (triggered by stepping on glass) ───
            case 'glass_floor':
                setPhaseLabel('Glass Floor');
                showPrompt('You\'re standing on glass... ' + TOWER_HEIGHT + ' meters above ground.', 4000);
                State.playerOnGlass = true;
                State.canMove = true;
                pt(function() {
                    showPrompt('Look down.', 3000);
                    State.transitioning = false;
                }, 4500);
                break;

            // ─── SKYWALK ───
            case 'skywalk':
                setPhaseLabel('Glass Skywalk');
                showPrompt('Step onto the Glass Skywalk...', 3000);
                updateWindVolume(0.3);
                windIndicator.textContent = 'Wind: 25 km/h';
                windIndicator.classList.add('visible');
                State.canMove = true;
                pt(function() {
                    showPrompt('Nothing between you and the city below but glass.', 4000);
                    State.transitioning = false;
                }, 3500);
                break;

            // ─── THE EDGE ───
            case 'edge':
                setPhaseLabel('The Edge');
                State.windStrength = 1.0;
                State.swayAmount = 0.003;
                updateWindVolume(0.5);
                windIndicator.textContent = 'Wind: 40 km/h';
                showPrompt('The edge. ' + TOWER_HEIGHT + ' meters of nothing beneath your feet.', 5000);
                State.canMove = true;
                pt(function() {
                    showPrompt('Look down... if you dare.', 4000);
                    pt(function() {
                        State.transitioning = false;
                    }, 4500);
                }, 5500);
                break;

            // ─── RETURN (walk back) ───
            case 'return':
                setPhaseLabel('Return');
                State.windStrength = 0.3;
                updateWindVolume(0.1);
                showPrompt('You faced the height. Walk back inside.', 4000);
                State.canMove = true;
                pt(function() {
                    State.transitioning = false;
                }, 2000);
                break;

            // ─── ENDED ───
            case 'ended':
                State.canMove = false;
                fadeIn(2);
                pt(function() {
                    showPrompt('You conquered the heights.', 0);
                    introText.style.zIndex = '101';
                    introText.classList.add('visible');
                    pt(function() {
                        try { window.parent.postMessage('simulation-complete', '*'); } catch (e) {}
                    }, 4000);
                }, 2500);
                break;
            }
        }

        // ═══════════════════════════════════════════════════
        //  PLAYER MOVEMENT
        // ═══════════════════════════════════════════════════
        function updatePlayer(delta) {
            if (!State.canMove) return;

            var speed = State.walkSpeed * delta;
            var direction = new THREE.Vector3();

            // Forward/back based on camera direction (only horizontal)
            var forward = new THREE.Vector3(0, 0, -1);
            forward.applyQuaternion(camera.quaternion);
            forward.y = 0;
            forward.normalize();

            var right = new THREE.Vector3(1, 0, 0);
            right.applyQuaternion(camera.quaternion);
            right.y = 0;
            right.normalize();

            if (keys['w'] || keys['arrowup']) direction.add(forward);
            if (keys['s'] || keys['arrowdown']) direction.sub(forward);
            if (keys['a'] || keys['arrowleft']) direction.sub(right);
            if (keys['d'] || keys['arrowright']) direction.add(right);

            if (direction.length() > 0) {
                direction.normalize().multiplyScalar(speed);
                camera.position.add(direction);
            }

            // Keep player at correct height
            if (State.phase === 'lobby') {
                camera.position.y = 1.7;
                // Boundary: lobby
                camera.position.x = Math.max(-9, Math.min(9, camera.position.x));
                camera.position.z = Math.max(-9, Math.min(9, camera.position.z));
            } else if (State.phase === 'observation' || State.phase === 'glass_floor') {
                camera.position.y = OBSERVATION_Y + 1.7;
                camera.position.x = Math.max(-OBS.w / 2 + 0.5, Math.min(OBS.w / 2 - 0.5, camera.position.x));
                camera.position.z = Math.max(-OBS.d / 2 + 0.5, Math.min(OBS.d / 2 - 0.5, camera.position.z));
            } else if (State.phase === 'skywalk' || State.phase === 'edge') {
                camera.position.y = OBSERVATION_Y + 1.7;
                // Allow walking the full observation deck + skywalk
                camera.position.x = Math.max(-OBS.w / 2 + 0.5, Math.min(OBS.w / 2 - 0.5, camera.position.x));
                // On the skywalk, constrain X to skywalk width
                if (camera.position.z > OBS.d / 2) {
                    camera.position.x = Math.max(-SKYWALK.width / 2 + 0.3, Math.min(SKYWALK.width / 2 - 0.3, camera.position.x));
                }
                camera.position.z = Math.max(-OBS.d / 2 + 0.5, Math.min(OBS.d / 2 + SKYWALK.length + 4.5, camera.position.z));
            } else if (State.phase === 'return') {
                camera.position.y = OBSERVATION_Y + 1.7;
                camera.position.x = Math.max(-OBS.w / 2 + 0.5, Math.min(OBS.w / 2 - 0.5, camera.position.x));
                if (camera.position.z > OBS.d / 2) {
                    camera.position.x = Math.max(-SKYWALK.width / 2 + 0.3, Math.min(SKYWALK.width / 2 - 0.3, camera.position.x));
                }
                camera.position.z = Math.max(-OBS.d / 2 + 0.5, Math.min(OBS.d / 2 + SKYWALK.length + 4.5, camera.position.z));
            }
        }

        // ═══════════════════════════════════════════════════
        //  ELEVATOR ANIMATION
        // ═══════════════════════════════════════════════════
        function updateElevator(delta) {
            if (State.phase !== 'elevator_up') return;

            // Accelerate then cruise then decelerate
            var currentY = elevatorGroup.position.y;
            var remaining = OBSERVATION_Y - currentY;

            if (remaining > 30) {
                State.elevatorSpeed = Math.min(State.elevatorSpeed + State.elevatorAccel * delta, State.elevatorMaxSpeed);
            } else if (remaining > 0) {
                State.elevatorSpeed = Math.max(0.3, State.elevatorSpeed * 0.99);
            }

            if (remaining > 0.5) {
                elevatorGroup.position.y += State.elevatorSpeed;
                camera.position.y = elevatorGroup.position.y + 1.7;
                State.elevatorFloor = Math.floor(elevatorGroup.position.y);

                // Update floor indicator
                var floor = Math.floor(elevatorGroup.position.y / 3);
                heightIndicator.textContent = Math.floor(elevatorGroup.position.y) + 'm — Floor ' + floor;

                // Update elevator hum pitch
                if (elevatorHum) {
                    elevatorHum.gain.gain.setTargetAtTime(0.08 + State.elevatorSpeed * 0.04, audioCtx.currentTime, 0.1);
                }

                // Wind gets louder as we rise
                var windVol = (elevatorGroup.position.y / OBSERVATION_Y) * 0.1;
                updateWindVolume(windVol);

                // Subtle camera shake at high speed
                if (State.elevatorSpeed > 1.5) {
                    camera.position.x = Math.sin(time * 15) * 0.003;
                    camera.position.z = 0.5 + Math.cos(time * 12) * 0.002;
                }
            } else {
                // Arrived
                elevatorGroup.position.y = OBSERVATION_Y;
                camera.position.y = OBSERVATION_Y + 1.7;
                State.elevatorSpeed = 0;
                heightIndicator.textContent = TOWER_HEIGHT + 'm — Floor ' + Math.floor(TOWER_HEIGHT / 3);
                showPrompt('Floor ' + Math.floor(TOWER_HEIGHT / 3) + ' — Observation Deck', 2500);
                playDing();
                pt(function() {
                    goPhase('observation');
                }, 3000);
            }
        }

        // ═══════════════════════════════════════════════════
        //  PHASE TRIGGERS (position-based)
        // ═══════════════════════════════════════════════════
        function checkPhaseTriggers() {
            var px = camera.position.x;
            var pz = camera.position.z;

            // Lobby → Elevator: walk to back wall (near elevator doors)
            if (State.phase === 'lobby' && pz < -7 && Math.abs(px) < 2) {
                if (State.canClick) goPhase('elevator_up');
            }

            // Observation → Glass floor: step onto a glass section
            if (State.phase === 'observation' && !State.transitioning) {
                var onGlass = false;
                // Check if near front glass section
                if (Math.abs(px) < 2.5 && pz > OBS.d / 2 - 4.5 && pz < OBS.d / 2 - 0.5) onGlass = true;
                if (onGlass && !State.playerOnGlass) {
                    goPhase('glass_floor');
                }
            }

            // Glass floor / Observation → Skywalk: walk onto the skywalk
            if ((State.phase === 'glass_floor' || State.phase === 'observation') && !State.transitioning) {
                if (pz > OBS.d / 2 + 1 && Math.abs(px) < SKYWALK.width / 2) {
                    goPhase('skywalk');
                }
            }

            // Skywalk → Edge: reach the end of the skywalk
            if (State.phase === 'skywalk' && !State.transitioning) {
                if (pz > OBS.d / 2 + SKYWALK.length - 1) {
                    goPhase('edge');
                }
            }

            // Edge → Return: stand at the edge for a while, then start return
            if (State.phase === 'edge' && !State.transitioning) {
                // If player walks back inside
                if (pz < OBS.d / 2 - 1) {
                    goPhase('return');
                }
            }

            // Return → Ended: walk back inside the observation deck center
            if (State.phase === 'return' && !State.transitioning) {
                if (pz < 0 && Math.abs(px) < 5) {
                    goPhase('ended');
                }
            }
        }

        // ═══════════════════════════════════════════════════
        //  EFFECTS
        // ═══════════════════════════════════════════════════
        function updateEffects(delta) {
            // Wind sway (on skywalk / edge)
            if (State.swayAmount > 0) {
                var sway = Math.sin(time * 1.5) * State.swayAmount;
                camera.position.x += sway;
                camera.rotation.z = sway * 0.5;
            }

            // Looking down detection (for glass floor / skywalk)
            if (State.phase === 'glass_floor' || State.phase === 'skywalk' || State.phase === 'edge') {
                var lookDir = new THREE.Vector3(0, 0, -1);
                lookDir.applyQuaternion(camera.quaternion);
                State.lookingDown = lookDir.y < -0.5;
            }

            // Clouds movement
            for (var ci = 0; ci < cloudMeshes.length; ci++) {
                var c = cloudMeshes[ci];
                c.position.x += c.userData.speed * delta;
                if (c.position.x > 500) c.position.x = -500;
            }

            // Wind indicator update
            if (State.phase === 'skywalk' || State.phase === 'edge') {
                var windKmh = 20 + Math.sin(time * 0.3) * 10 + State.windStrength * 15;
                windIndicator.textContent = 'Wind: ' + Math.floor(windKmh) + ' km/h';
            }
        }

        // ═══════════════════════════════════════════════════
        //  CONTROLS
        // ═══════════════════════════════════════════════════
        document.addEventListener('keydown', function(e) {
            keys[e.key.toLowerCase()] = true;
        });
        document.addEventListener('keyup', function(e) {
            keys[e.key.toLowerCase()] = false;
        });

        document.addEventListener('click', function() {
            initAudio();
            if (!isPointerLocked) {
                renderer.domElement.requestPointerLock();
            }
        });

        document.addEventListener('pointerlockchange', function() {
            isPointerLocked = document.pointerLockElement === renderer.domElement;
            if (isPointerLocked) {
                controlsHint.style.opacity = '0';
            }
        });

        document.addEventListener('mousemove', function(e) {
            if (!isPointerLocked) return;
            var movX = e.movementX || 0;
            var movY = e.movementY || 0;

            euler.setFromQuaternion(camera.quaternion);
            euler.y -= movX * State.mouseSensitivity;
            euler.x -= movY * State.mouseSensitivity;
            euler.x = Math.max(-Math.PI / 2 + 0.05, Math.min(Math.PI / 2 - 0.05, euler.x));
            camera.quaternion.setFromEuler(euler);
        });

        window.addEventListener('resize', function() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // ═══════════════════════════════════════════════════
        //  MAIN LOOP
        // ═══════════════════════════════════════════════════
        function animate() {
            requestAnimationFrame(animate);
            var delta = Math.min(clock.getDelta(), 0.1);
            time += delta;

            updatePlayer(delta);
            updateElevator(delta);
            checkPhaseTriggers();
            updateEffects(delta);

            renderer.render(scene, camera);
        }

        // ─── START ───
        goPhase('lobby');
        animate();

    })();
    </script>
</body>
</html>
