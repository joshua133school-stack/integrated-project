<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flight Experience - FAAH</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; background: #000; font-family: 'Georgia', serif; cursor: default; }
        canvas { display: block; }

        /* HUD */
        #hud {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 10;
        }
        #hud > * { pointer-events: auto; }

        #phase-label {
            position: fixed; top: 20px; left: 20px;
            color: #fff; font-size: 14px; z-index: 20;
            background: rgba(0,0,0,0.5); padding: 8px 16px; border-radius: 6px;
            text-transform: uppercase; letter-spacing: 2px;
            pointer-events: none;
        }
        #altitude-box {
            position: fixed; top: 20px; right: 20px;
            color: #fff; font-size: 13px; z-index: 20;
            background: rgba(0,0,0,0.5); padding: 8px 16px; border-radius: 6px;
            font-family: 'Courier New', monospace;
            opacity: 0; transition: opacity 0.8s;
            pointer-events: none;
        }
        #altitude-box.visible { opacity: 1; }

        #prompt {
            position: fixed; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: #fff; font-size: 1.6rem; text-align: center;
            pointer-events: none; z-index: 30;
            opacity: 0; transition: opacity 1s ease;
            text-shadow: 0 2px 20px rgba(0,0,0,0.8);
            max-width: 80%; line-height: 1.6;
        }
        #prompt.visible { opacity: 1; }

        #sub-prompt {
            position: fixed; bottom: 10%; left: 50%;
            transform: translateX(-50%);
            color: rgba(255,255,255,0.7); font-size: 0.95rem; text-align: center;
            pointer-events: none; z-index: 30;
            opacity: 0; transition: opacity 0.8s ease;
            text-shadow: 0 1px 10px rgba(0,0,0,0.8);
            background: rgba(0,0,0,0.35); padding: 10px 24px; border-radius: 8px;
        }
        #sub-prompt.visible { opacity: 1; }

        /* Seatbelt sign */
        #seatbelt-sign {
            position: fixed; top: 75px; left: 50%; transform: translateX(-50%);
            background: linear-gradient(145deg, #ff4444, #cc0000);
            color: #fff; padding: 10px 22px; border-radius: 6px;
            font-size: 0.95rem; z-index: 25;
            opacity: 0; transition: opacity 0.4s;
            box-shadow: 0 0 25px rgba(255,0,0,0.4);
            letter-spacing: 2px; text-transform: uppercase;
            pointer-events: none;
        }
        #seatbelt-sign.visible { opacity: 1; animation: pulse-sign 1.2s infinite; }
        @keyframes pulse-sign {
            0%,100% { box-shadow: 0 0 25px rgba(255,0,0,0.4); }
            50% { box-shadow: 0 0 45px rgba(255,0,0,0.8); }
        }

        /* Captain announcement */
        #captain-box {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%,-50%);
            background: rgba(0,0,0,0.85); color: #fff;
            padding: 30px 50px; border-radius: 12px;
            font-size: 1.1rem; z-index: 35;
            opacity: 0; transition: opacity 0.6s;
            max-width: 600px; text-align: center; line-height: 1.8;
            border: 1px solid rgba(255,255,255,0.1);
            pointer-events: none;
        }
        #captain-box.visible { opacity: 1; }
        #captain-box .captain-label {
            font-size: 0.75rem; letter-spacing: 3px; text-transform: uppercase;
            color: rgba(255,255,255,0.4); margin-bottom: 12px;
        }

        /* Fade overlay */
        #fade {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 50; opacity: 0;
            pointer-events: none; transition: opacity 1.5s ease;
        }
        #fade.visible { opacity: 1; pointer-events: all; }

        /* Flash (lightning) */
        #flash {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #fff; z-index: 40; opacity: 0;
            pointer-events: none;
        }

        /* Warning */
        #warning {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%,-50%);
            color: #ff4444; font-size: 2.2rem; z-index: 45;
            opacity: 0; transition: opacity 0.4s;
            text-shadow: 0 0 40px rgba(255,0,0,0.6);
            text-align: center; font-weight: bold;
            letter-spacing: 3px; pointer-events: none;
        }
        #warning.visible { opacity: 1; }

        /* Continue button */
        #continue-btn {
            position: fixed; bottom: 25%; left: 50%; transform: translateX(-50%);
            background: rgba(255,255,255,0.9); color: #222;
            border: none; padding: 14px 44px; font-size: 1.1rem;
            font-family: 'Georgia', serif; cursor: pointer;
            z-index: 55; border-radius: 8px;
            opacity: 0; transition: opacity 0.6s;
            pointer-events: none;
        }
        #continue-btn.visible { opacity: 1; pointer-events: auto; }
        #continue-btn:hover { background: #fff; transform: translateX(-50%) scale(1.05); }

        /* Oxygen masks */
        .oxygen-mask {
            position: fixed; z-index: 32; pointer-events: none;
            width: 40px; opacity: 0;
            transition: transform 1.2s cubic-bezier(0.2,0.8,0.3,1), opacity 0.3s;
        }
        .oxygen-mask .mask-tube {
            width: 3px; height: 60px; background: #888; margin: 0 auto;
        }
        .oxygen-mask .mask-cup {
            width: 36px; height: 28px; background: linear-gradient(145deg, #ffcc00, #e6a800);
            border-radius: 0 0 18px 18px; margin: 0 auto;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        /* Emergency lights */
        .emergency-strip {
            position: fixed; bottom: 0; left: 0; width: 100%; height: 4px;
            z-index: 31; opacity: 0; transition: opacity 0.5s;
            pointer-events: none;
        }
        .emergency-strip.visible {
            opacity: 1;
            background: repeating-linear-gradient(90deg, #00ff00 0px, #00ff00 30px, transparent 30px, transparent 60px);
            animation: floor-lights 1s linear infinite;
        }
        @keyframes floor-lights {
            0% { background-position: 0 0; }
            100% { background-position: 60px 0; }
        }

        /* Rain overlay on window */
        #rain-canvas {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 5; pointer-events: none; opacity: 0;
            transition: opacity 1s;
        }
        #rain-canvas.visible { opacity: 1; }

        /* Survival scene text */
        #survival-text {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%,-50%);
            color: #fff; font-size: 1.4rem; text-align: center;
            z-index: 55; opacity: 0; transition: opacity 1s;
            max-width: 80%; line-height: 2;
            pointer-events: none;
        }
        #survival-text.visible { opacity: 1; }
    </style>
</head>
<body>
    <div id="hud">
        <div id="phase-label">Airport Terminal</div>
        <div id="altitude-box">
            ALT <span id="alt-val">0</span> ft<br>
            SPD <span id="spd-val">0</span> kts<br>
            HDG <span id="hdg-val">270</span>°
        </div>
        <div id="seatbelt-sign">⚠ Fasten Seatbelt</div>
    </div>

    <div id="prompt"></div>
    <div id="sub-prompt"></div>
    <div id="captain-box"><div class="captain-label"></div><div id="captain-text"></div></div>
    <div id="warning"></div>
    <div id="fade"></div>
    <div id="flash"></div>
    <div class="emergency-strip" id="emergency-strip"></div>
    <canvas id="rain-canvas"></canvas>
    <div id="survival-text"></div>
    <button id="continue-btn">Continue</button>

    <script src="https://cdn.jsdelivr.net/npm/three@0.152.0/build/three.min.js"></script>
    <script>
    (function() {
    'use strict';

    // ═══════════════════════════════════════════════════
    //  RENDERER & SCENE
    // ═══════════════════════════════════════════════════
    var renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.0;
    document.body.appendChild(renderer.domElement);

    var scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x87CEEB, 0.0008);

    var camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 5000);

    // ═══════════════════════════════════════════════════
    //  GAME STATE
    // ═══════════════════════════════════════════════════
    var G = {
        phase: 'airport',
        time: 0,
        delta: 0,
        altitude: 0,
        speed: 0,
        heading: 270,
        pitch: 0,
        roll: 0,
        shakeAmount: 0,
        shakeDecay: 0.95,
        cameraBasePos: new THREE.Vector3(),
        cameraBaseRot: new THREE.Euler(),
        lookX: 0, lookY: 0,
        targetLookX: 0, targetLookY: 0,
        mouseX: 0, mouseY: 0,
        canClick: true,
        transitioning: false,
        lightningTimer: 0,
        rainIntensity: 0,
        emergencyLights: false,
        cabinLightsOn: true,
        cabinLightsDim: false
    };

    // ═══════════════════════════════════════════════════
    //  WEB AUDIO - PROCEDURAL SOUND ENGINE
    // ═══════════════════════════════════════════════════
    var audioCtx = null;
    var masterGain = null;
    var engineNode = null, engineGain = null;
    var windNode = null, windGain = null;
    var cabinNode = null, cabinGain = null;

    function initAudio() {
        try {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            masterGain = audioCtx.createGain();
            masterGain.gain.value = 0.3;
            masterGain.connect(audioCtx.destination);

            // Engine rumble (low-frequency noise)
            var bufferSize = 2 * audioCtx.sampleRate;
            engineNode = audioCtx.createBufferSource();
            var engineBuffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            var engineData = engineBuffer.getChannelData(0);
            for (var i = 0; i < bufferSize; i++) {
                engineData[i] = (Math.random() * 2 - 1) * 0.3;
            }
            engineNode.buffer = engineBuffer;
            engineNode.loop = true;

            var engineFilter = audioCtx.createBiquadFilter();
            engineFilter.type = 'lowpass';
            engineFilter.frequency.value = 120;
            engineFilter.Q.value = 1;

            engineGain = audioCtx.createGain();
            engineGain.gain.value = 0;
            engineNode.connect(engineFilter);
            engineFilter.connect(engineGain);
            engineGain.connect(masterGain);
            engineNode.start();

            // Wind noise (high-frequency shaped noise)
            windNode = audioCtx.createBufferSource();
            var windBuffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            var windData = windBuffer.getChannelData(0);
            for (var j = 0; j < bufferSize; j++) {
                windData[j] = (Math.random() * 2 - 1);
            }
            windNode.buffer = windBuffer;
            windNode.loop = true;

            var windFilter = audioCtx.createBiquadFilter();
            windFilter.type = 'bandpass';
            windFilter.frequency.value = 800;
            windFilter.Q.value = 0.5;

            windGain = audioCtx.createGain();
            windGain.gain.value = 0;
            windNode.connect(windFilter);
            windFilter.connect(windGain);
            windGain.connect(masterGain);
            windNode.start();

            // Cabin ambience (very low noise)
            cabinNode = audioCtx.createBufferSource();
            var cabinBuffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            var cabinData = cabinBuffer.getChannelData(0);
            var prev = 0;
            for (var k = 0; k < bufferSize; k++) {
                prev = prev * 0.99 + (Math.random() * 2 - 1) * 0.01;
                cabinData[k] = prev * 3;
            }
            cabinNode.buffer = cabinBuffer;
            cabinNode.loop = true;

            cabinGain = audioCtx.createGain();
            cabinGain.gain.value = 0;
            cabinNode.connect(cabinGain);
            cabinGain.connect(masterGain);
            cabinNode.start();

        } catch(e) { /* Audio not available */ }
    }

    function setEngineVolume(v) {
        if (engineGain) engineGain.gain.linearRampToValueAtTime(v, audioCtx.currentTime + 0.5);
    }
    function setWindVolume(v) {
        if (windGain) windGain.gain.linearRampToValueAtTime(v, audioCtx.currentTime + 0.5);
    }
    function setCabinVolume(v) {
        if (cabinGain) cabinGain.gain.linearRampToValueAtTime(v, audioCtx.currentTime + 0.3);
    }

    function playThunder() {
        if (!audioCtx) return;
        var osc = audioCtx.createOscillator();
        var g = audioCtx.createGain();
        var filter = audioCtx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 200;

        var buf = audioCtx.createBuffer(1, audioCtx.sampleRate * 2, audioCtx.sampleRate);
        var d = buf.getChannelData(0);
        for (var i = 0; i < d.length; i++) d[i] = (Math.random() * 2 - 1);
        var noise = audioCtx.createBufferSource();
        noise.buffer = buf;

        g.gain.setValueAtTime(0.8, audioCtx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 2.5);

        noise.connect(filter);
        filter.connect(g);
        g.connect(masterGain);
        noise.start();
        noise.stop(audioCtx.currentTime + 2.5);
    }

    function playDing() {
        if (!audioCtx) return;
        var osc = audioCtx.createOscillator();
        var g = audioCtx.createGain();
        osc.type = 'sine';
        osc.frequency.value = 1200;
        g.gain.setValueAtTime(0.15, audioCtx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.8);
        osc.connect(g);
        g.connect(masterGain);
        osc.start();
        osc.stop(audioCtx.currentTime + 0.8);
        // Second tone
        setTimeout(function() {
            if (!audioCtx) return;
            var o2 = audioCtx.createOscillator();
            var g2 = audioCtx.createGain();
            o2.type = 'sine'; o2.frequency.value = 900;
            g2.gain.setValueAtTime(0.12, audioCtx.currentTime);
            g2.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.6);
            o2.connect(g2); g2.connect(masterGain);
            o2.start(); o2.stop(audioCtx.currentTime + 0.6);
        }, 300);
    }

    function playAlarm() {
        if (!audioCtx) return;
        var osc = audioCtx.createOscillator();
        var g = audioCtx.createGain();
        osc.type = 'square';
        osc.frequency.setValueAtTime(600, audioCtx.currentTime);
        g.gain.setValueAtTime(0.2, audioCtx.currentTime);
        for (var i = 0; i < 10; i++) {
            osc.frequency.setValueAtTime(600, audioCtx.currentTime + i * 0.4);
            osc.frequency.setValueAtTime(400, audioCtx.currentTime + i * 0.4 + 0.2);
        }
        g.gain.setValueAtTime(0.2, audioCtx.currentTime + 3.8);
        g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 4);
        osc.connect(g); g.connect(masterGain);
        osc.start(); osc.stop(audioCtx.currentTime + 4);
    }

    function playImpact() {
        if (!audioCtx) return;
        var buf = audioCtx.createBuffer(1, audioCtx.sampleRate, audioCtx.sampleRate);
        var d = buf.getChannelData(0);
        for (var i = 0; i < d.length; i++) d[i] = (Math.random() * 2 - 1) * Math.exp(-i / (audioCtx.sampleRate * 0.15));
        var src = audioCtx.createBufferSource();
        src.buffer = buf;
        var filter = audioCtx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 300;
        var g = audioCtx.createGain();
        g.gain.value = 1.0;
        src.connect(filter); filter.connect(g); g.connect(masterGain);
        src.start();
    }

    // ═══════════════════════════════════════════════════
    //  MATERIALS
    // ═══════════════════════════════════════════════════
    var MAT = {
        concrete: new THREE.MeshStandardMaterial({ color: 0x999999, roughness: 0.9 }),
        asphalt: new THREE.MeshStandardMaterial({ color: 0x2a2a2a, roughness: 0.95 }),
        grass: new THREE.MeshStandardMaterial({ color: 0x3d7a1a, roughness: 0.95 }),
        glass: new THREE.MeshPhysicalMaterial({ color: 0x88ccff, transparent: true, opacity: 0.3, roughness: 0.05, metalness: 0.1, transmission: 0.6 }),
        metal: new THREE.MeshStandardMaterial({ color: 0xcccccc, roughness: 0.25, metalness: 0.85 }),
        white: new THREE.MeshStandardMaterial({ color: 0xf0f0f0, roughness: 0.6 }),
        blue: new THREE.MeshStandardMaterial({ color: 0x1a4b8c, roughness: 0.5 }),
        red: new THREE.MeshStandardMaterial({ color: 0xcc2222, roughness: 0.5 }),
        darkRed: new THREE.MeshStandardMaterial({ color: 0x661111, roughness: 0.5 }),
        seat: new THREE.MeshStandardMaterial({ color: 0x1e3a6e, roughness: 0.75 }),
        seatBack: new THREE.MeshStandardMaterial({ color: 0x152a52, roughness: 0.8 }),
        carpet: new THREE.MeshStandardMaterial({ color: 0x2a3040, roughness: 0.95 }),
        plastic: new THREE.MeshStandardMaterial({ color: 0xe0d8cc, roughness: 0.7 }),
        darkPlastic: new THREE.MeshStandardMaterial({ color: 0x3a3a3a, roughness: 0.8 }),
        windowInner: new THREE.MeshPhysicalMaterial({ color: 0xaaddff, transparent: true, opacity: 0.15, roughness: 0.02 }),
        terminalFloor: new THREE.MeshStandardMaterial({ color: 0xccbbaa, roughness: 0.5 }),
        sky: new THREE.MeshBasicMaterial({ color: 0x87CEEB }),
        emergencyGreen: new THREE.MeshBasicMaterial({ color: 0x00ff44 }),
        lightEmit: new THREE.MeshBasicMaterial({ color: 0xffffee }),
        lightEmitWarm: new THREE.MeshBasicMaterial({ color: 0xffeecc }),
        lightEmitDim: new THREE.MeshBasicMaterial({ color: 0x443322 }),
        stormCloud: new THREE.MeshLambertMaterial({ color: 0x333344, transparent: true, opacity: 0.85 }),
        darkCloud: new THREE.MeshLambertMaterial({ color: 0x1a1a22, transparent: true, opacity: 0.9 })
    };

    // ═══════════════════════════════════════════════════
    //  SCENE GROUPS
    // ═══════════════════════════════════════════════════
    var airportGroup = new THREE.Group();
    var planeExtGroup = new THREE.Group();
    var cabinGroup = new THREE.Group();
    var cloudGroup = new THREE.Group();
    var stormCloudGroup = new THREE.Group();
    var lightningGroup = new THREE.Group();
    var debrisGroup = new THREE.Group();
    var survivalGroup = new THREE.Group();
    scene.add(airportGroup, planeExtGroup, cabinGroup, cloudGroup, stormCloudGroup, lightningGroup, debrisGroup, survivalGroup);

    // Cabin light refs
    var cabinLights = [];
    var cabinLightMeshes = [];
    var emergencyLightMeshes = [];

    // ═══════════════════════════════════════════════════
    //  LIGHTING
    // ═══════════════════════════════════════════════════
    var ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
    scene.add(ambientLight);

    var sunLight = new THREE.DirectionalLight(0xfffff0, 1.2);
    sunLight.position.set(80, 120, 60);
    sunLight.castShadow = true;
    sunLight.shadow.mapSize.width = 2048;
    sunLight.shadow.mapSize.height = 2048;
    sunLight.shadow.camera.near = 0.5;
    sunLight.shadow.camera.far = 500;
    sunLight.shadow.camera.left = -100;
    sunLight.shadow.camera.right = 100;
    sunLight.shadow.camera.top = 100;
    sunLight.shadow.camera.bottom = -100;
    scene.add(sunLight);

    var hemiLight = new THREE.HemisphereLight(0x87ceeb, 0x3d5c2d, 0.4);
    scene.add(hemiLight);

    // ═══════════════════════════════════════════════════
    //  AIRPORT CONSTRUCTION
    // ═══════════════════════════════════════════════════
    function buildAirport() {
        // Ground plane
        var groundGeo = new THREE.PlaneGeometry(1000, 1000);
        var ground = new THREE.Mesh(groundGeo, MAT.grass);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        airportGroup.add(ground);

        // Runway
        var rwGeo = new THREE.PlaneGeometry(24, 400);
        var runway = new THREE.Mesh(rwGeo, MAT.asphalt);
        runway.rotation.x = -Math.PI / 2;
        runway.position.set(40, 0.02, 0);
        runway.receiveShadow = true;
        airportGroup.add(runway);

        // Runway center line
        var lineM = new THREE.MeshBasicMaterial({ color: 0xffffff });
        for (var i = -180; i < 180; i += 12) {
            var mark = new THREE.Mesh(new THREE.PlaneGeometry(0.6, 5), lineM);
            mark.rotation.x = -Math.PI / 2;
            mark.position.set(40, 0.03, i);
            airportGroup.add(mark);
        }

        // Runway edge lines
        for (var side = -1; side <= 1; side += 2) {
            var edgeLine = new THREE.Mesh(new THREE.PlaneGeometry(0.4, 380), lineM);
            edgeLine.rotation.x = -Math.PI / 2;
            edgeLine.position.set(40 + side * 11.5, 0.03, 0);
            airportGroup.add(edgeLine);
        }

        // Taxiway
        var twGeo = new THREE.PlaneGeometry(12, 80);
        var taxiway = new THREE.Mesh(twGeo, MAT.asphalt);
        taxiway.rotation.x = -Math.PI / 2;
        taxiway.position.set(15, 0.02, 0);
        airportGroup.add(taxiway);

        // Terminal building (large)
        var termGeo = new THREE.BoxGeometry(80, 18, 40);
        var terminal = new THREE.Mesh(termGeo, MAT.concrete);
        terminal.position.set(-25, 9, 0);
        terminal.castShadow = true;
        terminal.receiveShadow = true;
        airportGroup.add(terminal);

        // Terminal windows - large glass facade
        var facadeGeo = new THREE.PlaneGeometry(78, 12);
        var facade = new THREE.Mesh(facadeGeo, MAT.glass);
        facade.position.set(-25, 10, 20.01);
        airportGroup.add(facade);

        // Terminal entrance canopy
        var canopyGeo = new THREE.BoxGeometry(30, 0.5, 8);
        var canopy = new THREE.Mesh(canopyGeo, MAT.metal);
        canopy.position.set(-25, 5, 24);
        airportGroup.add(canopy);

        // Control tower
        var towerBase = new THREE.Mesh(new THREE.CylinderGeometry(4, 5, 30, 12), MAT.concrete);
        towerBase.position.set(-60, 15, -40);
        towerBase.castShadow = true;
        airportGroup.add(towerBase);

        var towerCab = new THREE.Mesh(new THREE.CylinderGeometry(8, 5, 7, 12), MAT.glass);
        towerCab.position.set(-60, 33, -40);
        airportGroup.add(towerCab);

        var towerRoof = new THREE.Mesh(new THREE.ConeGeometry(9, 3, 12), MAT.metal);
        towerRoof.position.set(-60, 38, -40);
        airportGroup.add(towerRoof);

        // Jet bridge (extends from terminal toward plane door, along X)
        var bridgeGeo = new THREE.BoxGeometry(16, 3.0, 4.0);
        var bridge = new THREE.Mesh(bridgeGeo, MAT.metal);
        bridge.position.set(3, 4.2, 0);
        airportGroup.add(bridge);

        // Plane at gate (exterior)
        buildPlaneExterior();

        // Other parked planes (along runway, distant)
        for (var p = 0; p < 3; p++) {
            var miniPlane = buildMiniPlane();
            miniPlane.position.set(40, 2, -60 - p * 50);
            miniPlane.rotation.y = Math.PI / 2; // facing down runway
            miniPlane.scale.set(0.7, 0.7, 0.7);
            airportGroup.add(miniPlane);
        }

        // Runway lights
        for (var rl = -190; rl < 190; rl += 15) {
            for (var rs = -1; rs <= 1; rs += 2) {
                var rlMesh = new THREE.Mesh(
                    new THREE.SphereGeometry(0.15, 6, 6),
                    new THREE.MeshBasicMaterial({ color: rl < -150 ? 0x00ff00 : (rl > 150 ? 0xff0000 : 0xffffff) })
                );
                rlMesh.position.set(40 + rs * 12.5, 0.15, rl);
                airportGroup.add(rlMesh);
            }
        }
    }

    // Plane is built along Z-axis: nose = +Z, tail = -Z, wings along X, up = Y
    // All coordinates: (x=left/right, y=up/down, z=fore/aft)
    var PLANE = { len: 38, radius: 2.0, wingSpan: 34, wingChord: 5 };

    function buildMiniPlane() {
        var g = new THREE.Group();
        // Fuselage along Z
        var body = new THREE.Mesh(new THREE.CylinderGeometry(1.2, 1.2, 16, 10), MAT.white);
        body.rotation.x = Math.PI / 2;
        g.add(body);
        // Nose
        var nose = new THREE.Mesh(new THREE.ConeGeometry(1.2, 3, 10), MAT.white);
        nose.rotation.x = -Math.PI / 2;
        nose.position.z = 9.5;
        g.add(nose);
        // Wings
        var wing = new THREE.Mesh(new THREE.BoxGeometry(14, 0.15, 3), MAT.metal);
        wing.position.set(0, -0.3, -1);
        g.add(wing);
        // Tail fin
        var tailFin = new THREE.Mesh(new THREE.BoxGeometry(0.2, 3, 2), MAT.blue);
        tailFin.position.set(0, 2, -8);
        g.add(tailFin);
        return g;
    }

    // ═══════════════════════════════════════════════════
    //  PLANE EXTERIOR (Z-forward convention)
    // ═══════════════════════════════════════════════════
    function buildPlaneExterior() {
        var R = PLANE.radius;
        var halfLen = PLANE.len / 2;

        // ── Fuselage (cylinder along Z) ──
        var fusGeo = new THREE.CylinderGeometry(R, R, PLANE.len, 32);
        var fuselage = new THREE.Mesh(fusGeo, MAT.white);
        fuselage.rotation.x = Math.PI / 2; // align along Z
        fuselage.castShadow = true;
        planeExtGroup.add(fuselage);

        // ── Blue cheatline stripe ──
        var stripeGeo = new THREE.CylinderGeometry(R + 0.015, R + 0.015, PLANE.len, 32, 1, false, Math.PI * 0.47, Math.PI * 0.06);
        var stripe = new THREE.Mesh(stripeGeo, MAT.blue);
        stripe.rotation.x = Math.PI / 2;
        planeExtGroup.add(stripe);

        // ── Nose cone ──
        var noseGeo = new THREE.SphereGeometry(R, 32, 16, 0, Math.PI * 2, 0, Math.PI / 2);
        var nose = new THREE.Mesh(noseGeo, MAT.white);
        nose.rotation.x = -Math.PI / 2; // hemisphere pointing +Z
        nose.position.z = halfLen;
        planeExtGroup.add(nose);

        // ── Cockpit windows (on nose, angled) ──
        var cwGeo = new THREE.PlaneGeometry(0.9, 0.5);
        for (var cw = -1; cw <= 1; cw += 2) {
            var cWin = new THREE.Mesh(cwGeo, MAT.glass);
            cWin.position.set(cw * 0.55, R * 0.55, halfLen + 0.3);
            cWin.rotation.x = -0.25;
            cWin.rotation.y = cw * 0.2;
            planeExtGroup.add(cWin);
        }

        // ── Tail cone ──
        var tailConeGeo = new THREE.ConeGeometry(R, 7, 32);
        var tailCone = new THREE.Mesh(tailConeGeo, MAT.white);
        tailCone.rotation.x = Math.PI / 2; // point toward -Z
        tailCone.position.z = -halfLen - 3.5;
        planeExtGroup.add(tailCone);

        // ── Passenger windows (both sides) ──
        var wGeo = new THREE.CircleGeometry(0.15, 10);
        for (var wz = -halfLen + 4; wz <= halfLen - 3; wz += 1.2) {
            // Left side (+X)
            var wL = new THREE.Mesh(wGeo, MAT.glass);
            wL.position.set(R + 0.02, R * 0.35, wz);
            wL.rotation.y = Math.PI / 2;
            planeExtGroup.add(wL);
            // Right side (-X)
            var wR = new THREE.Mesh(wGeo, MAT.glass);
            wR.position.set(-R - 0.02, R * 0.35, wz);
            wR.rotation.y = -Math.PI / 2;
            planeExtGroup.add(wR);
        }

        // ── Wings (flat boxes, swept back slightly) ──
        // Wing shape: root at fuselage, extends outward on X, swept back on Z
        function makeWing(side) {
            // side: 1 = left(+X), -1 = right(-X)
            var wGroup = new THREE.Group();
            var span = PLANE.wingSpan / 2 - R;
            // Main wing spar
            var wingGeo = new THREE.BoxGeometry(span, 0.25, PLANE.wingChord);
            var wingMesh = new THREE.Mesh(wingGeo, MAT.metal);
            wingMesh.position.set(side * (R + span / 2), 0, 0);
            wingMesh.castShadow = true;
            wGroup.add(wingMesh);

            // Wing tip (tapered)
            var tipGeo = new THREE.BoxGeometry(1.5, 0.2, PLANE.wingChord * 0.5);
            var tip = new THREE.Mesh(tipGeo, MAT.metal);
            tip.position.set(side * (R + span + 0.75), 0, -0.5);
            wGroup.add(tip);

            // Winglet (small vertical fin at tip)
            var wingletGeo = new THREE.BoxGeometry(0.08, 1.0, 0.8);
            var winglet = new THREE.Mesh(wingletGeo, MAT.white);
            winglet.position.set(side * (R + span + 1.4), 0.5, -0.3);
            wGroup.add(winglet);

            wGroup.position.set(0, -R * 0.4, -2); // wings slightly behind center, below center
            wGroup.rotation.y = side * 0.04; // slight sweep
            return wGroup;
        }
        planeExtGroup.add(makeWing(1));
        planeExtGroup.add(makeWing(-1));

        // ── Engines (under wings) ──
        function makeEngine(xPos) {
            var eGroup = new THREE.Group();
            // Nacelle (cylinder along Z)
            var nacGeo = new THREE.CylinderGeometry(0.65, 0.75, 3.5, 18);
            var nacelle = new THREE.Mesh(nacGeo, MAT.metal);
            nacelle.rotation.x = Math.PI / 2;
            eGroup.add(nacelle);
            // Intake ring
            var intakeGeo = new THREE.RingGeometry(0.25, 0.65, 18);
            var intake = new THREE.Mesh(intakeGeo, new THREE.MeshBasicMaterial({ color: 0x111111 }));
            intake.position.z = 1.75;
            eGroup.add(intake);
            // Fan blades
            var fanGeo = new THREE.CircleGeometry(0.55, 5);
            var fan = new THREE.Mesh(fanGeo, MAT.darkPlastic);
            fan.position.z = 1.7;
            eGroup.add(fan);
            // Pylon (connects engine to wing)
            var pylonGeo = new THREE.BoxGeometry(0.15, 0.7, 2.0);
            var pylon = new THREE.Mesh(pylonGeo, MAT.metal);
            pylon.position.y = 0.7;
            eGroup.add(pylon);

            eGroup.position.set(xPos, -R - 0.8, -1);
            return eGroup;
        }
        planeExtGroup.add(makeEngine(5.5));
        planeExtGroup.add(makeEngine(-5.5));

        // ── Vertical Stabilizer (tail fin) ──
        var vfinShape = new THREE.Shape();
        vfinShape.moveTo(0, 0);
        vfinShape.lineTo(1.5, 5.5);
        vfinShape.lineTo(-2, 5.5);
        vfinShape.lineTo(-4, 0);
        var vfinGeo = new THREE.ExtrudeGeometry(vfinShape, { depth: 0.2, bevelEnabled: false });
        var vfin = new THREE.Mesh(vfinGeo, MAT.blue);
        vfin.position.set(-0.1, R, -halfLen + 2);
        planeExtGroup.add(vfin);

        // ── Horizontal Stabilizers ──
        for (var hs = -1; hs <= 1; hs += 2) {
            var hsGeo = new THREE.BoxGeometry(6, 0.15, 3);
            var hStab = new THREE.Mesh(hsGeo, MAT.metal);
            hStab.position.set(hs * 3.5, R + 0.2, -halfLen - 1);
            planeExtGroup.add(hStab);
        }

        // ── Landing Gear ──
        function makeGear(x, z, numWheels) {
            var gGroup = new THREE.Group();
            // Strut
            var strut = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.06, 1.5, 8), MAT.darkPlastic);
            gGroup.add(strut);
            // Wheels
            for (var w = 0; w < numWheels; w++) {
                var wheel = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.3, 0.3, 0.18, 16),
                    MAT.darkPlastic
                );
                wheel.rotation.z = Math.PI / 2; // axle along X
                wheel.position.set((w - (numWheels - 1) / 2) * 0.5, -0.75, 0);
                gGroup.add(wheel);
            }
            gGroup.position.set(x, -R, z);
            return gGroup;
        }
        // Nose gear (single pair, forward)
        planeExtGroup.add(makeGear(0, halfLen - 5, 2));
        // Main gear (double pair, under wings)
        planeExtGroup.add(makeGear(1.5, -3, 2));
        planeExtGroup.add(makeGear(-1.5, -3, 2));

        // Position the whole plane: nose pointing +Z, at the gate
        // Ground clearance: bottom of wheels should touch y=0
        planeExtGroup.position.set(18, R + 1.5, 0);
    }

    // ═══════════════════════════════════════════════════
    //  CABIN INTERIOR
    // ═══════════════════════════════════════════════════
    // ── CABIN: Z-forward, X = left/right, Y = up ──
    // Real 737 cabin: ~3.54m wide, ~2.2m tall inside, ~24m passenger cabin length
    // Scale: 1 unit ≈ 1 meter
    function buildCabin() {
        var CW = 3.54; // cabin width (meters)
        var CH = 2.2;  // cabin height
        var CL = 22;   // cabin length (passenger section)
        var halfW = CW / 2;
        var halfL = CL / 2;

        // ── Fuselage shell (half-cylinder arch, inside face) ──
        var archSegs = 20;
        for (var wp = 0; wp < archSegs; wp++) {
            // Arch from -halfW to +halfW, height 0 to CH
            var a0 = (wp / archSegs) * Math.PI;
            var a1 = ((wp + 1) / archSegs) * Math.PI;
            var x0 = Math.cos(a0) * halfW;
            var y0 = Math.sin(a0) * (CH * 0.55) + CH * 0.3;
            var x1 = Math.cos(a1) * halfW;
            var y1 = Math.sin(a1) * (CH * 0.55) + CH * 0.3;

            var verts = new Float32Array([
                x0, y0, -halfL,  x0, y0, halfL,  x1, y1, halfL,  x1, y1, -halfL
            ]);
            var idx = [0, 2, 1, 0, 3, 2]; // inward-facing normals
            var geo = new THREE.BufferGeometry();
            geo.setAttribute('position', new THREE.BufferAttribute(verts, 3));
            geo.setIndex(idx);
            geo.computeVertexNormals();
            cabinGroup.add(new THREE.Mesh(geo, MAT.plastic));
        }

        // ── Floor ──
        var floor = new THREE.Mesh(new THREE.PlaneGeometry(CW, CL), MAT.carpet);
        floor.rotation.x = -Math.PI / 2;
        cabinGroup.add(floor);

        // ── Aisle strip (center of floor) ──
        var aisleMat = new THREE.MeshStandardMaterial({ color: 0x222830, roughness: 0.9 });
        var aisle = new THREE.Mesh(new THREE.PlaneGeometry(0.5, CL), aisleMat);
        aisle.rotation.x = -Math.PI / 2;
        aisle.position.y = 0.005;
        cabinGroup.add(aisle);

        // ── Seats: 3-3 layout (A B C | aisle | D E F) ──
        // Real economy seat: ~44cm wide, ~80cm pitch (row spacing)
        var seatWidth = 0.44;
        var rowPitch = 0.80;
        var aisleHalfW = 0.25;
        // Left group: seats at x = aisleHalfW + seatWidth*0.5, +seatWidth, +seatWidth*2
        // Right group: mirrored
        var seatPositionsX = [];
        for (var s = 0; s < 3; s++) {
            var leftX = aisleHalfW + seatWidth * 0.5 + s * seatWidth;
            seatPositionsX.push(leftX);   // left side (+X)
            seatPositionsX.push(-leftX);  // right side (-X)
        }

        var firstRowZ = -halfL + 1.5;
        var numRows = Math.floor((CL - 2) / rowPitch);
        for (var row = 0; row < numRows; row++) {
            var rz = firstRowZ + row * rowPitch;
            for (var si = 0; si < seatPositionsX.length; si++) {
                cabinGroup.add(buildSeat(seatPositionsX[si], rz));
            }
        }

        // ── Overhead bins (both sides, continuous panels) ──
        var binH = 0.4, binD = 0.55;
        var binY = CH - 0.45;
        for (var bSide = -1; bSide <= 1; bSide += 2) {
            for (var bz = -halfL + 1; bz < halfL - 1; bz += 3) {
                var segLen = Math.min(2.8, halfL - 1 - bz);
                if (segLen < 0.5) continue;
                var bin = new THREE.Mesh(new THREE.BoxGeometry(binD, binH, segLen), MAT.plastic);
                bin.position.set(bSide * (halfW - binD / 2 - 0.05), binY, bz + segLen / 2);
                cabinGroup.add(bin);
                // Handle
                var handle = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.03, segLen * 0.5), MAT.darkPlastic);
                handle.position.set(bSide * (halfW - binD - 0.07), binY - binH / 2 - 0.02, bz + segLen / 2);
                cabinGroup.add(handle);
            }
        }

        // ── Windows (interior, on walls) ──
        for (var wz = -halfL + 1.5; wz < halfL - 1; wz += rowPitch) {
            for (var wSide = -1; wSide <= 1; wSide += 2) {
                // Rounded-rect window frame
                var frame = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.28, 0.20), MAT.darkPlastic);
                frame.position.set(wSide * (halfW - 0.02), 1.15, wz);
                cabinGroup.add(frame);
                // Glass
                var glass = new THREE.Mesh(new THREE.PlaneGeometry(0.24, 0.16), MAT.windowInner);
                glass.position.set(wSide * (halfW - 0.01), 1.15, wz);
                glass.rotation.y = wSide > 0 ? -Math.PI / 2 : Math.PI / 2;
                cabinGroup.add(glass);
            }
        }

        // ── Ceiling light panels (along center) ──
        for (var lz = -halfL + 1; lz < halfL - 1; lz += 2) {
            var lPanel = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.03, 1.8), MAT.lightEmit);
            lPanel.position.set(0, CH - 0.02, lz);
            cabinGroup.add(lPanel);
            cabinLightMeshes.push(lPanel);

            // Actual point light every 4m
            if (Math.abs(lz % 4) < 1) {
                var pLight = new THREE.PointLight(0xffffee, 0.4, 6);
                pLight.position.set(0, CH - 0.1, lz);
                cabinGroup.add(pLight);
                cabinLights.push(pLight);
            }
        }

        // ── Reading light nozzles (under overhead bins) ──
        for (var rlz = -halfL + 1.5; rlz < halfL - 1; rlz += rowPitch) {
            for (var rlSide = -1; rlSide <= 1; rlSide += 2) {
                var nozzle = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.03, 0.06, 8), MAT.darkPlastic);
                nozzle.position.set(rlSide * (halfW - binD - 0.1), binY - binH / 2 - 0.06, rlz);
                cabinGroup.add(nozzle);
            }
        }

        // ── Cockpit door (front, centered) ──
        var cDoor = new THREE.Mesh(new THREE.BoxGeometry(0.9, 1.9, 0.08), MAT.metal);
        cDoor.position.set(0, 0.95, halfL - 0.04);
        cabinGroup.add(cDoor);

        // ── EXIT signs (front and rear) ──
        var exitMat = new THREE.MeshBasicMaterial({ color: 0x00ff44 });
        var ex1 = new THREE.Mesh(new THREE.BoxGeometry(0.35, 0.12, 0.02), exitMat);
        ex1.position.set(0, CH - 0.1, halfL - 0.5);
        cabinGroup.add(ex1);
        var ex2 = new THREE.Mesh(new THREE.BoxGeometry(0.35, 0.12, 0.02), exitMat);
        ex2.position.set(0, CH - 0.1, -halfL + 0.5);
        cabinGroup.add(ex2);

        // ── Emergency floor LEDs (hidden initially, along aisle edges) ──
        for (var elz = -halfL + 1; elz < halfL - 1; elz += 1.2) {
            for (var elSide = -1; elSide <= 1; elSide += 2) {
                var eled = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.015, 0.06), MAT.emergencyGreen);
                eled.position.set(elSide * 0.3, 0.01, elz);
                eled.visible = false;
                cabinGroup.add(eled);
                emergencyLightMeshes.push(eled);
            }
        }

        cabinGroup.visible = false;
    }

    // ── Single seat: faces +Z (toward cockpit), x = lateral position, z = row position ──
    // Real economy seat: ~44cm wide, ~42cm deep cushion, back ~60cm tall
    function buildSeat(x, z) {
        var sg = new THREE.Group();
        var W = 0.42, D = 0.42, backH = 0.58, backT = 0.05;
        var legH = 0.40, cushionH = 0.08;
        var seatY = legH; // top of legs = bottom of cushion

        // Legs (two vertical posts)
        sg.add(pm(new THREE.BoxGeometry(0.03, legH, 0.03), MAT.metal, -W/2+0.04, legH/2, 0));
        sg.add(pm(new THREE.BoxGeometry(0.03, legH, 0.03), MAT.metal,  W/2-0.04, legH/2, 0));

        // Seat cushion
        sg.add(pm(new THREE.BoxGeometry(W, cushionH, D), MAT.seat, 0, seatY + cushionH/2, 0));

        // Seat back (behind cushion, angled slightly)
        var back = pm(new THREE.BoxGeometry(W, backH, backT), MAT.seatBack, 0, seatY + cushionH + backH/2, -D/2 + backT/2);
        back.rotation.x = 0.08; // slight recline
        sg.add(back);

        // Headrest
        sg.add(pm(new THREE.BoxGeometry(W*0.6, 0.16, 0.04), MAT.plastic, 0, seatY + cushionH + backH + 0.04, -D/2 + 0.02));

        // Armrests (on left and right edges)
        for (var arm = -1; arm <= 1; arm += 2) {
            sg.add(pm(new THREE.BoxGeometry(0.04, 0.03, D*0.7), MAT.darkPlastic, arm * W/2, seatY + cushionH + 0.04, 0.04));
        }

        // Seat pocket (fabric on back)
        sg.add(pm(new THREE.BoxGeometry(W*0.8, 0.18, 0.008), MAT.darkPlastic, 0, seatY + 0.12, -D/2 + backT + 0.005));

        sg.position.set(x, 0, z);
        return sg;
    }

    function pm(geo, mat, x, y, z) {
        var m = new THREE.Mesh(geo, mat);
        m.position.set(x, y, z);
        return m;
    }

    // ═══════════════════════════════════════════════════
    //  CLOUDS
    // ═══════════════════════════════════════════════════
    function buildCloud(x, y, z, scale, mat) {
        var cg = new THREE.Group();
        mat = mat || new THREE.MeshLambertMaterial({ color: 0xffffff, transparent: true, opacity: 0.88 });
        var count = 4 + Math.floor(Math.random() * 6);
        for (var i = 0; i < count; i++) {
            var r = (0.6 + Math.random() * 1.4) * scale;
            var s = new THREE.Mesh(new THREE.SphereGeometry(r, 7, 7), mat);
            s.position.set(
                (Math.random() - 0.5) * 5 * scale,
                (Math.random() - 0.5) * 1.5 * scale,
                (Math.random() - 0.5) * 4 * scale
            );
            cg.add(s);
        }
        cg.position.set(x, y, z);
        cg.userData.speed = 0.3 + Math.random() * 0.7;
        return cg;
    }

    function populateClouds() {
        for (var i = 0; i < 40; i++) {
            cloudGroup.add(buildCloud(
                (Math.random() - 0.5) * 600,
                25 + Math.random() * 80,
                (Math.random() - 0.5) * 600,
                2 + Math.random() * 4
            ));
        }
    }

    function populateStormClouds() {
        for (var i = 0; i < 30; i++) {
            stormCloudGroup.add(buildCloud(
                (Math.random() - 0.5) * 500,
                20 + Math.random() * 40,
                (Math.random() - 0.5) * 500,
                3 + Math.random() * 6,
                Math.random() < 0.5 ? MAT.stormCloud : MAT.darkCloud
            ));
        }
        stormCloudGroup.visible = false;
    }

    // ═══════════════════════════════════════════════════
    //  SURVIVAL SCENE
    // ═══════════════════════════════════════════════════
    function buildSurvivalScene() {
        // Dark terrain
        var ground = new THREE.Mesh(
            new THREE.PlaneGeometry(200, 200),
            new THREE.MeshStandardMaterial({ color: 0x1a2a10, roughness: 0.95 })
        );
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = -0.5;
        survivalGroup.add(ground);

        // Wreckage pieces
        for (var i = 0; i < 20; i++) {
            var size = 0.5 + Math.random() * 3;
            var piece = new THREE.Mesh(
                new THREE.BoxGeometry(size, size * 0.5, size * 0.7),
                new THREE.MeshStandardMaterial({
                    color: new THREE.Color().setHSL(0, 0, 0.3 + Math.random() * 0.4),
                    roughness: 0.9
                })
            );
            piece.position.set(
                (Math.random() - 0.5) * 40,
                size * 0.2,
                (Math.random() - 0.5) * 40
            );
            piece.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * 0.5);
            survivalGroup.add(piece);
        }

        // Fire glow (simple)
        var fireLight = new THREE.PointLight(0xff6600, 2, 30);
        fireLight.position.set(5, 2, -3);
        survivalGroup.add(fireLight);

        // Fire particles (simple mesh clusters)
        for (var f = 0; f < 8; f++) {
            var flame = new THREE.Mesh(
                new THREE.ConeGeometry(0.3 + Math.random() * 0.4, 1 + Math.random() * 1.5, 6),
                new THREE.MeshBasicMaterial({ color: Math.random() < 0.5 ? 0xff4400 : 0xff8800, transparent: true, opacity: 0.8 })
            );
            flame.position.set(5 + (Math.random() - 0.5) * 3, 0.5 + Math.random(), -3 + (Math.random() - 0.5) * 3);
            flame.userData.baseY = flame.position.y;
            flame.userData.flicker = Math.random() * Math.PI * 2;
            survivalGroup.add(flame);
        }

        // Smoke column
        for (var sm = 0; sm < 12; sm++) {
            var smoke = new THREE.Mesh(
                new THREE.SphereGeometry(1 + Math.random() * 2, 6, 6),
                new THREE.MeshBasicMaterial({ color: 0x222222, transparent: true, opacity: 0.3 + Math.random() * 0.3 })
            );
            smoke.position.set(5 + (Math.random() - 0.5) * 2, 4 + sm * 2, -3 + (Math.random() - 0.5) * 2);
            survivalGroup.add(smoke);
        }

        // Emergency flashers on ground
        for (var ef = 0; ef < 5; ef++) {
            var flasher = new THREE.Mesh(
                new THREE.SphereGeometry(0.1, 6, 6),
                new THREE.MeshBasicMaterial({ color: 0xff0000 })
            );
            flasher.position.set(-10 + ef * 5, 0.1, 8);
            flasher.userData.flashPhase = ef * 0.5;
            survivalGroup.add(flasher);
        }

        survivalGroup.visible = false;
    }

    // ═══════════════════════════════════════════════════
    //  RAIN SYSTEM (2D canvas overlay)
    // ═══════════════════════════════════════════════════
    var rainCanvas = document.getElementById('rain-canvas');
    var rainCtx = rainCanvas.getContext('2d');
    var rainDrops = [];

    function initRain() {
        rainCanvas.width = window.innerWidth;
        rainCanvas.height = window.innerHeight;
        for (var i = 0; i < 200; i++) {
            rainDrops.push({
                x: Math.random() * rainCanvas.width,
                y: Math.random() * rainCanvas.height,
                len: 10 + Math.random() * 20,
                speed: 8 + Math.random() * 12,
                opacity: 0.1 + Math.random() * 0.3
            });
        }
    }

    function updateRain() {
        if (G.rainIntensity <= 0) return;
        rainCtx.clearRect(0, 0, rainCanvas.width, rainCanvas.height);
        for (var i = 0; i < rainDrops.length; i++) {
            var d = rainDrops[i];
            d.y += d.speed * G.rainIntensity;
            d.x -= 2 * G.rainIntensity;
            if (d.y > rainCanvas.height) { d.y = -d.len; d.x = Math.random() * rainCanvas.width; }
            if (d.x < 0) d.x = rainCanvas.width;
            rainCtx.beginPath();
            rainCtx.moveTo(d.x, d.y);
            rainCtx.lineTo(d.x + 1, d.y + d.len * G.rainIntensity);
            rainCtx.strokeStyle = 'rgba(180,200,220,' + (d.opacity * G.rainIntensity) + ')';
            rainCtx.lineWidth = 1;
            rainCtx.stroke();
        }
    }

    // ═══════════════════════════════════════════════════
    //  UI HELPERS
    // ═══════════════════════════════════════════════════
    var $phase = document.getElementById('phase-label');
    var $alt = document.getElementById('altitude-box');
    var $altVal = document.getElementById('alt-val');
    var $spdVal = document.getElementById('spd-val');
    var $hdgVal = document.getElementById('hdg-val');
    var $prompt = document.getElementById('prompt');
    var $sub = document.getElementById('sub-prompt');
    var $seatbelt = document.getElementById('seatbelt-sign');
    var $captain = document.getElementById('captain-box');
    var $captainText = document.getElementById('captain-text');
    var $warning = document.getElementById('warning');
    var $fade = document.getElementById('fade');
    var $flash = document.getElementById('flash');
    var $eStrip = document.getElementById('emergency-strip');
    var $survival = document.getElementById('survival-text');
    var $continueBtn = document.getElementById('continue-btn');

    function showPrompt(text, dur) {
        $prompt.textContent = text;
        $prompt.classList.add('visible');
        if (dur) setTimeout(function() { $prompt.classList.remove('visible'); }, dur);
    }
    function hidePrompt() { $prompt.classList.remove('visible'); }

    function showSub(text) { $sub.textContent = text; $sub.classList.add('visible'); }
    function hideSub() { $sub.classList.remove('visible'); }

    function showCaptain(text, dur) {
        $captain.querySelector('.captain-label').textContent = '— Captain Speaking —';
        $captainText.textContent = text;
        $captain.classList.add('visible');
        playDing();
        if (dur) setTimeout(function() { $captain.classList.remove('visible'); }, dur);
    }
    function hideCaptain() { $captain.classList.remove('visible'); }

    function showWarning(text) { $warning.textContent = text; $warning.classList.add('visible'); }
    function hideWarning() { $warning.classList.remove('visible'); }

    function fadeIn(dur) {
        $fade.style.transition = 'opacity ' + (dur || 1.5) + 's ease';
        $fade.classList.add('visible');
    }
    function fadeOut(dur) {
        $fade.style.transition = 'opacity ' + (dur || 1.5) + 's ease';
        $fade.classList.remove('visible');
    }

    function doFlash(intensity, dur) {
        $flash.style.opacity = intensity || 0.9;
        $flash.style.transition = 'opacity ' + (dur || 0.5) + 's ease-out';
        setTimeout(function() { $flash.style.opacity = 0; }, 50);
    }

    function setPhaseLabel(txt) { $phase.textContent = txt; }

    function updateHUD() {
        $altVal.textContent = Math.max(0, Math.round(G.altitude)).toLocaleString();
        $spdVal.textContent = Math.round(G.speed);
        $hdgVal.textContent = Math.round(G.heading);
    }

    // ═══════════════════════════════════════════════════
    //  PHASE SYSTEM
    // ═══════════════════════════════════════════════════
    var phaseTimers = [];

    function clearPhaseTimers() {
        for (var i = 0; i < phaseTimers.length; i++) clearTimeout(phaseTimers[i]);
        phaseTimers = [];
    }

    function pt(fn, delay) {
        phaseTimers.push(setTimeout(fn, delay));
    }

    function goPhase(phase) {
        clearPhaseTimers();
        G.phase = phase;
        G.transitioning = true;

        switch (phase) {

        // ─── AIRPORT ───
        case 'airport':
            setPhaseLabel('Airport Terminal');
            airportGroup.visible = true;
            planeExtGroup.visible = true;
            cabinGroup.visible = false;
            stormCloudGroup.visible = false;
            survivalGroup.visible = false;
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.FogExp2(0x87CEEB, 0.0008);
            // Camera in front of terminal looking at plane (plane at x=18)
            camera.position.set(-5, 3.0, 18);
            camera.lookAt(new THREE.Vector3(18, 4, 0));
            G.cameraBasePos.copy(camera.position);
            showPrompt('Welcome to the airport.', 3500);
            pt(function() {
                showSub('Click to begin boarding');
                G.canClick = true;
                G.transitioning = false;
            }, 1500);
            break;

        // ─── BOARDING ───
        case 'boarding':
            G.canClick = false;
            setPhaseLabel('Boarding');
            showPrompt('Boarding the aircraft...', 3000);
            hideSub();

            pt(function() {
                fadeIn(1.5);
            }, 2000);

            pt(function() {
                airportGroup.visible = false;
                planeExtGroup.visible = false;
                cabinGroup.visible = true;

                // Standing in aisle at rear of cabin, looking forward (+Z)
                camera.position.set(0, 1.65, -9);
                camera.rotation.set(0, 0, 0);
                G.cameraBasePos.copy(camera.position);
                G.lookX = 0; G.lookY = 0;
                G.targetLookX = 0; G.targetLookY = 0;

                setCabinVolume(0.15);
                fadeOut(1.5);
            }, 4000);

            pt(function() {
                setPhaseLabel('Finding Your Seat');
                showPrompt('Find your seat...', 2500);
            }, 5500);

            pt(function() {
                showSub('Click to take your window seat');
                G.canClick = true;
                G.transitioning = false;
            }, 7000);
            break;

        // ─── SEATED ───
        case 'seated':
            G.canClick = false;
            setPhaseLabel('Seated');

            // Animate to window seat (seat A, left side +X, mid-cabin)
            // Eye height when seated: ~1.15m (seat at 0.48m + torso)
            var seatTarget = new THREE.Vector3(1.45, 1.15, -2);
            animateCamera(seatTarget, 1500, function() {
                camera.position.copy(seatTarget);
                G.cameraBasePos.copy(camera.position);
                G.lookX = 0; G.lookY = 0;

                showPrompt('Please fasten your seatbelt.', 2500);
                playDing();
            });

            pt(function() {
                showCaptain(
                    'Good afternoon, ladies and gentlemen. Welcome aboard. ' +
                    'This is your captain speaking. We\'ll be cruising at 35,000 feet today. ' +
                    'Flight time will be approximately three hours. ' +
                    'Please fasten your seatbelts and ensure your tray tables are in the upright position.',
                    9000
                );
            }, 4000);

            pt(function() {
                $seatbelt.classList.add('visible');
            }, 4500);

            pt(function() {
                showSub('Click when ready for departure');
                G.canClick = true;
                G.transitioning = false;
            }, 13500);
            break;

        // ─── TAXI ───
        case 'taxi':
            G.canClick = false;
            setPhaseLabel('Taxiing');
            hideSub();

            showPrompt('Taxiing to runway...', 3000);
            G.shakeAmount = 0.003;
            setEngineVolume(0.15);

            pt(function() {
                showCaptain(
                    'Cabin crew, please prepare for takeoff.',
                    3500
                );
            }, 3500);

            pt(function() {
                G.transitioning = false;
                goPhase('takeoff');
            }, 8000);
            break;

        // ─── TAKEOFF ───
        case 'takeoff':
            setPhaseLabel('Takeoff');
            $alt.classList.add('visible');
            showPrompt('Prepare for takeoff...', 2500);
            G.speed = 0;

            setEngineVolume(0.5);

            var toAccel = setInterval(function() {
                G.speed += 3;
                G.shakeAmount = 0.004 + G.speed * 0.00015;
                setEngineVolume(Math.min(0.8, 0.3 + G.speed * 0.003));
                setWindVolume(Math.min(0.3, G.speed * 0.002));
                updateHUD();

                if (G.speed >= 165) {
                    clearInterval(toAccel);
                    showPrompt('Rotate...', 1500);
                    pt(function() { goPhase('climbing'); }, 1800);
                }
            }, 80);
            phaseTimers.push(toAccel);
            break;

        // ─── CLIMBING ───
        case 'climbing':
            setPhaseLabel('Climbing');
            showPrompt('Climbing to cruising altitude...', 3000);
            G.pitch = 5;

            var climbInt = setInterval(function() {
                G.altitude += 400;
                G.shakeAmount = Math.max(0.001, G.shakeAmount * 0.995);

                // Sky color transitions with altitude
                var f = Math.min(G.altitude / 35000, 1);
                var skyCol = new THREE.Color().lerpColors(
                    new THREE.Color(0x87CEEB),
                    new THREE.Color(0x1a3a6e),
                    f
                );
                scene.background = skyCol;
                scene.fog.color = skyCol;
                renderer.toneMappingExposure = 1.0 - f * 0.3;

                updateHUD();

                if (G.altitude >= 35000) {
                    clearInterval(climbInt);
                    G.pitch = 0;
                    goPhase('cruising');
                }
            }, 150);
            phaseTimers.push(climbInt);
            break;

        // ─── CRUISING ───
        case 'cruising':
            setPhaseLabel('Cruising — 35,000 ft');
            $seatbelt.classList.remove('visible');
            G.shakeAmount = 0.0004;
            G.speed = 480;

            showPrompt('You may now move about the cabin.', 3000);
            setEngineVolume(0.2);
            setWindVolume(0.15);
            setCabinVolume(0.2);

            pt(function() {
                showCaptain(
                    'We\'ve reached our cruising altitude of 35,000 feet. ' +
                    'The seatbelt sign has been turned off. ' +
                    'Sit back and enjoy the flight.',
                    6000
                );
            }, 4000);

            pt(function() {
                showPrompt('Smooth skies ahead...', 3000);
            }, 12000);

            // Transition to turbulence
            pt(function() {
                G.transitioning = false;
                goPhase('turbulence_light');
            }, 18000);
            break;

        // ─── LIGHT TURBULENCE ───
        case 'turbulence_light':
            setPhaseLabel('Light Turbulence');
            $seatbelt.classList.add('visible');
            playDing();

            pt(function() {
                showCaptain(
                    'Ladies and gentlemen, we\'re experiencing some light turbulence. ' +
                    'Please return to your seats and fasten your seatbelts.',
                    5000
                );
            }, 500);

            var ltLevel = 0;
            var ltInt = setInterval(function() {
                ltLevel += 0.05;
                G.shakeAmount = 0.003 + ltLevel * 0.004;
                G.roll = Math.sin(G.time * 2) * ltLevel * 2;
            }, 200);
            phaseTimers.push(ltInt);

            pt(function() {
                clearInterval(ltInt);
                goPhase('storm');
            }, 8000);
            break;

        // ─── STORM ───
        case 'storm':
            setPhaseLabel('Severe Turbulence');

            // Darken sky
            scene.background = new THREE.Color(0x0a0a15);
            scene.fog = new THREE.FogExp2(0x0a0a15, 0.003);
            renderer.toneMappingExposure = 0.4;

            stormCloudGroup.visible = true;
            cloudGroup.visible = false;

            // Rain
            G.rainIntensity = 0.6;
            rainCanvas.classList.add('visible');

            // Dim cabin lights
            dimCabinLights(true);

            setEngineVolume(0.6);
            setWindVolume(0.5);

            showPrompt('Weather ahead...', 2000);

            var stormLevel = 0;
            var stormInt = setInterval(function() {
                stormLevel += 0.04;
                G.shakeAmount = 0.008 + stormLevel * 0.008;
                G.roll = Math.sin(G.time * 3) * stormLevel * 3;
                G.pitch = Math.sin(G.time * 1.5) * stormLevel;
                G.rainIntensity = Math.min(1.0, 0.6 + stormLevel * 0.2);
                setWindVolume(Math.min(0.8, 0.5 + stormLevel * 0.1));
            }, 200);
            phaseTimers.push(stormInt);

            // Lightning strikes
            pt(function() { triggerLightning(); }, 3000);
            pt(function() { triggerLightning(); }, 5500);
            pt(function() { triggerLightning(); }, 7000);
            pt(function() { triggerLightning(); }, 8200);
            pt(function() { triggerLightning(); triggerLightning(); }, 9500);

            pt(function() {
                showCaptain(
                    'We are passing through a severe storm cell. ' +
                    'Please remain calm and keep your seatbelts tightly fastened.',
                    5000
                );
            }, 4000);

            pt(function() {
                clearInterval(stormInt);
                goPhase('lightning_intense');
            }, 12000);
            break;

        // ─── INTENSE LIGHTNING ───
        case 'lightning_intense':
            setPhaseLabel('⚡ Electrical Storm');

            G.shakeAmount = 0.03;
            G.rainIntensity = 1.0;
            setWindVolume(0.9);
            setEngineVolume(0.8);

            // Rapid lightning
            var lnCount = 0;
            var lnInt = setInterval(function() {
                triggerLightning();
                lnCount++;
                G.shakeAmount = 0.03 + Math.random() * 0.02;
                G.roll = (Math.random() - 0.5) * 8;
                G.pitch = (Math.random() - 0.5) * 3;

                // Altitude drops
                G.altitude -= 200 + Math.random() * 300;
                updateHUD();
            }, 800);
            phaseTimers.push(lnInt);

            pt(function() {
                showPrompt('', 100);
                showWarning('SEVERE TURBULENCE');
            }, 1000);

            pt(function() {
                hideWarning();
            }, 3000);

            // Big lightning hit
            pt(function() {
                clearInterval(lnInt);
                doFlash(1.0, 0.8);
                playThunder();
                G.shakeAmount = 0.08;
                showWarning('⚡ LIGHTNING STRIKE');

                // Brief power flicker
                flickerCabinLights();
            }, 6000);

            pt(function() {
                hideWarning();
                goPhase('emergency');
            }, 8500);
            break;

        // ─── EMERGENCY ───
        case 'emergency':
            setPhaseLabel('🔴 EMERGENCY');
            $phase.style.background = 'rgba(200,0,0,0.8)';
            playAlarm();

            // Systems failing
            showWarning('BRACE FOR IMPACT');

            // Drop oxygen masks
            dropOxygenMasks();

            // Emergency lights
            G.emergencyLights = true;
            $eStrip.classList.add('visible');
            for (var i = 0; i < emergencyLightMeshes.length; i++) {
                emergencyLightMeshes[i].visible = true;
            }

            // Kill main cabin lights
            setCabinLightsPower(false);

            G.shakeAmount = 0.06;
            G.rainIntensity = 1.0;
            setWindVolume(1.0);

            pt(function() {
                showCaptain(
                    'BRACE BRACE BRACE! Heads down, stay down!',
                    4000
                );
            }, 2000);

            // Rapid descent
            var descInt = setInterval(function() {
                G.altitude -= 1500;
                G.speed += 5;
                G.shakeAmount = 0.05 + (35000 - Math.max(0, G.altitude)) / 35000 * 0.08;
                G.pitch = -8 - (35000 - Math.max(0, G.altitude)) / 35000 * 10;

                // Sky changes during descent
                var descF = Math.max(0, G.altitude) / 35000;
                scene.background.lerpColors(
                    new THREE.Color(0x1a0a0a),
                    new THREE.Color(0x0a0a15),
                    descF
                );

                updateHUD();

                if (G.altitude <= 0) {
                    clearInterval(descInt);
                    goPhase('crash');
                }
            }, 100);
            phaseTimers.push(descInt);
            break;

        // ─── CRASH ───
        case 'crash':
            G.altitude = 0;
            G.speed = 0;
            setPhaseLabel('IMPACT');

            playImpact();
            doFlash(1.0, 0.3);
            G.shakeAmount = 0.15;

            setEngineVolume(0);
            setWindVolume(0);
            setCabinVolume(0);

            showWarning('');
            hideWarning();

            // Violent shake then fade
            pt(function() {
                G.shakeAmount = 0.08;
            }, 500);

            pt(function() {
                G.shakeAmount = 0.03;
                fadeIn(2);
            }, 1500);

            pt(function() {
                G.shakeAmount = 0;
                goPhase('survival');
            }, 4000);
            break;

        // ─── SURVIVAL ───
        case 'survival':
            setPhaseLabel('');
            $alt.classList.remove('visible');
            $seatbelt.classList.remove('visible');
            $eStrip.classList.remove('visible');
            hideWarning();
            hideSub();
            $phase.style.background = '';
            G.rainIntensity = 0.3;

            cabinGroup.visible = false;
            stormCloudGroup.visible = false;
            airportGroup.visible = false;
            survivalGroup.visible = true;

            scene.background = new THREE.Color(0x050508);
            scene.fog = new THREE.FogExp2(0x050508, 0.02);
            renderer.toneMappingExposure = 0.5;
            ambientLight.intensity = 0.15;

            camera.position.set(0, 1.7, 15);
            camera.lookAt(new THREE.Vector3(5, 1, -3));
            G.cameraBasePos.copy(camera.position);
            G.shakeAmount = 0;

            fadeOut(3);

            pt(function() {
                $survival.innerHTML = 'You survived.';
                $survival.classList.add('visible');
            }, 3000);

            pt(function() {
                $survival.classList.remove('visible');
            }, 6000);

            pt(function() {
                $survival.innerHTML =
                    'In reality, 95.7% of passengers survive plane crashes.<br><br>' +
                    'Flying remains the safest form of long-distance travel.<br><br>' +
                    'Your chances of being in a fatal crash are<br><b style="font-size:2rem">1 in 13,700,000</b>';
                $survival.classList.add('visible');
            }, 7500);

            pt(function() {
                $continueBtn.classList.add('visible');
            }, 12000);
            break;
        }
    }

    // ═══════════════════════════════════════════════════
    //  CABIN LIGHT CONTROLS
    // ═══════════════════════════════════════════════════
    function dimCabinLights(dim) {
        G.cabinLightsDim = dim;
        var targetIntensity = dim ? 0.1 : 0.4;
        for (var i = 0; i < cabinLights.length; i++) {
            cabinLights[i].intensity = targetIntensity;
        }
        for (var j = 0; j < cabinLightMeshes.length; j++) {
            cabinLightMeshes[j].material = dim ? MAT.lightEmitDim : MAT.lightEmit;
        }
    }

    function setCabinLightsPower(on) {
        G.cabinLightsOn = on;
        for (var i = 0; i < cabinLights.length; i++) {
            cabinLights[i].intensity = on ? 0.1 : 0;
        }
        for (var j = 0; j < cabinLightMeshes.length; j++) {
            cabinLightMeshes[j].visible = on;
        }
    }

    function flickerCabinLights() {
        var count = 0;
        var flickInt = setInterval(function() {
            count++;
            var on = count % 2 === 0;
            for (var i = 0; i < cabinLights.length; i++) {
                cabinLights[i].intensity = on ? 0.15 : 0;
            }
            for (var j = 0; j < cabinLightMeshes.length; j++) {
                cabinLightMeshes[j].visible = on;
            }
            if (count > 8) {
                clearInterval(flickInt);
                dimCabinLights(true);
            }
        }, 100);
    }

    // ═══════════════════════════════════════════════════
    //  LIGHTNING EFFECT
    // ═══════════════════════════════════════════════════
    function triggerLightning() {
        doFlash(0.6 + Math.random() * 0.4, 0.3 + Math.random() * 0.4);
        playThunder();

        // Create lightning bolt geometry in scene
        var bolt = createLightningBolt();
        lightningGroup.add(bolt);
        setTimeout(function() { lightningGroup.remove(bolt); }, 200);
    }

    function createLightningBolt() {
        var points = [];
        var x = (Math.random() - 0.5) * 100;
        var z = (Math.random() - 0.5) * 100;
        var y = 50 + Math.random() * 30;
        for (var i = 0; i < 10; i++) {
            points.push(new THREE.Vector3(
                x + (Math.random() - 0.5) * 10,
                y - i * (y / 10),
                z + (Math.random() - 0.5) * 10
            ));
        }
        var geo = new THREE.BufferGeometry().setFromPoints(points);
        var mat = new THREE.LineBasicMaterial({ color: 0xeeeeff, linewidth: 2 });
        return new THREE.Line(geo, mat);
    }

    // ═══════════════════════════════════════════════════
    //  OXYGEN MASKS
    // ═══════════════════════════════════════════════════
    function dropOxygenMasks() {
        var positions = ['25%', '40%', '55%', '70%'];
        for (var i = 0; i < positions.length; i++) {
            (function(idx) {
                pt(function() {
                    var mask = document.createElement('div');
                    mask.className = 'oxygen-mask';
                    mask.style.left = positions[idx];
                    mask.style.top = '-100px';
                    mask.innerHTML = '<div class="mask-tube"></div><div class="mask-cup"></div>';
                    document.body.appendChild(mask);

                    setTimeout(function() {
                        mask.style.opacity = '1';
                        mask.style.transform = 'translateY(200px)';
                    }, 50);
                }, idx * 150);
            })(i);
        }
    }

    // ═══════════════════════════════════════════════════
    //  CAMERA ANIMATION HELPER
    // ═══════════════════════════════════════════════════
    function animateCamera(target, duration, callback) {
        var start = camera.position.clone();
        var startTime = performance.now();
        function step(now) {
            var t = Math.min((now - startTime) / duration, 1);
            t = t * t * (3 - 2 * t); // smoothstep
            camera.position.lerpVectors(start, target, t);
            if (t < 1) {
                requestAnimationFrame(step);
            } else {
                if (callback) callback();
            }
        }
        requestAnimationFrame(step);
    }

    // ═══════════════════════════════════════════════════
    //  INPUT
    // ═══════════════════════════════════════════════════
    var audioStarted = false;

    document.addEventListener('click', function() {
        if (!audioStarted) {
            initAudio();
            audioStarted = true;
        }

        if (G.transitioning) return;
        if (!G.canClick) return;

        switch (G.phase) {
            case 'airport': goPhase('boarding'); break;
            case 'boarding': goPhase('seated'); break;
            case 'seated': goPhase('taxi'); break;
        }
    });

    document.addEventListener('mousemove', function(e) {
        G.mouseX = e.clientX;
        G.mouseY = e.clientY;
        if (['airport', 'boarding', 'seated', 'cruising'].indexOf(G.phase) !== -1) {
            G.targetLookX = (e.clientX / window.innerWidth - 0.5) * 0.6;
            G.targetLookY = (e.clientY / window.innerHeight - 0.5) * 0.3;
        }
    });

    // Continue button → back to parent
    $continueBtn.addEventListener('click', function() {
        if (window.parent !== window) {
            window.parent.postMessage('simulation-complete', '*');
        }
    });

    // ═══════════════════════════════════════════════════
    //  MAIN ANIMATION LOOP
    // ═══════════════════════════════════════════════════
    var clock = new THREE.Clock();

    function animate() {
        requestAnimationFrame(animate);
        G.delta = Math.min(clock.getDelta(), 0.1);
        G.time += G.delta;

        // ── Smooth look ──
        G.lookX += (G.targetLookX - G.lookX) * 0.04;
        G.lookY += (G.targetLookY - G.lookY) * 0.04;

        // ── Camera shake ──
        if (G.shakeAmount > 0.0001) {
            camera.position.x = G.cameraBasePos.x + (Math.random() - 0.5) * G.shakeAmount * 2;
            camera.position.y = G.cameraBasePos.y + (Math.random() - 0.5) * G.shakeAmount * 2;
            camera.position.z = G.cameraBasePos.z + (Math.random() - 0.5) * G.shakeAmount;
            camera.rotation.z = (Math.random() - 0.5) * G.shakeAmount * 0.4;
        }

        // ── Phase-specific camera ──
        if (G.phase === 'airport') {
            // Looking from terminal toward plane
            camera.rotation.y = -1.1 + G.lookX;
            camera.rotation.x = -0.05 + G.lookY * 0.3;
        }
        if (G.phase === 'boarding') {
            // Standing in aisle, looking forward (+Z)
            camera.rotation.y = G.lookX * 0.8;
            camera.rotation.x = G.lookY * 0.3;
        }
        if (G.phase === 'seated' || G.phase === 'taxi' || G.phase === 'takeoff' ||
            G.phase === 'climbing') {
            // Looking out left window (+X direction) = camera rotY ~ -PI/2
            camera.rotation.y = -Math.PI / 2 + G.lookX * 0.5;
            camera.rotation.x = G.lookY * 0.3;
        }
        if (['cruising', 'turbulence_light', 'storm', 'lightning_intense', 'emergency'].indexOf(G.phase) !== -1) {
            // Mostly looking out window with subtle drift
            camera.rotation.y = -Math.PI / 2 + Math.sin(G.time * 0.15) * 0.02 + G.lookX * 0.4;
            camera.rotation.x = G.lookY * 0.2 + G.pitch * 0.01;
            camera.rotation.z += G.roll * 0.005;
        }
        if (G.phase === 'crash') {
            camera.rotation.y = -Math.PI / 2;
            camera.rotation.x = G.pitch * 0.015;
        }
        if (G.phase === 'survival') {
            // Looking at wreckage/fire
            camera.rotation.y = Math.PI * 0.05 + Math.sin(G.time * 0.1) * 0.02 + G.lookX * 0.2;
            camera.rotation.x = -0.05 + G.lookY * 0.1;
        }

        // ── Animate clouds ──
        var cSpeed = G.speed * 0.08;
        cloudGroup.children.forEach(function(c) {
            c.position.x -= c.userData.speed * G.delta * cSpeed;
            if (c.position.x < -300) {
                c.position.x = 300;
                c.position.z = (Math.random() - 0.5) * 600;
            }
        });
        stormCloudGroup.children.forEach(function(c) {
            c.position.x -= c.userData.speed * G.delta * cSpeed * 0.5;
            if (c.position.x < -250) {
                c.position.x = 250;
                c.position.z = (Math.random() - 0.5) * 500;
            }
        });

        // ── Emergency light flashing ──
        if (G.emergencyLights) {
            var emOn = Math.sin(G.time * 6) > 0;
            for (var el = 0; el < emergencyLightMeshes.length; el++) {
                emergencyLightMeshes[el].visible = (el + (emOn ? 0 : 1)) % 2 === 0;
            }
        }

        // ── Survival fire flicker ──
        if (G.phase === 'survival') {
            survivalGroup.children.forEach(function(child) {
                if (child.userData.flicker !== undefined) {
                    child.userData.flicker += G.delta * 5;
                    child.position.y = child.userData.baseY + Math.sin(child.userData.flicker) * 0.2;
                    child.scale.x = 0.8 + Math.sin(child.userData.flicker * 1.3) * 0.3;
                }
                if (child.userData.flashPhase !== undefined) {
                    child.visible = Math.sin(G.time * 4 + child.userData.flashPhase) > 0.3;
                }
            });
        }

        // ── Rain ──
        updateRain();

        // ── Render ──
        renderer.render(scene, camera);
    }

    // ═══════════════════════════════════════════════════
    //  WINDOW RESIZE
    // ═══════════════════════════════════════════════════
    window.addEventListener('resize', function() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        rainCanvas.width = window.innerWidth;
        rainCanvas.height = window.innerHeight;
    });

    // ═══════════════════════════════════════════════════
    //  INIT & START
    // ═══════════════════════════════════════════════════
    buildAirport();
    buildCabin();
    populateClouds();
    populateStormClouds();
    buildSurvivalScene();
    initRain();

    // Start
    fadeOut(2);
    pt(function() { goPhase('airport'); }, 500);

    animate();

    })();
    </script>
</body>
</html>
