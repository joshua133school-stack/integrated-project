<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flight Experience - FAAH</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; background: #000; font-family: 'Georgia', serif; cursor: default; }
        body.fp-mode { cursor: none; }
        canvas { display: block; }

        /* HUD */
        #hud {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 10;
        }
        #hud > * { pointer-events: auto; }

        #phase-label {
            position: fixed; top: 20px; left: 20px;
            color: #fff; font-size: 14px; z-index: 20;
            background: rgba(0,0,0,0.5); padding: 8px 16px; border-radius: 6px;
            text-transform: uppercase; letter-spacing: 2px;
            pointer-events: none;
        }
        #altitude-box {
            position: fixed; top: 20px; right: 20px;
            color: #fff; font-size: 13px; z-index: 20;
            background: rgba(0,0,0,0.5); padding: 8px 16px; border-radius: 6px;
            font-family: 'Courier New', monospace;
            opacity: 0; transition: opacity 0.8s;
            pointer-events: none;
        }
        #altitude-box.visible { opacity: 1; }

        #prompt {
            position: fixed; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: #fff; font-size: 1.6rem; text-align: center;
            pointer-events: none; z-index: 30;
            opacity: 0; transition: opacity 1s ease;
            text-shadow: 0 2px 20px rgba(0,0,0,0.8);
            max-width: 80%; line-height: 1.6;
        }
        #prompt.visible { opacity: 1; }

        #sub-prompt {
            position: fixed; bottom: 10%; left: 50%;
            transform: translateX(-50%);
            color: rgba(255,255,255,0.7); font-size: 0.95rem; text-align: center;
            pointer-events: none; z-index: 30;
            opacity: 0; transition: opacity 0.8s ease;
            text-shadow: 0 1px 10px rgba(0,0,0,0.8);
            background: rgba(0,0,0,0.35); padding: 10px 24px; border-radius: 8px;
        }
        #sub-prompt.visible { opacity: 1; }

        /* Fade overlay */
        #fade {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 50; opacity: 0;
            pointer-events: none; transition: opacity 1.5s ease;
        }
        #fade.visible { opacity: 1; pointer-events: all; }

        /* Flash (lightning) */
        #flash {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #fff; z-index: 40; opacity: 0;
            pointer-events: none;
        }

        /* Warning */
        #warning {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%,-50%);
            color: #ff4444; font-size: 2.2rem; z-index: 45;
            opacity: 0; transition: opacity 0.4s;
            text-shadow: 0 0 40px rgba(255,0,0,0.6);
            text-align: center; font-weight: bold;
            letter-spacing: 3px; pointer-events: none;
        }
        #warning.visible { opacity: 1; }

        /* Continue button */
        #continue-btn {
            position: fixed; bottom: 25%; left: 50%; transform: translateX(-50%);
            background: rgba(255,255,255,0.9); color: #222;
            border: none; padding: 14px 44px; font-size: 1.1rem;
            font-family: 'Georgia', serif; cursor: pointer;
            z-index: 55; border-radius: 8px;
            opacity: 0; transition: opacity 0.6s;
            pointer-events: none;
        }
        #continue-btn.visible { opacity: 1; pointer-events: auto; }
        #continue-btn:hover { background: #fff; transform: translateX(-50%) scale(1.05); }

        /* Oxygen masks */
        .oxygen-mask {
            position: fixed; z-index: 32; pointer-events: none;
            width: 40px; opacity: 0;
            transition: transform 1.2s cubic-bezier(0.2,0.8,0.3,1), opacity 0.3s;
        }
        .oxygen-mask .mask-tube {
            width: 3px; height: 60px; background: #888; margin: 0 auto;
        }
        .oxygen-mask .mask-cup {
            width: 36px; height: 28px; background: linear-gradient(145deg, #ffcc00, #e6a800);
            border-radius: 0 0 18px 18px; margin: 0 auto;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        /* Emergency lights */
        .emergency-strip {
            position: fixed; bottom: 0; left: 0; width: 100%; height: 4px;
            z-index: 31; opacity: 0; transition: opacity 0.5s;
            pointer-events: none;
        }
        .emergency-strip.visible {
            opacity: 1;
            background: repeating-linear-gradient(90deg, #00ff00 0px, #00ff00 30px, transparent 30px, transparent 60px);
            animation: floor-lights 1s linear infinite;
        }
        @keyframes floor-lights {
            0% { background-position: 0 0; }
            100% { background-position: 60px 0; }
        }

        /* Rain overlay on window */
        #rain-canvas {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 5; pointer-events: none; opacity: 0;
            transition: opacity 1s;
        }
        #rain-canvas.visible { opacity: 1; }

        /* Survival scene text */
        #survival-text {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%,-50%);
            color: #fff; font-size: 1.4rem; text-align: center;
            z-index: 55; opacity: 0; transition: opacity 1s;
            max-width: 80%; line-height: 2;
            pointer-events: none;
        }
        #survival-text.visible { opacity: 1; }
    </style>
</head>
<body>
    <div id="hud">
        <div id="phase-label">Airport Terminal</div>
        <div id="altitude-box">
            ALT <span id="alt-val">0</span> ft<br>
            SPD <span id="spd-val">0</span> kts<br>
            HDG <span id="hdg-val">270</span>°
        </div>
    </div>

    <div id="prompt"></div>
    <div id="sub-prompt"></div>
    <div id="warning"></div>
    <div id="fade"></div>
    <div id="flash"></div>
    <div class="emergency-strip" id="emergency-strip"></div>
    <canvas id="rain-canvas"></canvas>
    <div id="survival-text"></div>
    <button id="continue-btn">Continue</button>

    <script src="https://cdn.jsdelivr.net/npm/three@0.152.0/build/three.min.js"></script>
    <script>
    (function() {
    'use strict';

    // ═══════════════════════════════════════════════════
    //  RENDERER & SCENE
    // ═══════════════════════════════════════════════════
    var renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.0;
    document.body.appendChild(renderer.domElement);

    var scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x87CEEB, 0.0008);

    var camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 5000);

    // ═══════════════════════════════════════════════════
    //  GAME STATE
    // ═══════════════════════════════════════════════════
    var G = {
        phase: 'airport',
        time: 0,
        delta: 0,
        altitude: 0,
        speed: 0,
        heading: 270,
        pitch: 0,
        roll: 0,
        shakeAmount: 0,
        shakeDecay: 0.95,
        cameraBasePos: new THREE.Vector3(),
        cameraBaseRot: new THREE.Euler(),
        lookX: 0, lookY: 0,
        targetLookX: 0, targetLookY: 0,
        mouseX: 0, mouseY: 0,
        canClick: true,
        transitioning: false,
        lightningTimer: 0,
        rainIntensity: 0,
        emergencyLights: false,
        cabinLightsOn: true,
        cabinLightsDim: false
    };

    // ═══════════════════════════════════════════════════
    //  WEB AUDIO - PROCEDURAL SOUND ENGINE
    // ═══════════════════════════════════════════════════
    var audioCtx = null;
    var masterGain = null;
    var engineNode = null, engineGain = null;
    var windNode = null, windGain = null;
    var cabinNode = null, cabinGain = null;

    function initAudio() {
        try {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            masterGain = audioCtx.createGain();
            masterGain.gain.value = 0.3;
            masterGain.connect(audioCtx.destination);

            // Engine rumble (low-frequency noise)
            var bufferSize = 2 * audioCtx.sampleRate;
            engineNode = audioCtx.createBufferSource();
            var engineBuffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            var engineData = engineBuffer.getChannelData(0);
            for (var i = 0; i < bufferSize; i++) {
                engineData[i] = (Math.random() * 2 - 1) * 0.3;
            }
            engineNode.buffer = engineBuffer;
            engineNode.loop = true;

            var engineFilter = audioCtx.createBiquadFilter();
            engineFilter.type = 'lowpass';
            engineFilter.frequency.value = 120;
            engineFilter.Q.value = 1;

            engineGain = audioCtx.createGain();
            engineGain.gain.value = 0;
            engineNode.connect(engineFilter);
            engineFilter.connect(engineGain);
            engineGain.connect(masterGain);
            engineNode.start();

            // Wind noise (high-frequency shaped noise)
            windNode = audioCtx.createBufferSource();
            var windBuffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            var windData = windBuffer.getChannelData(0);
            for (var j = 0; j < bufferSize; j++) {
                windData[j] = (Math.random() * 2 - 1);
            }
            windNode.buffer = windBuffer;
            windNode.loop = true;

            var windFilter = audioCtx.createBiquadFilter();
            windFilter.type = 'bandpass';
            windFilter.frequency.value = 800;
            windFilter.Q.value = 0.5;

            windGain = audioCtx.createGain();
            windGain.gain.value = 0;
            windNode.connect(windFilter);
            windFilter.connect(windGain);
            windGain.connect(masterGain);
            windNode.start();

            // Cabin ambience (very low noise)
            cabinNode = audioCtx.createBufferSource();
            var cabinBuffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            var cabinData = cabinBuffer.getChannelData(0);
            var prev = 0;
            for (var k = 0; k < bufferSize; k++) {
                prev = prev * 0.99 + (Math.random() * 2 - 1) * 0.01;
                cabinData[k] = prev * 3;
            }
            cabinNode.buffer = cabinBuffer;
            cabinNode.loop = true;

            cabinGain = audioCtx.createGain();
            cabinGain.gain.value = 0;
            cabinNode.connect(cabinGain);
            cabinGain.connect(masterGain);
            cabinNode.start();

        } catch(e) { /* Audio not available */ }
    }

    function setEngineVolume(v) {
        if (engineGain) engineGain.gain.linearRampToValueAtTime(v, audioCtx.currentTime + 0.5);
    }
    function setWindVolume(v) {
        if (windGain) windGain.gain.linearRampToValueAtTime(v, audioCtx.currentTime + 0.5);
    }
    function setCabinVolume(v) {
        if (cabinGain) cabinGain.gain.linearRampToValueAtTime(v, audioCtx.currentTime + 0.3);
    }

    function playThunder() {
        if (!audioCtx) return;
        var osc = audioCtx.createOscillator();
        var g = audioCtx.createGain();
        var filter = audioCtx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 200;

        var buf = audioCtx.createBuffer(1, audioCtx.sampleRate * 2, audioCtx.sampleRate);
        var d = buf.getChannelData(0);
        for (var i = 0; i < d.length; i++) d[i] = (Math.random() * 2 - 1);
        var noise = audioCtx.createBufferSource();
        noise.buffer = buf;

        g.gain.setValueAtTime(0.8, audioCtx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 2.5);

        noise.connect(filter);
        filter.connect(g);
        g.connect(masterGain);
        noise.start();
        noise.stop(audioCtx.currentTime + 2.5);
    }

    function playDing() {
        if (!audioCtx) return;
        var osc = audioCtx.createOscillator();
        var g = audioCtx.createGain();
        osc.type = 'sine';
        osc.frequency.value = 1200;
        g.gain.setValueAtTime(0.15, audioCtx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.8);
        osc.connect(g);
        g.connect(masterGain);
        osc.start();
        osc.stop(audioCtx.currentTime + 0.8);
        // Second tone
        setTimeout(function() {
            if (!audioCtx) return;
            var o2 = audioCtx.createOscillator();
            var g2 = audioCtx.createGain();
            o2.type = 'sine'; o2.frequency.value = 900;
            g2.gain.setValueAtTime(0.12, audioCtx.currentTime);
            g2.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.6);
            o2.connect(g2); g2.connect(masterGain);
            o2.start(); o2.stop(audioCtx.currentTime + 0.6);
        }, 300);
    }

    function playAlarm() {
        if (!audioCtx) return;
        var osc = audioCtx.createOscillator();
        var g = audioCtx.createGain();
        osc.type = 'square';
        osc.frequency.setValueAtTime(600, audioCtx.currentTime);
        g.gain.setValueAtTime(0.2, audioCtx.currentTime);
        for (var i = 0; i < 10; i++) {
            osc.frequency.setValueAtTime(600, audioCtx.currentTime + i * 0.4);
            osc.frequency.setValueAtTime(400, audioCtx.currentTime + i * 0.4 + 0.2);
        }
        g.gain.setValueAtTime(0.2, audioCtx.currentTime + 3.8);
        g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 4);
        osc.connect(g); g.connect(masterGain);
        osc.start(); osc.stop(audioCtx.currentTime + 4);
    }

    function playImpact() {
        if (!audioCtx) return;
        var buf = audioCtx.createBuffer(1, audioCtx.sampleRate, audioCtx.sampleRate);
        var d = buf.getChannelData(0);
        for (var i = 0; i < d.length; i++) d[i] = (Math.random() * 2 - 1) * Math.exp(-i / (audioCtx.sampleRate * 0.15));
        var src = audioCtx.createBufferSource();
        src.buffer = buf;
        var filter = audioCtx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 300;
        var g = audioCtx.createGain();
        g.gain.value = 1.0;
        src.connect(filter); filter.connect(g); g.connect(masterGain);
        src.start();
    }

    // ═══════════════════════════════════════════════════
    //  MATERIALS
    // ═══════════════════════════════════════════════════
    var MAT = {
        concrete: new THREE.MeshStandardMaterial({ color: 0x999999, roughness: 0.9 }),
        asphalt: new THREE.MeshStandardMaterial({ color: 0x2a2a2a, roughness: 0.95 }),
        grass: new THREE.MeshStandardMaterial({ color: 0x3d7a1a, roughness: 0.95 }),
        glass: new THREE.MeshPhysicalMaterial({ color: 0x88ccff, transparent: true, opacity: 0.3, roughness: 0.05, metalness: 0.1, transmission: 0.6 }),
        metal: new THREE.MeshStandardMaterial({ color: 0xcccccc, roughness: 0.25, metalness: 0.85 }),
        white: new THREE.MeshStandardMaterial({ color: 0xf0f0f0, roughness: 0.6 }),
        blue: new THREE.MeshStandardMaterial({ color: 0x1a4b8c, roughness: 0.5 }),
        red: new THREE.MeshStandardMaterial({ color: 0xcc2222, roughness: 0.5 }),
        darkRed: new THREE.MeshStandardMaterial({ color: 0x661111, roughness: 0.5 }),
        seat: new THREE.MeshStandardMaterial({ color: 0x1e3a6e, roughness: 0.75 }),
        seatBack: new THREE.MeshStandardMaterial({ color: 0x152a52, roughness: 0.8 }),
        carpet: new THREE.MeshStandardMaterial({ color: 0x2a3040, roughness: 0.95 }),
        plastic: new THREE.MeshStandardMaterial({ color: 0xe0d8cc, roughness: 0.7 }),
        darkPlastic: new THREE.MeshStandardMaterial({ color: 0x3a3a3a, roughness: 0.8 }),
        windowInner: new THREE.MeshBasicMaterial({ color: 0x88ccff, side: THREE.DoubleSide }),
        terminalFloor: new THREE.MeshStandardMaterial({ color: 0xccbbaa, roughness: 0.5 }),
        sky: new THREE.MeshBasicMaterial({ color: 0x87CEEB }),
        emergencyGreen: new THREE.MeshBasicMaterial({ color: 0x00ff44 }),
        lightEmit: new THREE.MeshBasicMaterial({ color: 0xffffee }),
        lightEmitWarm: new THREE.MeshBasicMaterial({ color: 0xffeecc }),
        lightEmitDim: new THREE.MeshBasicMaterial({ color: 0x443322 }),
        stormCloud: new THREE.MeshLambertMaterial({ color: 0x333344, transparent: true, opacity: 0.85 }),
        darkCloud: new THREE.MeshLambertMaterial({ color: 0x1a1a22, transparent: true, opacity: 0.9 }),
        yellow: new THREE.MeshStandardMaterial({ color: 0xf0c000, roughness: 0.6 }),
        yellowLine: new THREE.MeshBasicMaterial({ color: 0xf0c000 }),
        orange: new THREE.MeshBasicMaterial({ color: 0xff6600 }),
        navRed: new THREE.MeshBasicMaterial({ color: 0xff0000 }),
        navGreen: new THREE.MeshBasicMaterial({ color: 0x00ff00 }),
        navWhite: new THREE.MeshBasicMaterial({ color: 0xffffff }),
        stainless: new THREE.MeshStandardMaterial({ color: 0xc8c8c8, roughness: 0.2, metalness: 0.9 }),
        fabric: new THREE.MeshStandardMaterial({ color: 0x1a3560, roughness: 0.85 }),
        seatbeltOrange: new THREE.MeshStandardMaterial({ color: 0xd4760a, roughness: 0.7 }),
        lavDoor: new THREE.MeshStandardMaterial({ color: 0x778899, roughness: 0.5, metalness: 0.3 }),
        trayTable: new THREE.MeshStandardMaterial({ color: 0xd0ccc0, roughness: 0.5 }),
        signPanel: new THREE.MeshBasicMaterial({ color: 0x004422 }),
        vehicleBody: new THREE.MeshStandardMaterial({ color: 0xe8d540, roughness: 0.6 }),
        vehicleWheel: new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.9 }),
        windsock: new THREE.MeshStandardMaterial({ color: 0xff6600, roughness: 0.8, side: THREE.DoubleSide }),
        windsockWhite: new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.8, side: THREE.DoubleSide }),
        doorOutline: new THREE.MeshBasicMaterial({ color: 0x444444 }),
        panelLine: new THREE.MeshBasicMaterial({ color: 0xcccccc }),
        fuselageAccent: new THREE.MeshStandardMaterial({ color: 0xcc1e2e, roughness: 0.4 })
    };

    // ═══════════════════════════════════════════════════
    //  SCENE GROUPS
    // ═══════════════════════════════════════════════════
    var airportGroup = new THREE.Group();
    var planeExtGroup = new THREE.Group();
    var cabinGroup = new THREE.Group();
    var cloudGroup = new THREE.Group();
    var stormCloudGroup = new THREE.Group();
    var lightningGroup = new THREE.Group();
    var debrisGroup = new THREE.Group();
    var survivalGroup = new THREE.Group();
    scene.add(airportGroup, planeExtGroup, cabinGroup, cloudGroup, stormCloudGroup, lightningGroup, debrisGroup, survivalGroup);

    // Cabin light refs
    var cabinLights = [];
    var cabinLightMeshes = [];
    var emergencyLightMeshes = [];
    var engineFans = [];
    var seatMarker = null; // glowing marker above assigned seat

    // ═══════════════════════════════════════════════════
    //  LIGHTING
    // ═══════════════════════════════════════════════════
    var ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
    scene.add(ambientLight);

    var sunLight = new THREE.DirectionalLight(0xfffff0, 1.2);
    sunLight.position.set(80, 120, 60);
    sunLight.castShadow = true;
    sunLight.shadow.mapSize.width = 2048;
    sunLight.shadow.mapSize.height = 2048;
    sunLight.shadow.camera.near = 0.5;
    sunLight.shadow.camera.far = 500;
    sunLight.shadow.camera.left = -100;
    sunLight.shadow.camera.right = 100;
    sunLight.shadow.camera.top = 100;
    sunLight.shadow.camera.bottom = -100;
    scene.add(sunLight);

    var hemiLight = new THREE.HemisphereLight(0x87ceeb, 0x3d5c2d, 0.4);
    scene.add(hemiLight);

    // ═══════════════════════════════════════════════════
    //  AIRPORT CONSTRUCTION
    // ═══════════════════════════════════════════════════
    function buildAirport() {
        // Ground plane
        var groundGeo = new THREE.PlaneGeometry(1000, 1000);
        var ground = new THREE.Mesh(groundGeo, MAT.grass);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        airportGroup.add(ground);

        // Runway (further out at x=45)
        var rwGeo = new THREE.PlaneGeometry(24, 400);
        var runway = new THREE.Mesh(rwGeo, MAT.asphalt);
        runway.rotation.x = -Math.PI / 2;
        runway.position.set(45, 0.02, 0);
        runway.receiveShadow = true;
        airportGroup.add(runway);

        // Runway center line
        var lineM = new THREE.MeshBasicMaterial({ color: 0xffffff });
        for (var i = -180; i < 180; i += 12) {
            var mark = new THREE.Mesh(new THREE.PlaneGeometry(0.6, 5), lineM);
            mark.rotation.x = -Math.PI / 2;
            mark.position.set(45, 0.03, i);
            airportGroup.add(mark);
        }

        // Runway edge lines
        for (var side = -1; side <= 1; side += 2) {
            var edgeLine = new THREE.Mesh(new THREE.PlaneGeometry(0.4, 380), lineM);
            edgeLine.rotation.x = -Math.PI / 2;
            edgeLine.position.set(45 + side * 11.5, 0.03, 0);
            airportGroup.add(edgeLine);
        }

        // Taxiway (between terminal and runway)
        var twGeo = new THREE.PlaneGeometry(12, 80);
        var taxiway = new THREE.Mesh(twGeo, MAT.asphalt);
        taxiway.rotation.x = -Math.PI / 2;
        taxiway.position.set(35, 0.02, 0);
        airportGroup.add(taxiway);

        // ════════════════════════════════════════
        //  TERMINAL BUILDING & INTERIOR (2-story)
        // ════════════════════════════════════════
        // Large terminal corridor along Z axis, 2 floors
        // Ground floor: y=0 to y=4 (arrivals, services — not detailed)
        // 2nd floor: y=4 to y=8.5 (departure gates — where player is)
        // Window wall on +X side facing the planes
        // TI = terminal interior bounds (2nd floor only)
        var TI = { x1: -20, x2: 2, z1: -50, z2: 50, floorY: 4.0, ceilY: 8.5 };
        var TW = TI.x2 - TI.x1; // 22m wide
        var TL = TI.z2 - TI.z1; // 100m long
        var TH = TI.ceilY - TI.floorY; // 4.5m tall (2nd floor)
        var TCX = (TI.x1 + TI.x2) / 2; // center X = -9
        var TCZ = (TI.z1 + TI.z2) / 2; // center Z = 0

        // ── Terminal exterior shell ──
        var termExtMat = new THREE.MeshStandardMaterial({ color: 0xcccccc, roughness: 0.7 });
        // Roof
        var termRoof = new THREE.Mesh(new THREE.BoxGeometry(TW + 2, 0.4, TL + 2), termExtMat);
        termRoof.position.set(TCX, TI.ceilY + 0.2, TCZ);
        termRoof.castShadow = true;
        airportGroup.add(termRoof);
        // Back exterior wall (spans full height, ground to roof)
        var termBackExt = new THREE.Mesh(new THREE.BoxGeometry(0.3, TI.ceilY + 0.4, TL + 2), termExtMat);
        termBackExt.position.set(TI.x1 - 0.85, (TI.ceilY + 0.4) / 2, TCZ);
        termBackExt.castShadow = true;
        airportGroup.add(termBackExt);
        // Side exterior walls (end caps, full height)
        for (var ew = 0; ew < 2; ew++) {
            var endExtWall = new THREE.Mesh(new THREE.BoxGeometry(TW + 2, TI.ceilY + 0.4, 0.3), termExtMat);
            endExtWall.position.set(TCX, (TI.ceilY + 0.4) / 2, ew === 0 ? TI.z1 - 0.5 : TI.z2 + 0.5);
            endExtWall.castShadow = true;
            airportGroup.add(endExtWall);
        }

        // ── Ground floor exterior (visible structure below 2nd floor) ──
        var groundFloorMat = new THREE.MeshStandardMaterial({ color: 0xbbbbbb, roughness: 0.7 });
        // Ground floor facade (concrete/glass lower portion on +X side)
        var gfFacade = new THREE.Mesh(new THREE.BoxGeometry(0.2, 4, TL), groundFloorMat);
        gfFacade.position.set(TI.x2 + 0.1, 2, TCZ);
        airportGroup.add(gfFacade);
        // Ground floor windows (decorative, along +X side)
        for (var gfw = TI.z1 + 2; gfw < TI.z2; gfw += 5) {
            var gfWin = new THREE.Mesh(new THREE.PlaneGeometry(3, 2.5),
                new THREE.MeshPhysicalMaterial({ color: 0x88aacc, transparent: true, opacity: 0.3, roughness: 0.1 }));
            gfWin.position.set(TI.x2 + 0.22, 2, gfw);
            gfWin.rotation.y = -Math.PI / 2;
            airportGroup.add(gfWin);
        }

        // ── Interior floor (polished tile) ──
        var tFloorMat = new THREE.MeshStandardMaterial({ color: 0xd4c8b0, roughness: 0.3, metalness: 0.1 });
        var tFloor = new THREE.Mesh(new THREE.PlaneGeometry(TW, TL), tFloorMat);
        tFloor.rotation.x = -Math.PI / 2;
        tFloor.position.set(TCX, TI.floorY, TCZ);
        tFloor.receiveShadow = true;
        airportGroup.add(tFloor);

        // ── Interior ceiling (offset slightly below roof to prevent z-fighting) ──
        var tCeilMat = new THREE.MeshStandardMaterial({ color: 0xeeeeee, roughness: 0.7 });
        var tCeil = new THREE.Mesh(new THREE.PlaneGeometry(TW, TL), tCeilMat);
        tCeil.rotation.x = Math.PI / 2;
        tCeil.position.set(TCX, TI.ceilY - 0.15, TCZ);
        airportGroup.add(tCeil);

        // ── Back wall interior (-X side, solid) ──
        var wallMat = new THREE.MeshStandardMaterial({ color: 0xe8e0d4, roughness: 0.6 });
        var tBackWall = new THREE.Mesh(new THREE.PlaneGeometry(TL, TH), wallMat);
        tBackWall.position.set(TI.x1, TI.floorY + TH / 2, TCZ);
        tBackWall.rotation.y = Math.PI / 2;
        airportGroup.add(tBackWall);

        // ── End walls (z = -30 and z = +30) ──
        var tEndWall1 = new THREE.Mesh(new THREE.PlaneGeometry(TW, TH), wallMat);
        tEndWall1.position.set(TCX, TI.floorY + TH / 2, TI.z1);
        airportGroup.add(tEndWall1);
        var tEndWall2 = new THREE.Mesh(new THREE.PlaneGeometry(TW, TH), wallMat);
        tEndWall2.position.set(TCX, TI.floorY + TH / 2, TI.z2);
        tEndWall2.rotation.y = Math.PI;
        airportGroup.add(tEndWall2);

        // ── Gate positions (defined early — needed for window wall openings) ──
        var gatePositions = [
            { name: '83', z: -30, hasPlane: true },
            { name: '84', z: 5, hasPlane: false },
            { name: '85', z: 35, hasPlane: true }
        ];

        // ── Window wall (+X side) — floor-to-ceiling glass with openings for jet bridges ──
        var glassMat = new THREE.MeshPhysicalMaterial({ color: 0xaaddff, transparent: true, opacity: 0.15, roughness: 0.02, transmission: 0.8 });
        // Collect gate Z positions for bridge openings (3.5m wide opening each)
        var bridgeOpeningHalfW = 1.8;
        function isInBridgeOpening(z) {
            for (var go = 0; go < gatePositions.length; go++) {
                if (Math.abs(z - gatePositions[go].z) < bridgeOpeningHalfW) return true;
            }
            return false;
        }
        // Glass panels (every 3m along Z, skip where bridges connect)
        for (var gz = TI.z1; gz < TI.z2; gz += 3) {
            var panelCenter = gz + 1.5;
            if (isInBridgeOpening(panelCenter)) continue; // skip — bridge opening
            var glassPanel = new THREE.Mesh(new THREE.PlaneGeometry(2.8, TH), glassMat);
            glassPanel.position.set(TI.x2, TI.floorY + TH / 2, panelCenter);
            glassPanel.rotation.y = -Math.PI / 2;
            airportGroup.add(glassPanel);
        }
        // Vertical mullions (skip in bridge openings)
        for (var mz = TI.z1; mz <= TI.z2; mz += 3) {
            if (isInBridgeOpening(mz)) continue;
            var mullion = new THREE.Mesh(new THREE.BoxGeometry(0.12, TH, 0.08), MAT.metal);
            mullion.position.set(TI.x2 + 0.01, TI.floorY + TH / 2, mz);
            airportGroup.add(mullion);
        }
        // Horizontal mullion (skip in bridge openings — split into segments)
        for (var hmz = TI.z1; hmz < TI.z2; hmz += 3) {
            var hmCenter = hmz + 1.5;
            if (isInBridgeOpening(hmCenter)) continue;
            var hMullSeg = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.06, 2.8), MAT.metal);
            hMullSeg.position.set(TI.x2 + 0.01, TI.floorY + TH * 0.55, hmCenter);
            airportGroup.add(hMullSeg);
        }

        // ── Ceiling lights (fluorescent panels, along corridor) ──
        var ceilLightMat = new THREE.MeshBasicMaterial({ color: 0xffffee });
        for (var clz = TI.z1 + 3; clz < TI.z2; clz += 6) {
            var cLight = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.04, 3), ceilLightMat);
            cLight.position.set(TCX, TI.ceilY - 0.03, clz);
            airportGroup.add(cLight);
            // Actual point light every other panel
            if (clz % 12 < 6) {
                var pLight = new THREE.PointLight(0xffffee, 0.4, 12);
                pLight.position.set(TCX, TI.ceilY - 0.2, clz);
                airportGroup.add(pLight);
            }
        }

        // ── Support columns (along corridor center) ──
        for (var colZ = TI.z1 + 5; colZ < TI.z2; colZ += 15) {
            var col = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, TH, 8), MAT.concrete);
            col.position.set(TCX, TI.floorY + TH / 2, colZ);
            airportGroup.add(col);
        }

        // ════════════════════════════════════════
        //  GATES AND JET BRIDGES
        // ════════════════════════════════════════

        // Gate desk, signs, and jet bridges for each gate
        var deskMat = new THREE.MeshStandardMaterial({ color: 0x3a3a4a, roughness: 0.5 });
        var bridgeMat = new THREE.MeshStandardMaterial({ color: 0xbbbbbb, roughness: 0.5, metalness: 0.3 });
        var accordionMat = new THREE.MeshStandardMaterial({ color: 0x555555, roughness: 0.8 });

        for (var gi = 0; gi < gatePositions.length; gi++) {
            var gate = gatePositions[gi];

            // ── Gate sign (hanging from ceiling, with gate number) ──
            var signBg = new THREE.Mesh(new THREE.BoxGeometry(2.5, 0.8, 0.1), MAT.signPanel);
            signBg.position.set(TCX + 2, TI.ceilY - 0.5, gate.z);
            airportGroup.add(signBg);
            // Sign face with gate number text (canvas texture)
            var signCanvas = document.createElement('canvas');
            signCanvas.width = 512; signCanvas.height = 128;
            var sCtx = signCanvas.getContext('2d');
            sCtx.fillStyle = '#ffffff';
            sCtx.fillRect(0, 0, 512, 128);
            sCtx.fillStyle = '#003322';
            sCtx.font = 'bold 72px Arial, sans-serif';
            sCtx.textAlign = 'center';
            sCtx.textBaseline = 'middle';
            sCtx.fillText('Gate ' + gate.name, 256, 64);
            var signTex = new THREE.CanvasTexture(signCanvas);
            var signFace = new THREE.Mesh(new THREE.PlaneGeometry(2.3, 0.6),
                new THREE.MeshBasicMaterial({ map: signTex }));
            signFace.position.set(TCX + 2, TI.ceilY - 0.5, gate.z + 0.06);
            airportGroup.add(signFace);
            // Back face (visible from other side)
            var signFaceBack = new THREE.Mesh(new THREE.PlaneGeometry(2.3, 0.6),
                new THREE.MeshBasicMaterial({ map: signTex }));
            signFaceBack.position.set(TCX + 2, TI.ceilY - 0.5, gate.z - 0.06);
            signFaceBack.rotation.y = Math.PI;
            airportGroup.add(signFaceBack);

            // ── Gate desk / counter ──
            var gDesk = new THREE.Group();
            var dTop = new THREE.Mesh(new THREE.BoxGeometry(3, 0.08, 1.2), deskMat);
            dTop.position.y = 1.1;
            gDesk.add(dTop);
            var dFront = new THREE.Mesh(new THREE.BoxGeometry(3, 1.1, 0.06), deskMat);
            dFront.position.set(0, 0.55, -0.57);
            gDesk.add(dFront);
            // Monitor on desk
            var gMon = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.35, 0.03), MAT.darkPlastic);
            gMon.position.set(0, 1.5, -0.2);
            gDesk.add(gMon);
            var gScr = new THREE.Mesh(new THREE.PlaneGeometry(0.45, 0.3),
                new THREE.MeshBasicMaterial({ color: 0x3388cc }));
            gScr.position.set(0, 1.5, -0.216);
            gDesk.add(gScr);
            // Position desk next to gate, rotated parallel to window wall so it doesn't block entry
            gDesk.rotation.y = Math.PI / 2;
            gDesk.position.set(TI.x2 - 1.2, TI.floorY, gate.z - 3.5);
            airportGroup.add(gDesk);

            // ── Jet bridge (connects 2nd floor to plane) ──
            // Bridge starts flush with terminal window wall (x=TI.x2)
            // and extends out to the plane's forward door
            var bridgeLen = 13;
            var bridgeH = 3.0;
            var bridgeW = 3.2;
            var bridgeFloorY = TI.floorY; // y=4, same as terminal floor
            var bridgeCenterY = bridgeFloorY + bridgeH / 2;
            var bridgeStartX = TI.x2; // flush with terminal wall
            var bridgeEndX = bridgeStartX + bridgeLen;
            var bridgeCenterX = (bridgeStartX + bridgeEndX) / 2;
            var halfBW = bridgeW / 2;
            var isPlayerGate = (gate.name === '84');

            // Exterior shell — built from individual faces (not a box)
            // so the terminal-side face is open for walking through
            var bExtMat = new THREE.MeshStandardMaterial({ color: 0xaaaaaa, roughness: 0.5, metalness: 0.3 });
            // Top face
            var bTop = new THREE.Mesh(new THREE.PlaneGeometry(bridgeLen, bridgeW), bExtMat);
            bTop.rotation.x = -Math.PI / 2;
            bTop.position.set(bridgeCenterX, bridgeFloorY + bridgeH, gate.z);
            airportGroup.add(bTop);
            // Bottom face
            var bBot = new THREE.Mesh(new THREE.PlaneGeometry(bridgeLen, bridgeW), bExtMat);
            bBot.rotation.x = Math.PI / 2;
            bBot.position.set(bridgeCenterX, bridgeFloorY, gate.z);
            airportGroup.add(bBot);
            // Side faces (exterior, both Z sides)
            for (var bSide = -1; bSide <= 1; bSide += 2) {
                var bSideFace = new THREE.Mesh(new THREE.PlaneGeometry(bridgeLen, bridgeH), bExtMat);
                bSideFace.position.set(bridgeCenterX, bridgeCenterY, gate.z + bSide * halfBW);
                bSideFace.rotation.y = bSide > 0 ? 0 : Math.PI;
                airportGroup.add(bSideFace);
            }
            // Far end face (plane side — closed for non-player gates, open for A7)
            if (!isPlayerGate) {
                var bEndFace = new THREE.Mesh(new THREE.PlaneGeometry(bridgeW, bridgeH), bExtMat);
                bEndFace.position.set(bridgeEndX, bridgeCenterY, gate.z);
                bEndFace.rotation.y = -Math.PI / 2;
                airportGroup.add(bEndFace);
            }
            // Terminal-side face is OPEN (no face) so player can walk in

            // Interior floor (walkable surface)
            var bIntFloorMat = new THREE.MeshStandardMaterial({ color: 0x666666, roughness: 0.8 });
            var bIntFloor = new THREE.Mesh(new THREE.PlaneGeometry(bridgeLen, bridgeW - 0.2), bIntFloorMat);
            bIntFloor.rotation.x = -Math.PI / 2;
            bIntFloor.position.set(bridgeCenterX, bridgeFloorY + 0.05, gate.z);
            airportGroup.add(bIntFloor);
            // Interior ceiling
            var bIntCeil = new THREE.Mesh(new THREE.PlaneGeometry(bridgeLen, bridgeW - 0.2), tCeilMat);
            bIntCeil.rotation.x = Math.PI / 2;
            bIntCeil.position.set(bridgeCenterX, bridgeFloorY + bridgeH - 0.05, gate.z);
            airportGroup.add(bIntCeil);
            // Interior walls (both sides, visible from inside)
            for (var bws = -1; bws <= 1; bws += 2) {
                var bIntWall = new THREE.Mesh(new THREE.PlaneGeometry(bridgeLen, bridgeH - 0.2), wallMat);
                bIntWall.position.set(bridgeCenterX, bridgeCenterY, gate.z + bws * (halfBW - 0.05));
                bIntWall.rotation.y = bws > 0 ? Math.PI : 0;
                airportGroup.add(bIntWall);
            }
            // Interior windows (glass panels on both sides)
            for (var bwSide = -1; bwSide <= 1; bwSide += 2) {
                for (var bwi = 0; bwi < 3; bwi++) {
                    var bWin = new THREE.Mesh(new THREE.PlaneGeometry(2.5, 1.2), glassMat);
                    bWin.position.set(bridgeStartX + 2.5 + bwi * 4, bridgeCenterY + 0.3, gate.z + bwSide * (halfBW - 0.03));
                    bWin.rotation.y = bwSide > 0 ? Math.PI : 0;
                    airportGroup.add(bWin);
                }
            }

            // Support pillars (from ground to bridge underside)
            for (var bp = 0; bp < 2; bp++) {
                var bPillar = new THREE.Mesh(new THREE.CylinderGeometry(0.25, 0.35, bridgeFloorY, 8), MAT.concrete);
                bPillar.position.set(bridgeStartX + 3 + bp * 8, bridgeFloorY / 2, gate.z);
                airportGroup.add(bPillar);
            }
            // Accordion connector at plane end (open-ended for player gate)
            if (isPlayerGate) {
                // Open accordion — just top, bottom, sides (no front/back faces)
                var accLen = 2.0;
                var accCX = bridgeEndX + accLen / 2;
                var accTop = new THREE.Mesh(new THREE.PlaneGeometry(accLen, bridgeW + 0.4), accordionMat);
                accTop.rotation.x = -Math.PI / 2;
                accTop.position.set(accCX, bridgeFloorY + bridgeH, gate.z);
                airportGroup.add(accTop);
                var accBot = new THREE.Mesh(new THREE.PlaneGeometry(accLen, bridgeW + 0.4), accordionMat);
                accBot.rotation.x = Math.PI / 2;
                accBot.position.set(accCX, bridgeFloorY, gate.z);
                airportGroup.add(accBot);
                for (var accS = -1; accS <= 1; accS += 2) {
                    var accSide = new THREE.Mesh(new THREE.PlaneGeometry(accLen, bridgeH), accordionMat);
                    accSide.position.set(accCX, bridgeCenterY, gate.z + accS * (bridgeW / 2 + 0.2));
                    accSide.rotation.y = accS > 0 ? 0 : Math.PI;
                    airportGroup.add(accSide);
                }
            } else {
                var bAccordion = new THREE.Mesh(new THREE.BoxGeometry(2.0, bridgeH, bridgeW + 0.4), accordionMat);
                bAccordion.position.set(bridgeEndX + 1.0, bridgeCenterY, gate.z);
                airportGroup.add(bAccordion);
            }

            // ── Parked mini-plane at non-player gates ──
            if (gate.hasPlane) {
                var miniP = buildMiniPlane();
                miniP.position.set(20, 2, gate.z);
                miniP.scale.set(0.8, 0.8, 0.8);
                airportGroup.add(miniP);
            }
        }

        // ── Seating rows in gate areas ──
        var chairMat = new THREE.MeshStandardMaterial({ color: 0x2244aa, roughness: 0.7 });
        var chairLegMat = new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 0.3, metalness: 0.7 });
        function makeChairRow(rz, count, facingDir) {
            // facingDir: 1 = facing +X (toward windows), -1 = facing -X (toward back wall)
            var rowGroup = new THREE.Group();
            var totalLen = count * 0.55;
            // Beam
            var beam = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.04, totalLen), chairLegMat);
            beam.position.y = 0.42;
            rowGroup.add(beam);
            for (var c = 0; c < count; c++) {
                var cz = (c - (count - 1) / 2) * 0.55;
                // Seat
                var cSeat = new THREE.Mesh(new THREE.BoxGeometry(0.40, 0.04, 0.45), chairMat);
                cSeat.position.set(0, 0.44, cz);
                rowGroup.add(cSeat);
                // Back rest
                var cBack = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.35, 0.45), chairMat);
                cBack.position.set(facingDir * -0.18, 0.64, cz);
                rowGroup.add(cBack);
                // Legs
                for (var leg = -1; leg <= 1; leg += 2) {
                    var cLeg = new THREE.Mesh(new THREE.CylinderGeometry(0.015, 0.015, 0.42, 6), chairLegMat);
                    cLeg.position.set(0, 0.21, cz + leg * 0.2);
                    rowGroup.add(cLeg);
                }
                // Armrest
                var armR = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.03, 0.04), chairLegMat);
                armR.position.set(0, 0.5, cz + 0.25);
                rowGroup.add(armR);
            }
            return rowGroup;
        }

        // Seating near each gate (rows along the corridor, facing windows)
        for (var gi2 = 0; gi2 < gatePositions.length; gi2++) {
            var gZ = gatePositions[gi2].z;
            // Two rows facing windows (+X), one row facing back wall
            var row1 = makeChairRow(gZ - 5, 6, 1);
            row1.position.set(TCX + 2, TI.floorY, gZ - 5);
            airportGroup.add(row1);
            var row2 = makeChairRow(gZ + 5, 6, 1);
            row2.position.set(TCX + 2, TI.floorY, gZ + 5);
            airportGroup.add(row2);
            var row3 = makeChairRow(gZ, 6, -1);
            row3.position.set(TCX - 2, TI.floorY, gZ);
            airportGroup.add(row3);
        }

        // ── Departure board (on back wall near gate A7) ──
        var boardBg = new THREE.Mesh(new THREE.BoxGeometry(0.15, 2, 5), MAT.darkPlastic);
        boardBg.position.set(TI.x1 + 0.1, 3.5, 5);
        airportGroup.add(boardBg);
        var boardScreen = new THREE.Mesh(new THREE.PlaneGeometry(4.6, 1.6),
            new THREE.MeshBasicMaterial({ color: 0x001133 }));
        boardScreen.position.set(TI.x1 + 0.18, 3.5, 5);
        boardScreen.rotation.y = Math.PI / 2;
        airportGroup.add(boardScreen);
        // Flight info rows
        for (var fi = 0; fi < 5; fi++) {
            var rowBar = new THREE.Mesh(new THREE.PlaneGeometry(4.0, 0.2),
                new THREE.MeshBasicMaterial({ color: fi % 2 === 0 ? 0x002244 : 0x003355 }));
            rowBar.position.set(TI.x1 + 0.19, 4.0 - fi * 0.35, 5);
            rowBar.rotation.y = Math.PI / 2;
            airportGroup.add(rowBar);
        }

        // ── Trash cans (along corridor) ──
        for (var tc = 0; tc < 4; tc++) {
            var trashCan = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 0.7, 8), MAT.darkPlastic);
            trashCan.position.set(TCX, TI.floorY + 0.35, TI.z1 + 10 + tc * 18);
            airportGroup.add(trashCan);
        }

        // ── Potted plants ──
        for (var pp = 0; pp < 3; pp++) {
            var potGroup = new THREE.Group();
            var pot = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.25, 0.5, 8),
                new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.9 }));
            pot.position.y = 0.25;
            potGroup.add(pot);
            var plant = new THREE.Mesh(new THREE.SphereGeometry(0.5, 6, 6),
                new THREE.MeshStandardMaterial({ color: 0x228822, roughness: 0.9 }));
            plant.position.y = 0.75;
            potGroup.add(plant);
            potGroup.position.set(TI.x1 + 1, TI.floorY, TI.z1 + 8 + pp * 22);
            airportGroup.add(potGroup);
        }

        // ── Vending machines (back wall) ──
        var vendMat = new THREE.MeshStandardMaterial({ color: 0xcc2222, roughness: 0.5 });
        var vend1 = new THREE.Mesh(new THREE.BoxGeometry(0.7, 1.8, 1.0), vendMat);
        vend1.position.set(TI.x1 + 0.45, TI.floorY + 0.9, -15);
        airportGroup.add(vend1);
        var vendFace = new THREE.Mesh(new THREE.PlaneGeometry(0.8, 1.2),
            new THREE.MeshBasicMaterial({ color: 0xffeecc }));
        vendFace.position.set(TI.x1 + 0.81, TI.floorY + 1.1, -15);
        vendFace.rotation.y = Math.PI / 2;
        airportGroup.add(vendFace);
        var vend2 = new THREE.Mesh(new THREE.BoxGeometry(0.7, 1.8, 1.0),
            new THREE.MeshStandardMaterial({ color: 0x2244cc, roughness: 0.5 }));
        vend2.position.set(TI.x1 + 0.45, TI.floorY + 0.9, -13.5);
        airportGroup.add(vend2);

        // ── Coffee kiosk (near gate A7) ──
        var kioskMat = new THREE.MeshStandardMaterial({ color: 0x6b3a2a, roughness: 0.7 });
        var kioskGroup = new THREE.Group();
        // Counter
        var kioskCounter = new THREE.Mesh(new THREE.BoxGeometry(3, 1.1, 1.5), kioskMat);
        kioskCounter.position.y = 0.55;
        kioskGroup.add(kioskCounter);
        // Counter top
        var kioskTop = new THREE.Mesh(new THREE.BoxGeometry(3.1, 0.06, 1.6),
            new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.3 }));
        kioskTop.position.y = 1.12;
        kioskGroup.add(kioskTop);
        // Back wall / menu board
        var kioskBack = new THREE.Mesh(new THREE.BoxGeometry(3, 2.0, 0.1), MAT.darkPlastic);
        kioskBack.position.set(0, 1.5, -0.8);
        kioskGroup.add(kioskBack);
        var kioskMenu = new THREE.Mesh(new THREE.PlaneGeometry(2.6, 1.4),
            new THREE.MeshBasicMaterial({ color: 0xffeecc }));
        kioskMenu.position.set(0, 1.8, -0.74);
        kioskGroup.add(kioskMenu);
        // Coffee machine
        var coffeeMachine = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.6, 0.4), MAT.metal);
        coffeeMachine.position.set(-0.8, 1.42, -0.3);
        kioskGroup.add(coffeeMachine);
        kioskGroup.position.set(TCX - 4, TI.floorY, 15);
        airportGroup.add(kioskGroup);

        // ── Newsstand / bookshop (near gate A5) ──
        var shopGroup = new THREE.Group();
        var shopMat = new THREE.MeshStandardMaterial({ color: 0x445566, roughness: 0.5 });
        // Shelving unit
        var shelf1 = new THREE.Mesh(new THREE.BoxGeometry(0.4, 2.0, 3.0), shopMat);
        shelf1.position.set(0, 1.0, 0);
        shopGroup.add(shelf1);
        var shelf2 = new THREE.Mesh(new THREE.BoxGeometry(0.4, 2.0, 3.0), shopMat);
        shelf2.position.set(0, 1.0, 3.5);
        shopGroup.add(shelf2);
        // Colorful book/magazine spines
        var bookColors = [0xcc3333, 0x3366cc, 0x33aa33, 0xccaa33, 0xcc33aa];
        for (var bk = 0; bk < 10; bk++) {
            var bookColor = bookColors[bk % bookColors.length];
            var book = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.3, 0.22),
                new THREE.MeshStandardMaterial({ color: bookColor, roughness: 0.8 }));
            book.position.set(0.22, 1.5 + (bk % 3) * 0.35, -1.2 + bk * 0.35);
            shopGroup.add(book);
        }
        shopGroup.position.set(TI.x1 + 0.3, TI.floorY, -28);
        airportGroup.add(shopGroup);

        // ── Ceiling light strips (long LED panels) ──
        var ceilLightMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
        for (var clz = TI.z1 + 3; clz < TI.z2 - 3; clz += 8) {
            var ceilLight = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.05, 6), ceilLightMat);
            ceilLight.position.set(TCX, TI.ceilY - 0.05, clz);
            airportGroup.add(ceilLight);
            // Side lights
            for (var cls = -1; cls <= 1; cls += 2) {
                var sideLight = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.05, 4), ceilLightMat);
                sideLight.position.set(TCX + cls * 6, TI.ceilY - 0.05, clz);
                airportGroup.add(sideLight);
            }
        }

        // ── Wayfinding floor arrows (directing to gates) ──
        var arrowMat = new THREE.MeshBasicMaterial({ color: 0x2266cc, side: THREE.DoubleSide });
        for (var aw = 0; aw < 5; aw++) {
            var arrow = new THREE.Mesh(new THREE.PlaneGeometry(1.0, 0.4), arrowMat);
            arrow.rotation.x = -Math.PI / 2;
            arrow.position.set(TCX + 3, TI.floorY + 0.01, TI.z1 + 10 + aw * 20);
            airportGroup.add(arrow);
        }

        // ── Information kiosk / map stand ──
        var infoStand = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.35, 1.2, 8),
            new THREE.MeshStandardMaterial({ color: 0x2244aa, roughness: 0.4 }));
        infoStand.position.set(TCX, TI.floorY + 0.6, 0);
        airportGroup.add(infoStand);
        var infoScreen = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.4, 0.04),
            new THREE.MeshBasicMaterial({ color: 0x003366 }));
        infoScreen.position.set(TCX, TI.floorY + 1.4, 0);
        airportGroup.add(infoScreen);

        // ════════════════════════════════════════
        //  OUTSIDE AIRPORT INFRASTRUCTURE
        // ════════════════════════════════════════

        // Control tower
        var towerBase = new THREE.Mesh(new THREE.CylinderGeometry(3, 3.5, 22, 12), MAT.concrete);
        towerBase.position.set(-25, 11, -35);
        towerBase.castShadow = true;
        airportGroup.add(towerBase);
        var towerCab = new THREE.Mesh(new THREE.CylinderGeometry(5.5, 3.5, 5, 12), MAT.glass);
        towerCab.position.set(-25, 24.5, -35);
        airportGroup.add(towerCab);
        var towerRoof = new THREE.Mesh(new THREE.ConeGeometry(6.5, 2.5, 12), MAT.metal);
        towerRoof.position.set(-25, 28, -35);
        airportGroup.add(towerRoof);

        // ── Apron / ramp area (between terminal and taxiway) ──
        var apronGeo = new THREE.PlaneGeometry(30, 80);
        var apron = new THREE.Mesh(apronGeo, MAT.concrete);
        apron.rotation.x = -Math.PI / 2;
        apron.position.set(17, 0.01, 0);
        apron.receiveShadow = true;
        airportGroup.add(apron);

        // Apron guide lines
        for (var al = 0; al < gatePositions.length; al++) {
            var gLineZ = gatePositions[al].z;
            var apronLine = new THREE.Mesh(new THREE.PlaneGeometry(0.15, 20), MAT.yellowLine);
            apronLine.rotation.x = -Math.PI / 2;
            apronLine.position.set(22, 0.02, gLineZ);
            apronLine.rotation.z = Math.PI / 2;
            airportGroup.add(apronLine);
        }

        // ── Ground vehicles ──
        var fuelTruck = new THREE.Group();
        var ftBody = new THREE.Mesh(new THREE.BoxGeometry(2, 1.2, 4), MAT.vehicleBody);
        ftBody.position.y = 0.9;
        fuelTruck.add(ftBody);
        var ftTank = new THREE.Mesh(new THREE.CylinderGeometry(0.7, 0.7, 3.2, 12), MAT.stainless);
        ftTank.rotation.x = Math.PI / 2;
        ftTank.position.set(0, 1.8, 0);
        fuelTruck.add(ftTank);
        for (var fw = 0; fw < 4; fw++) {
            var fWheel = new THREE.Mesh(new THREE.CylinderGeometry(0.25, 0.25, 0.15, 8), MAT.vehicleWheel);
            fWheel.rotation.z = Math.PI / 2;
            fWheel.position.set((fw < 2 ? -1 : 1) * 1.1, 0.25, (fw % 2 === 0 ? -1.2 : 1.2));
            fuelTruck.add(fWheel);
        }
        fuelTruck.position.set(25, 0, -25);
        airportGroup.add(fuelTruck);

        // Baggage cart
        var bagTrain = new THREE.Group();
        var tugBody = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.8, 2), MAT.vehicleBody);
        tugBody.position.y = 0.6;
        bagTrain.add(tugBody);
        var tugRoof = new THREE.Mesh(new THREE.BoxGeometry(1.1, 0.05, 1.4), MAT.darkPlastic);
        tugRoof.position.set(0, 1.25, -0.2);
        bagTrain.add(tugRoof);
        for (var bc = 0; bc < 3; bc++) {
            var cart = new THREE.Mesh(new THREE.BoxGeometry(1.4, 0.4, 1.8), MAT.metal);
            cart.position.set(0, 0.35, -2.5 - bc * 2.2);
            bagTrain.add(cart);
            for (var lg = 0; lg < 3; lg++) {
                var luggage = new THREE.Mesh(
                    new THREE.BoxGeometry(0.4, 0.3, 0.5),
                    new THREE.MeshStandardMaterial({ color: new THREE.Color().setHSL(Math.random() * 0.1 + 0.55, 0.6, 0.4), roughness: 0.8 })
                );
                luggage.position.set((lg - 1) * 0.45, 0.7, -2.5 - bc * 2.2);
                luggage.rotation.y = Math.random() * 0.3;
                bagTrain.add(luggage);
            }
        }
        bagTrain.position.set(28, 0, 15);
        bagTrain.rotation.y = 0.3;
        airportGroup.add(bagTrain);

        // Pushback tug
        var pushTug = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.7, 2.5), MAT.vehicleBody);
        pushTug.position.set(25, 0.5, 10);
        airportGroup.add(pushTug);

        // ── Windsock ──
        var wsGroup = new THREE.Group();
        var wsPole = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.08, 6, 6), MAT.metal);
        wsPole.position.y = 3;
        wsGroup.add(wsPole);
        for (var ws = 0; ws < 5; ws++) {
            var sockR = 0.4 - ws * 0.06;
            var sockSeg = new THREE.Mesh(
                new THREE.CylinderGeometry(sockR - 0.06, sockR, 0.5, 8, 1, true),
                ws % 2 === 0 ? MAT.windsock : MAT.windsockWhite
            );
            sockSeg.rotation.z = -Math.PI / 2;
            sockSeg.position.set(0.3 + ws * 0.45, 5.8, 0);
            wsGroup.add(sockSeg);
        }
        wsGroup.position.set(55, 0, -40);
        airportGroup.add(wsGroup);

        // Build the player's plane at gate A7
        buildPlaneExterior();

        // Other parked planes (distant, along runway)
        for (var p = 0; p < 3; p++) {
            var distPlane = buildMiniPlane();
            distPlane.position.set(45, 2, -60 - p * 50);
            distPlane.rotation.y = Math.PI / 2;
            distPlane.scale.set(0.7, 0.7, 0.7);
            airportGroup.add(distPlane);
        }

        // Runway lights
        for (var rl = -190; rl < 190; rl += 15) {
            for (var rs = -1; rs <= 1; rs += 2) {
                var rlMesh = new THREE.Mesh(
                    new THREE.SphereGeometry(0.15, 6, 6),
                    new THREE.MeshBasicMaterial({ color: rl < -150 ? 0x00ff00 : (rl > 150 ? 0xff0000 : 0xffffff) })
                );
                rlMesh.position.set(45 + rs * 12.5, 0.15, rl);
                airportGroup.add(rlMesh);
            }
        }

        // Runway threshold markings
        var pianoKeyMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
        for (var te = 0; te < 2; te++) {
            var threshZ = te === 0 ? -188 : 188;
            var threshDir = te === 0 ? 1 : -1;
            for (var pk = 0; pk < 8; pk++) {
                var pkX = 45 + (pk - 3.5) * 2.5;
                var key = new THREE.Mesh(new THREE.PlaneGeometry(1.5, 10), pianoKeyMat);
                key.rotation.x = -Math.PI / 2;
                key.position.set(pkX, 0.035, threshZ + threshDir * 6);
                airportGroup.add(key);
            }
        }

        // Taxiway center line
        for (var ti = -35; ti < 35; ti += 4) {
            var tLine = new THREE.Mesh(new THREE.PlaneGeometry(0.3, 2.5), MAT.yellowLine);
            tLine.rotation.x = -Math.PI / 2;
            tLine.position.set(35, 0.025, ti);
            airportGroup.add(tLine);
        }

        // Perimeter fence
        for (var fp = -200; fp <= 200; fp += 15) {
            var fPost = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.04, 2, 4), MAT.metal);
            fPost.position.set(-25, 1, fp);
            airportGroup.add(fPost);
        }
        var fenceWire = new THREE.Mesh(new THREE.BoxGeometry(0.02, 0.02, 400), MAT.metal);
        fenceWire.position.set(-25, 1.8, 0);
        airportGroup.add(fenceWire);
    }

    // Plane is built along Z-axis: nose = +Z, tail = -Z, wings along X, up = Y
    // All coordinates: (x=left/right, y=up/down, z=fore/aft)
    var PLANE = { len: 38, radius: 2.8, wingSpan: 34, wingChord: 5 };

    function buildMiniPlane() {
        var g = new THREE.Group();
        // Fuselage along Z
        var body = new THREE.Mesh(new THREE.CylinderGeometry(1.2, 1.2, 16, 10), MAT.white);
        body.rotation.x = Math.PI / 2;
        g.add(body);
        // Blue cheatline
        var mStripe = new THREE.Mesh(
            new THREE.CylinderGeometry(1.22, 1.22, 16, 10, 1, false, Math.PI * 0.47, Math.PI * 0.06),
            MAT.blue
        );
        mStripe.rotation.x = Math.PI / 2;
        g.add(mStripe);
        // Nose — full sphere, back half hidden inside fuselage (same approach as large plane)
        var nose = new THREE.Mesh(new THREE.SphereGeometry(1.2, 10, 8), MAT.white);
        nose.scale.set(1, 1, 1.5);
        nose.position.z = 8;
        g.add(nose);
        // Tail cone
        var tailC = new THREE.Mesh(new THREE.CylinderGeometry(1.2, 0.2, 4, 10), MAT.white);
        tailC.rotation.x = Math.PI / 2;
        tailC.position.z = -10;
        g.add(tailC);
        // Wings
        var wing = new THREE.Mesh(new THREE.BoxGeometry(14, 0.15, 3), MAT.metal);
        wing.position.set(0, -0.3, -1);
        g.add(wing);
        // Winglets
        for (var wl = -1; wl <= 1; wl += 2) {
            var winglet = new THREE.Mesh(new THREE.BoxGeometry(0.1, 1, 0.6), MAT.white);
            winglet.position.set(wl * 7.1, 0.2, -1);
            g.add(winglet);
        }
        // Engines
        for (var eng = -1; eng <= 1; eng += 2) {
            var nacMini = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.45, 2, 8), MAT.metal);
            nacMini.rotation.x = Math.PI / 2;
            nacMini.position.set(eng * 3.5, -0.8, -0.5);
            g.add(nacMini);
        }
        // Tail fin
        var tailFin = new THREE.Mesh(new THREE.BoxGeometry(0.2, 3, 2), MAT.blue);
        tailFin.position.set(0, 2, -8);
        g.add(tailFin);
        // Horizontal stabilizers
        var hStab = new THREE.Mesh(new THREE.BoxGeometry(5, 0.1, 1.5), MAT.metal);
        hStab.position.set(0, 1, -9);
        g.add(hStab);
        return g;
    }

    // ═══════════════════════════════════════════════════
    //  PLANE EXTERIOR (Z-forward convention)
    // ═══════════════════════════════════════════════════
    function buildPlaneExterior() {
        var R = PLANE.radius;
        var halfLen = PLANE.len / 2;

        // ── Fuselage (cylinder along Z, closed with caps, higher poly for smooth belly) ──
        var fusGeo = new THREE.CylinderGeometry(R, R, PLANE.len, 48, 1, false);
        var fuselage = new THREE.Mesh(fusGeo, MAT.white);
        fuselage.rotation.x = Math.PI / 2; // align along Z
        fuselage.castShadow = true;
        planeExtGroup.add(fuselage);

        // ── Blue cheatline stripe ──
        var stripeGeo = new THREE.CylinderGeometry(R + 0.015, R + 0.015, PLANE.len, 32, 1, false, Math.PI * 0.47, Math.PI * 0.06);
        var stripe = new THREE.Mesh(stripeGeo, MAT.blue);
        stripe.rotation.x = Math.PI / 2;
        planeExtGroup.add(stripe);

        // ── Nose cone (full sphere, front half protrudes beyond fuselage) ──
        // Using a full sphere centered at the fuselage front — back half hidden inside fuselage
        var noseGeo = new THREE.SphereGeometry(R, 32, 16);
        var nose = new THREE.Mesh(noseGeo, MAT.white);
        nose.scale.set(1, 1, 2.5);      // stretch along Z for elongated airliner nose
        nose.position.z = halfLen;       // centered at fuselage front end
        planeExtGroup.add(nose);

        // ── Cockpit windows (dark patches on nose surface) ──
        // Nose is a full sphere at z=halfLen, radius R, scaled (1,1,2.5) in Z
        // Must position windows ON or slightly outside the scaled sphere surface
        var cockpitGlassMat = new THREE.MeshBasicMaterial({ color: 0x112233 });
        var cwGeo = new THREE.PlaneGeometry(0.85, 0.48);
        for (var cw = -1; cw <= 1; cw += 2) {
            var cWin = new THREE.Mesh(cwGeo, cockpitGlassMat);
            // Calculate surface position on scaled ellipsoid
            var cwX = cw * 0.6;
            var cwY = R * 0.42;
            // Solve for z on ellipsoid: x²+y²+((z-halfLen)/2.5)²=R²
            var zUnscaled = Math.sqrt(Math.max(0, R * R - cwX * cwX - cwY * cwY));
            var cwZ = halfLen + zUnscaled * 2.5 + 0.05; // +0.05 to sit just outside surface
            cWin.position.set(cwX, cwY, cwZ);
            // Angle to match nose curvature
            var nz = zUnscaled / (2.5 * 2.5); // ellipsoid normal z component
            var ny = cwY;
            var tiltX = -Math.atan2(ny, nz * 2.5) * 0.6;
            cWin.rotation.x = tiltX;
            cWin.rotation.y = cw * 0.2;
            planeExtGroup.add(cWin);
        }
        // Center windshield strip
        var cwCenter = new THREE.Mesh(new THREE.PlaneGeometry(0.3, 0.42), cockpitGlassMat);
        var czUnscaled = Math.sqrt(R * R - (R * 0.42) * (R * 0.42));
        cwCenter.position.set(0, R * 0.42, halfLen + czUnscaled * 2.5 + 0.05);
        cwCenter.rotation.x = -Math.atan2(R * 0.42, czUnscaled) * 0.5;
        planeExtGroup.add(cwCenter);

        // ── Tail cone (wide end connects to fuselage, narrows toward tail tip) ──
        // After rotation.x=PI/2: radiusTop→+Z end, radiusBottom→-Z end
        // So radiusTop=R (connects to fuselage at +Z), radiusBottom=0.3 (tail tip at -Z)
        var tailConeLen = 7;
        var tailConeGeo = new THREE.CylinderGeometry(R, 0.3, tailConeLen, 32);
        var tailCone = new THREE.Mesh(tailConeGeo, MAT.white);
        tailCone.rotation.x = Math.PI / 2;
        tailCone.position.z = -halfLen - tailConeLen / 2;
        planeExtGroup.add(tailCone);
        // APU exhaust at very tip
        var apuGeo = new THREE.CylinderGeometry(0.18, 0.3, 0.5, 12);
        var apu = new THREE.Mesh(apuGeo, MAT.darkPlastic);
        apu.rotation.x = Math.PI / 2;
        apu.position.z = -halfLen - tailConeLen;
        planeExtGroup.add(apu);

        // ── Passenger windows (both sides, with frames) ──
        var wGeo = new THREE.CircleGeometry(0.15, 10);
        var wFrameGeo = new THREE.RingGeometry(0.14, 0.19, 12);
        var wFrameMat = new THREE.MeshBasicMaterial({ color: 0x666666, side: THREE.DoubleSide });
        for (var wz = -halfLen + 4; wz <= halfLen - 3; wz += 1.2) {
            for (var wSide = -1; wSide <= 1; wSide += 2) {
                var wM = new THREE.Mesh(wGeo, MAT.glass);
                wM.position.set(wSide * (R + 0.02), R * 0.35, wz);
                wM.rotation.y = wSide > 0 ? Math.PI / 2 : -Math.PI / 2;
                planeExtGroup.add(wM);
                // Window frame ring
                var wF = new THREE.Mesh(wFrameGeo, wFrameMat);
                wF.position.set(wSide * (R + 0.025), R * 0.35, wz);
                wF.rotation.y = wSide > 0 ? Math.PI / 2 : -Math.PI / 2;
                planeExtGroup.add(wF);
            }
        }

        // ── Fuselage door outlines ──
        var doorOutGeo = new THREE.PlaneGeometry(1.0, 1.8);
        var doorEdges = new THREE.EdgesGeometry(doorOutGeo);
        var doorLineMat = new THREE.LineBasicMaterial({ color: 0x555555, linewidth: 1 });
        // Forward left door (main boarding door)
        var doorFL = new THREE.LineSegments(doorEdges, doorLineMat);
        doorFL.position.set(R + 0.03, R * 0.2, halfLen - 4);
        doorFL.rotation.y = Math.PI / 2;
        planeExtGroup.add(doorFL);
        // Forward right door
        var doorFR = new THREE.LineSegments(doorEdges.clone(), doorLineMat);
        doorFR.position.set(-R - 0.03, R * 0.2, halfLen - 4);
        doorFR.rotation.y = -Math.PI / 2;
        planeExtGroup.add(doorFR);
        // Aft left door
        var doorAL = new THREE.LineSegments(doorEdges.clone(), doorLineMat);
        doorAL.position.set(R + 0.03, R * 0.2, -halfLen + 7);
        doorAL.rotation.y = Math.PI / 2;
        planeExtGroup.add(doorAL);
        // Aft right door
        var doorAR = new THREE.LineSegments(doorEdges.clone(), doorLineMat);
        doorAR.position.set(-R - 0.03, R * 0.2, -halfLen + 7);
        doorAR.rotation.y = -Math.PI / 2;
        planeExtGroup.add(doorAR);

        // ── Belly fairing (wing-to-body fairing, smooth transition) ──
        var fairingGeo = new THREE.BoxGeometry(1.6, 0.2, 8);
        var fairing = new THREE.Mesh(fairingGeo, MAT.white);
        fairing.position.set(0, -R - 0.08, -1);
        planeExtGroup.add(fairing);

        // ── Cargo door outlines (forward and aft belly) ──
        var cargoDoorGeo = new THREE.PlaneGeometry(1.8, 1.2);
        var cargoDoorEdges = new THREE.EdgesGeometry(cargoDoorGeo);
        var cargoDoorLineMat = new THREE.LineBasicMaterial({ color: 0x888888 });
        // Forward cargo door
        var cargoDoorF = new THREE.LineSegments(cargoDoorEdges, cargoDoorLineMat);
        cargoDoorF.position.set(0, -R - 0.01, 8);
        cargoDoorF.rotation.x = Math.PI / 2;
        planeExtGroup.add(cargoDoorF);
        // Aft cargo door
        var cargoDoorA = new THREE.LineSegments(cargoDoorEdges.clone(), cargoDoorLineMat);
        cargoDoorA.position.set(0, -R - 0.01, -8);
        cargoDoorA.rotation.x = Math.PI / 2;
        planeExtGroup.add(cargoDoorA);

        // ── Belly anti-collision stripe (gray panel) ──
        var bellyPanelGeo = new THREE.CylinderGeometry(R + 0.012, R + 0.012, PLANE.len * 0.7, 32, 1, false, Math.PI * 0.95, Math.PI * 0.10);
        var bellyPanel = new THREE.Mesh(bellyPanelGeo, new THREE.MeshStandardMaterial({ color: 0xd0d0d0, roughness: 0.5 }));
        bellyPanel.rotation.x = Math.PI / 2;
        planeExtGroup.add(bellyPanel);

        // ── Fuselage red accent stripe (below windows) ──
        var accentGeo = new THREE.CylinderGeometry(R + 0.018, R + 0.018, PLANE.len, 32, 1, false, Math.PI * 0.40, Math.PI * 0.04);
        var accent = new THREE.Mesh(accentGeo, MAT.fuselageAccent);
        accent.rotation.x = Math.PI / 2;
        planeExtGroup.add(accent);

        // ── Antenna (shark fin on top of fuselage) ──
        var antennaShape = new THREE.Shape();
        antennaShape.moveTo(0, 0);
        antennaShape.lineTo(0.8, 0);
        antennaShape.lineTo(0.3, 0.5);
        antennaShape.lineTo(0, 0);
        var antennaGeo = new THREE.ExtrudeGeometry(antennaShape, { depth: 0.06, bevelEnabled: false });
        var antenna = new THREE.Mesh(antennaGeo, MAT.darkPlastic);
        antenna.rotation.x = Math.PI / 2;
        antenna.rotation.y = Math.PI / 2;
        antenna.position.set(-0.03, R + 0.01, 3);
        planeExtGroup.add(antenna);

        // ── Navigation lights ──
        // Red on left wingtip
        var navRedLight = new THREE.Mesh(new THREE.SphereGeometry(0.08, 6, 6), MAT.navRed);
        navRedLight.position.set(PLANE.wingSpan / 2 + 0.1, -R * 0.35 + 0.1, -1);
        planeExtGroup.add(navRedLight);
        // Green on right wingtip
        var navGreenLight = new THREE.Mesh(new THREE.SphereGeometry(0.08, 6, 6), MAT.navGreen);
        navGreenLight.position.set(-PLANE.wingSpan / 2 - 0.1, -R * 0.35 + 0.1, -1);
        planeExtGroup.add(navGreenLight);
        // White on tail
        var navTailLight = new THREE.Mesh(new THREE.SphereGeometry(0.08, 6, 6), MAT.navWhite);
        navTailLight.position.set(0, R + 0.3, -halfLen - 7.8);
        planeExtGroup.add(navTailLight);
        // Anti-collision beacon (red, on top of fuselage)
        var beaconTop = new THREE.Mesh(new THREE.SphereGeometry(0.1, 6, 6), MAT.navRed);
        beaconTop.position.set(0, R + 0.1, 0);
        planeExtGroup.add(beaconTop);
        // Belly beacon
        var beaconBot = new THREE.Mesh(new THREE.SphereGeometry(0.1, 6, 6), MAT.navRed);
        beaconBot.position.set(0, -R - 0.1, 0);
        planeExtGroup.add(beaconBot);

        // ── Wings (tapered airfoil shape, white) ──
        // Wing uses a custom ExtrudeGeometry for proper airfoil cross-section with taper
        function makeWing(side) {
            // side: 1 = left(+X), -1 = right(-X)
            var wGroup = new THREE.Group();
            var span = PLANE.wingSpan / 2 - R; // ~15m per side
            var rootChord = PLANE.wingChord;     // 5m at root
            var tipChord = rootChord * 0.35;     // 1.75m at tip (tapered)
            var thickness = 0.5;                  // airfoil max thickness at root
            var tipThickness = 0.18;              // thinner at tip

            // Build wing as a custom BufferGeometry (tapered box)
            // 8 vertices: 4 at root, 4 at tip
            var rootX = side * R;           // root starts at fuselage edge
            var tipX = side * (R + span);   // tip at full span
            var rootLE = rootChord * 0.3;   // leading edge forward of spar
            var rootTE = -rootChord * 0.7;  // trailing edge behind spar
            var tipLE = tipChord * 0.3;     // tip leading edge (swept back)
            var tipTE = -tipChord * 0.7;    // tip trailing edge
            var sweep = -2.0;               // sweep: tip is 2m further aft than root

            var verts = new Float32Array([
                // Root: top-LE, top-TE, bot-LE, bot-TE
                rootX, thickness / 2, rootLE,
                rootX, thickness / 2, rootTE,
                rootX, -thickness / 2, rootLE,
                rootX, -thickness / 2, rootTE,
                // Tip: top-LE, top-TE, bot-LE, bot-TE
                tipX, tipThickness / 2, tipLE + sweep,
                tipX, tipThickness / 2, tipTE + sweep,
                tipX, -tipThickness / 2, tipLE + sweep,
                tipX, -tipThickness / 2, tipTE + sweep
            ]);

            // 12 triangles (6 faces, 2 tri each)
            var indices = [
                // Top face (LE-root, TE-root, TE-tip, LE-tip)
                0, 1, 5, 0, 5, 4,
                // Bottom face
                2, 6, 7, 2, 7, 3,
                // Leading edge (front face)
                0, 4, 6, 0, 6, 2,
                // Trailing edge (back face)
                1, 3, 7, 1, 7, 5,
                // Root cap
                0, 2, 3, 0, 3, 1,
                // Tip cap
                4, 5, 7, 4, 7, 6
            ];

            var wingGeo = new THREE.BufferGeometry();
            wingGeo.setAttribute('position', new THREE.BufferAttribute(verts, 3));
            wingGeo.setIndex(indices);
            wingGeo.computeVertexNormals();

            var wingMat = new THREE.MeshStandardMaterial({ color: 0xe8e8e8, roughness: 0.4, metalness: 0.1, side: THREE.DoubleSide });
            var wingMesh = new THREE.Mesh(wingGeo, wingMat);
            wingMesh.castShadow = true;
            wGroup.add(wingMesh);

            // Winglet (blended, curves up at the tip)
            var wingletGeo = new THREE.BoxGeometry(0.12, 1.4, tipChord * 0.5);
            var winglet = new THREE.Mesh(wingletGeo, MAT.white);
            winglet.position.set(tipX + side * 0.06, 0.7, tipLE + sweep - tipChord * 0.15);
            winglet.rotation.z = side * 0.15; // slight outward cant
            wGroup.add(winglet);

            wGroup.position.set(0, -R * 0.35, 0); // wings below fuselage center
            return wGroup;
        }
        planeExtGroup.add(makeWing(1));
        planeExtGroup.add(makeWing(-1));

        // ── Engines (under wings, with spinning fan blades) ──
        function makeEngine(xPos) {
            var eGroup = new THREE.Group();
            // Nacelle (cylinder along Z)
            var nacGeo = new THREE.CylinderGeometry(0.65, 0.75, 3.5, 18);
            var nacelle = new THREE.Mesh(nacGeo, MAT.metal);
            nacelle.rotation.x = Math.PI / 2;
            eGroup.add(nacelle);
            // Exhaust nozzle (rear, darker ring)
            var exhaustGeo = new THREE.CylinderGeometry(0.55, 0.62, 0.4, 18);
            var exhaust = new THREE.Mesh(exhaustGeo, MAT.darkPlastic);
            exhaust.rotation.x = Math.PI / 2;
            exhaust.position.z = -1.8;
            eGroup.add(exhaust);
            // Intake ring (thick lip)
            var intakeGeo = new THREE.TorusGeometry(0.65, 0.06, 8, 24);
            var intake = new THREE.Mesh(intakeGeo, MAT.metal);
            intake.position.z = 1.75;
            eGroup.add(intake);
            // Inner dark circle (engine interior)
            var innerGeo = new THREE.CircleGeometry(0.62, 18);
            var inner = new THREE.Mesh(innerGeo, new THREE.MeshBasicMaterial({ color: 0x0a0a0a }));
            inner.position.z = 1.73;
            eGroup.add(inner);
            // Spinner cone (center hub)
            var spinnerGeo = new THREE.ConeGeometry(0.12, 0.35, 12);
            var spinner = new THREE.Mesh(spinnerGeo, MAT.metal);
            spinner.rotation.x = -Math.PI / 2;
            spinner.position.z = 1.85;
            eGroup.add(spinner);
            // Fan blade disc (group that rotates)
            var fanGroup = new THREE.Group();
            fanGroup.position.z = 1.72;
            var bladeCount = 18;
            var bladeMat = new THREE.MeshStandardMaterial({ color: 0x888899, roughness: 0.3, metalness: 0.8, side: THREE.DoubleSide });
            for (var b = 0; b < bladeCount; b++) {
                var angle = (b / bladeCount) * Math.PI * 2;
                var bladeGeo = new THREE.PlaneGeometry(0.04, 0.48);
                var blade = new THREE.Mesh(bladeGeo, bladeMat);
                blade.position.set(Math.cos(angle) * 0.35, Math.sin(angle) * 0.35, 0);
                blade.rotation.z = angle;
                // Slight twist to simulate airfoil
                blade.rotation.x = 0.3;
                fanGroup.add(blade);
            }
            eGroup.add(fanGroup);
            engineFans.push(fanGroup);
            // Pylon (connects engine to wing)
            var pylonGeo = new THREE.BoxGeometry(0.15, 1.2, 2.5);
            var pylon = new THREE.Mesh(pylonGeo, MAT.metal);
            pylon.position.y = 1.35;
            pylon.position.z = -0.2;
            eGroup.add(pylon);

            eGroup.position.set(xPos, -R * 0.35 - 1.3, 0);
            return eGroup;
        }
        planeExtGroup.add(makeEngine(6.0));
        planeExtGroup.add(makeEngine(-6.0));

        // ── Vertical Stabilizer (swept tail fin) ──
        // Shape drawn in XY: X = fore/aft, Y = height
        // Only rotation.y = PI/2 maps: X→-Z (toward tail), Y stays Y (upward), extrusion Z→+X (thickness)
        var vfinShape = new THREE.Shape();
        vfinShape.moveTo(0, 0);
        vfinShape.lineTo(7, 0);
        vfinShape.quadraticCurveTo(5, 3.5, 3, 5.5);
        vfinShape.lineTo(1.5, 5.5);
        vfinShape.quadraticCurveTo(0.8, 4, 0, 0);
        var vfinDepth = 0.5;
        var vfinGeo = new THREE.ExtrudeGeometry(vfinShape, { depth: vfinDepth, bevelEnabled: true, bevelThickness: 0.1, bevelSize: 0.1, bevelSegments: 3 });
        var vfin = new THREE.Mesh(vfinGeo, MAT.blue);
        vfin.rotation.y = Math.PI / 2;  // only Y rotation — stands upright
        vfin.position.set(-vfinDepth / 2, R, -halfLen + 2);
        planeExtGroup.add(vfin);

        // ── Tail livery accent (red swoosh on vertical fin) ──
        var liveryShape = new THREE.Shape();
        liveryShape.moveTo(0, 0);
        liveryShape.lineTo(7, 0);
        liveryShape.quadraticCurveTo(4.5, 1.5, 3, 3);
        liveryShape.lineTo(0, 0);
        var liveryGeo = new THREE.ExtrudeGeometry(liveryShape, { depth: vfinDepth + 0.06, bevelEnabled: false });
        var livery = new THREE.Mesh(liveryGeo, MAT.fuselageAccent);
        livery.rotation.y = Math.PI / 2;  // same as fin
        livery.position.set(-(vfinDepth + 0.06) / 2, R, -halfLen + 2);
        planeExtGroup.add(livery);

        // ── Horizontal Stabilizers ──
        for (var hs = -1; hs <= 1; hs += 2) {
            var hsGroup = new THREE.Group();
            var hsGeo = new THREE.BoxGeometry(6, 0.15, 3);
            var hStab = new THREE.Mesh(hsGeo, MAT.metal);
            hsGroup.add(hStab);
            hsGroup.position.set(hs * 3.5, R + 0.2, -halfLen - 1);
            planeExtGroup.add(hsGroup);
        }

        // ── Landing Gear ──
        var gearMetal = new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 0.3, metalness: 0.7 });
        function makeGear(x, z, numWheels, isMain) {
            var gGroup = new THREE.Group();
            // Main strut (oleo/shock absorber - two-piece telescoping)
            var strutUpper = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.08, 0.8, 8), gearMetal);
            strutUpper.position.y = -0.1;
            gGroup.add(strutUpper);
            var strutLower = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.06, 0.8, 8), gearMetal);
            strutLower.position.y = -0.8;
            gGroup.add(strutLower);
            // Hydraulic lines (thin tubes on strut)
            var hydraulic = new THREE.Mesh(new THREE.CylinderGeometry(0.015, 0.015, 1.2, 4), MAT.darkPlastic);
            hydraulic.position.set(0.08, -0.4, 0);
            gGroup.add(hydraulic);
            // Axle
            var axleW = numWheels * 0.4;
            var axle = new THREE.Mesh(new THREE.CylinderGeometry(0.035, 0.035, axleW, 6), gearMetal);
            axle.rotation.z = Math.PI / 2;
            axle.position.y = -1.15;
            gGroup.add(axle);
            // Wheels with tire detail
            for (var w = 0; w < numWheels; w++) {
                var wheelGroup = new THREE.Group();
                // Tire (torus for roundness)
                var tire = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.3, 0.3, 0.18, 16),
                    MAT.darkPlastic
                );
                tire.rotation.z = Math.PI / 2;
                wheelGroup.add(tire);
                // Hub cap (silver center)
                var hub = new THREE.Mesh(new THREE.CircleGeometry(0.15, 10), gearMetal);
                hub.position.x = 0.1;
                hub.rotation.y = Math.PI / 2;
                wheelGroup.add(hub);
                var hub2 = new THREE.Mesh(new THREE.CircleGeometry(0.15, 10), gearMetal);
                hub2.position.x = -0.1;
                hub2.rotation.y = -Math.PI / 2;
                wheelGroup.add(hub2);
                wheelGroup.position.set((w - (numWheels - 1) / 2) * 0.45, -1.15, 0);
                gGroup.add(wheelGroup);
            }
            // Gear door (folded open along fuselage)
            if (isMain) {
                var doorGeo = new THREE.BoxGeometry(0.5, 0.04, 1.2);
                var door = new THREE.Mesh(doorGeo, MAT.white);
                door.position.set(x > 0 ? 0.4 : -0.4, 0.15, 0);
                door.rotation.z = x > 0 ? 0.8 : -0.8;
                gGroup.add(door);
            }
            gGroup.position.set(x, -R, z);
            return gGroup;
        }
        // Nose gear (single pair, forward)
        planeExtGroup.add(makeGear(0, halfLen - 5, 2, false));
        // Main gear (double pair, under wings)
        planeExtGroup.add(makeGear(1.5, -3, 2, true));
        planeExtGroup.add(makeGear(-1.5, -3, 2, true));

        // ── Gear well covers (on belly, where gear retracts into) ──
        for (var gwSide = -1; gwSide <= 1; gwSide += 2) {
            var gearWell = new THREE.Mesh(new THREE.PlaneGeometry(1.0, 1.8), new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 0.5 }));
            gearWell.rotation.x = -Math.PI / 2;
            gearWell.position.set(gwSide * 1.5, -R + 0.01, -3);
            planeExtGroup.add(gearWell);
        }

        // Position the whole plane at gate A7: nose pointing +Z
        // x=15 puts left side (-X) facing the terminal window wall at x=2
        // z=-10 so forward door (local z=halfLen-4=15) aligns with gate A7 at z=5
        // Forward door (-X side) world pos: (13, 3.9, 5)
        planeExtGroup.position.set(15, R + 2.0, -10);
    }

    // ═══════════════════════════════════════════════════
    //  CABIN INTERIOR
    // ═══════════════════════════════════════════════════
    // ── CABIN: Z-forward, X = left/right, Y = up ──
    // Real 737 cabin: ~3.54m wide, ~2.2m tall inside, ~24m passenger cabin length
    // Scale: 1 unit ≈ 1 meter
    function buildCabin() {
        var CW = 4.8;  // cabin width (meters)
        var CH = 2.8;  // cabin height
        var CL = 22;   // cabin length (passenger section)
        var halfW = CW / 2;
        var halfL = CL / 2;

        // ── Fuselage shell (elliptical arch, centered at chest height) ──
        // Ellipse: x = Rh*cos(a), y = centerY + Rv*sin(a)
        // Widest at ~shoulder height, narrowing at floor and ceiling
        var Rh = halfW;            // horizontal radius = 2.4
        var archCenterY = 0.8;     // ellipse center height (chest level)
        var Rv = CH - archCenterY; // vertical radius = 2.0 (reaches ceiling at CH)
        // Helper: get arch wall X at given Y height
        function archXatY(yh) {
            var t = (yh - archCenterY) / Rv;
            if (t >= 1) return 0;
            if (t <= -1) return Rh;
            return Rh * Math.sqrt(1 - t * t);
        }
        // Arch from right-floor → top → left-floor
        var archFloorA = Math.asin(-archCenterY / Rv); // ~-0.412 rad (right floor)
        var archStart = archFloorA;
        var archEnd = Math.PI - archFloorA;             // ~PI+0.412 (left floor)
        var archRange = archEnd - archStart;
        // Window cutout parameters
        var winY = 1.2;
        var winHalfH = 0.21;  // half of 0.42 (frame height)
        var winHalfZ = 0.15;  // half of 0.30 (frame width in Z)
        var winYBot = winY - winHalfH; // 0.99
        var winYTop = winY + winHalfH; // 1.41
        var rowPitch = 0.80;
        // Pre-compute window Z positions
        var windowZList = [];
        for (var wzi = -halfL + 1.5; wzi < halfL - 1; wzi += rowPitch) {
            windowZList.push(wzi);
        }
        // Pre-compute Z breakpoints for window segments
        var zBreaks = [-halfL];
        for (var wb = 0; wb < windowZList.length; wb++) {
            zBreaks.push(windowZList[wb] - winHalfZ);
            zBreaks.push(windowZList[wb] + winHalfZ);
        }
        zBreaks.push(halfL);

        // Helper: build one arch quad panel from z0 to z1
        function addArchPanel(ax0, ay0, ax1, ay1, az0, az1) {
            var v = new Float32Array([
                ax0, ay0, az0,  ax0, ay0, az1,  ax1, ay1, az1,  ax1, ay1, az0
            ]);
            var g = new THREE.BufferGeometry();
            g.setAttribute('position', new THREE.BufferAttribute(v, 3));
            g.setIndex([0, 1, 2, 0, 2, 3]);
            g.computeVertexNormals();
            cabinGroup.add(new THREE.Mesh(g, MAT.plastic));
        }

        var archSegs = 32;
        for (var wp = 0; wp < archSegs; wp++) {
            var a0 = archStart + (wp / archSegs) * archRange;
            var a1 = archStart + ((wp + 1) / archSegs) * archRange;
            var x0 = Rh * Math.cos(a0);
            var y0 = Math.max(0, archCenterY + Rv * Math.sin(a0));
            var x1 = Rh * Math.cos(a1);
            var y1 = Math.max(0, archCenterY + Rv * Math.sin(a1));

            // Check if this segment overlaps with window height
            var segYmin = Math.min(y0, y1);
            var segYmax = Math.max(y0, y1);
            var isWindowSeg = segYmax > winYBot && segYmin < winYTop;

            if (isWindowSeg) {
                // Build Z-segmented panels with gaps at window positions
                // Wall sections are at even indices: [0,1], [2,3], [4,5], ...
                // Window gaps (skipped) are at odd indices: [1,2], [3,4], ...
                for (var zb = 0; zb < zBreaks.length - 1; zb += 2) {
                    var z0 = zBreaks[zb];
                    var z1 = zBreaks[zb + 1];
                    if (z1 <= z0 + 0.01) continue;
                    addArchPanel(x0, y0, x1, y1, z0, z1);
                }
            } else {
                // Full-length panel (no windows at this height)
                addArchPanel(x0, y0, x1, y1, -halfL, halfL);
            }
        }

        // ── Front bulkhead wall (seals cabin at +Z end) ──
        var frontBulkhead = new THREE.Mesh(new THREE.PlaneGeometry(CW, CH), MAT.plastic);
        frontBulkhead.position.set(0, CH / 2, halfL);
        frontBulkhead.rotation.y = Math.PI;
        cabinGroup.add(frontBulkhead);

        // ── Rear bulkhead wall (seals cabin at -Z end) ──
        var rearBulkhead = new THREE.Mesh(new THREE.PlaneGeometry(CW, CH), MAT.plastic);
        rearBulkhead.position.set(0, CH / 2, -halfL);
        cabinGroup.add(rearBulkhead);

        // ── Floor ──
        var floor = new THREE.Mesh(new THREE.PlaneGeometry(CW, CL), MAT.carpet);
        floor.rotation.x = -Math.PI / 2;
        cabinGroup.add(floor);

        // ── Aisle strip (center of floor) ──
        var aisleMat = new THREE.MeshStandardMaterial({ color: 0x222830, roughness: 0.9 });
        var aisle = new THREE.Mesh(new THREE.PlaneGeometry(0.5, CL), aisleMat);
        aisle.rotation.x = -Math.PI / 2;
        aisle.position.y = 0.005;
        cabinGroup.add(aisle);

        // ── Seats: 3-3 layout (A B C | aisle | D E F) ──
        // Real economy seat: ~44cm wide, ~80cm pitch (row spacing)
        var seatWidth = 0.44;
        // rowPitch already defined above (0.80) for window Z positions
        var aisleHalfW = 0.25;
        // Left group: seats at x = aisleHalfW + seatWidth*0.5, +seatWidth, +seatWidth*2
        // Right group: mirrored
        var seatPositionsX = [];
        for (var s = 0; s < 3; s++) {
            var leftX = aisleHalfW + seatWidth * 0.5 + s * seatWidth;
            seatPositionsX.push(leftX);   // left side (+X)
            seatPositionsX.push(-leftX);  // right side (-X)
        }

        var firstRowZ = -halfL + 1.5;
        var numRows = Math.floor((CL - 2) / rowPitch);
        for (var row = 0; row < numRows; row++) {
            var rz = firstRowZ + row * rowPitch;
            for (var si = 0; si < seatPositionsX.length; si++) {
                cabinGroup.add(buildSeat(seatPositionsX[si], rz));
            }
        }

        // ── Overhead bins (both sides, follow arch curvature) ──
        var binH = 0.4, binD = 0.55;
        var binY = CH - 0.45;
        var binWallX = archXatY(binY); // arch X at bin height
        for (var bSide = -1; bSide <= 1; bSide += 2) {
            for (var bz = -halfL + 1; bz < halfL - 1; bz += 3) {
                var segLen = Math.min(2.8, halfL - 1 - bz);
                if (segLen < 0.5) continue;
                var bin = new THREE.Mesh(new THREE.BoxGeometry(binD, binH, segLen), MAT.plastic);
                bin.position.set(bSide * (binWallX - binD / 2 - 0.03), binY, bz + segLen / 2);
                cabinGroup.add(bin);
                // Handle
                var handle = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.03, segLen * 0.5), MAT.darkPlastic);
                handle.position.set(bSide * (binWallX - binD - 0.05), binY - binH / 2 - 0.02, bz + segLen / 2);
                cabinGroup.add(handle);
            }
        }

        // ── Window trim and exterior view planes ──
        var winWallX = archXatY(winY); // arch X at window height
        var trimMat = new THREE.MeshStandardMaterial({ color: 0x555555, roughness: 0.5 });
        // Sky view for exterior view behind each window (updated dynamically with altitude)
        var skyViewCanvas = document.createElement('canvas');
        skyViewCanvas.width = 64; skyViewCanvas.height = 64;
        var svCtx = skyViewCanvas.getContext('2d');
        var skyViewTex = new THREE.CanvasTexture(skyViewCanvas);
        var skyViewMat = new THREE.MeshBasicMaterial({ map: skyViewTex });
        var lastSkyAlt = -1; // track to avoid unnecessary redraws

        function updateSkyView() {
            var alt = G.altitude || 0;
            // Quantize to avoid repainting every frame
            var altBucket = Math.floor(alt / 500);
            if (altBucket === lastSkyAlt) return;
            lastSkyAlt = altBucket;

            var f = Math.min(alt / 10000, 1); // 0 = ground, 1 = high altitude
            var grad = svCtx.createLinearGradient(0, 0, 0, 64);
            // Ground line drops as altitude increases; at f=1 it's all sky
            var horizonPos = 0.55 + f * 0.45; // 0.55 on ground → 1.0 at altitude
            // Sky darkens with altitude
            var skyR = Math.round(85 - f * 50), skyG = Math.round(153 - f * 60), skyB = Math.round(221 - f * 80);
            var skyR2 = Math.round(136 - f * 60), skyG2 = Math.round(204 - f * 80), skyB2 = Math.round(255 - f * 80);
            grad.addColorStop(0, 'rgb(' + skyR + ',' + skyG + ',' + skyB + ')');
            grad.addColorStop(Math.min(horizonPos, 0.99), 'rgb(' + skyR2 + ',' + skyG2 + ',' + skyB2 + ')');
            if (horizonPos < 0.99) {
                grad.addColorStop(horizonPos, '#44aa55');
                grad.addColorStop(1, '#337733');
            }
            svCtx.fillStyle = grad;
            svCtx.fillRect(0, 0, 64, 64);
            skyViewTex.needsUpdate = true;
        }
        updateSkyView(); // initial ground-level draw

        // Calculate wall tilt angle at window height for frame rotation
        // The arch tangent at angle a: (-Rh*sin(a), Rv*cos(a))
        // Wall tilt from vertical = atan2(Rh*sin(a), Rv*cos(a))
        var winSinA = (winY - archCenterY) / Rv; // sin(a) at window height
        var winCosA = Math.sqrt(1 - winSinA * winSinA);
        var wallTilt = Math.atan2(Rh * winSinA, Rv * winCosA); // ~0.24 rad (~14°)

        for (var wfz = 0; wfz < windowZList.length; wfz++) {
            var wz = windowZList[wfz];
            for (var wSide = -1; wSide <= 1; wSide += 2) {
                var wx = wSide * winWallX;
                // Frame group — tilted to match wall curvature
                var frameGrp = new THREE.Group();
                frameGrp.position.set(wx * 0.98, winY, wz);
                frameGrp.rotation.z = wSide * wallTilt; // tilt outward to match arch lean
                // Top trim
                frameGrp.add(pm(new THREE.BoxGeometry(0.04, 0.025, winHalfZ * 2 + 0.04), trimMat, 0, winHalfH, 0));
                // Bottom trim
                frameGrp.add(pm(new THREE.BoxGeometry(0.04, 0.025, winHalfZ * 2 + 0.04), trimMat, 0, -winHalfH, 0));
                // Side trims
                frameGrp.add(pm(new THREE.BoxGeometry(0.04, winHalfH * 2, 0.025), trimMat, 0, 0, -winHalfZ));
                frameGrp.add(pm(new THREE.BoxGeometry(0.04, winHalfH * 2, 0.025), trimMat, 0, 0, winHalfZ));
                cabinGroup.add(frameGrp);
                // Exterior view plane (sky/ground gradient behind the hole)
                var extView = new THREE.Mesh(new THREE.PlaneGeometry(winHalfZ * 2 - 0.02, winHalfH * 2 - 0.02), skyViewMat);
                extView.position.set(wSide * (winWallX + 0.1), winY, wz);
                extView.rotation.y = wSide > 0 ? -Math.PI / 2 : Math.PI / 2;
                cabinGroup.add(extView);
            }
        }

        // ── Individual ceiling lights above each seat, every 2 rows ──
        var ceilLightY = binY - binH / 2 - 0.04; // just below overhead bins
        var ceilLightGeo = new THREE.BoxGeometry(0.10, 0.02, 0.10);
        var ceilLightLensGeo = new THREE.CircleGeometry(0.04, 12);
        for (var lr = 0; lr < numRows; lr += 2) {
            var lrZ = firstRowZ + lr * rowPitch;
            for (var lsi = 0; lsi < seatPositionsX.length; lsi++) {
                var lsx = seatPositionsX[lsi];
                // Light housing
                var lHouse = new THREE.Mesh(ceilLightGeo, MAT.darkPlastic);
                lHouse.position.set(lsx, ceilLightY, lrZ);
                cabinGroup.add(lHouse);
                // Light lens (glowing face pointing down)
                var lLens = new THREE.Mesh(ceilLightLensGeo, MAT.lightEmit);
                lLens.position.set(lsx, ceilLightY - 0.011, lrZ);
                lLens.rotation.x = -Math.PI / 2;
                cabinGroup.add(lLens);
                cabinLightMeshes.push(lLens);
            }
            // One point light per row (centered in aisle) for actual illumination
            var pLight = new THREE.PointLight(0xffffee, 0.4, 4);
            pLight.position.set(0, ceilLightY - 0.1, lrZ);
            cabinGroup.add(pLight);
            cabinLights.push(pLight);
        }


        // ── Cockpit door (front, centered) ──
        var cDoor = new THREE.Mesh(new THREE.BoxGeometry(0.9, 1.9, 0.08), MAT.metal);
        cDoor.position.set(0, 0.95, halfL - 0.04);
        cabinGroup.add(cDoor);

        // ── EXIT signs (front and rear) ──
        var exitMat = new THREE.MeshBasicMaterial({ color: 0x00ff44 });
        var ex1 = new THREE.Mesh(new THREE.BoxGeometry(0.35, 0.12, 0.02), exitMat);
        ex1.position.set(0, CH - 0.1, halfL - 0.5);
        cabinGroup.add(ex1);
        var ex2 = new THREE.Mesh(new THREE.BoxGeometry(0.35, 0.12, 0.02), exitMat);
        ex2.position.set(0, CH - 0.1, -halfL + 0.5);
        cabinGroup.add(ex2);

        // ── Emergency floor light strips (flush with floor, along aisle edges) ──
        // Continuous LED strips that guide passengers down the aisle
        var aisleEdgeX = 0.35; // just outside the aisle walkway
        var floorStripMat = new THREE.MeshBasicMaterial({ color: 0x88cc66, transparent: true, opacity: 0.5 });
        var floorStripLen = 0.7;
        var floorStripGeo = new THREE.PlaneGeometry(0.04, floorStripLen);
        for (var elz = -halfL + 1; elz < halfL - 1; elz += floorStripLen + 0.1) {
            for (var elSide = -1; elSide <= 1; elSide += 2) {
                var fStrip = new THREE.Mesh(floorStripGeo, floorStripMat);
                fStrip.position.set(elSide * aisleEdgeX, 0.005, elz);
                fStrip.rotation.x = -Math.PI / 2; // lay flat on floor
                cabinGroup.add(fStrip);
                emergencyLightMeshes.push(fStrip);
            }
        }

        // ── Row numbers (on overhead bins, every row) ──
        var rowNumMat = new THREE.MeshBasicMaterial({ color: 0x88aacc });
        for (var rn = 0; rn < numRows; rn++) {
            var rnZ = firstRowZ + rn * rowPitch;
            for (var rnSide = -1; rnSide <= 1; rnSide += 2) {
                var rowTag = new THREE.Mesh(new THREE.PlaneGeometry(0.12, 0.08), rowNumMat);
                rowTag.position.set(rnSide * (binWallX - binD - 0.03), binY - binH / 2 - 0.01, rnZ);
                rowTag.rotation.y = rnSide > 0 ? -Math.PI / 2 : Math.PI / 2;
                cabinGroup.add(rowTag);
            }
        }

        // ── Air vent / reading light panel (PSU panel above each seat group) ──
        var psuMat = new THREE.MeshStandardMaterial({ color: 0xd0ccc0, roughness: 0.6 });
        for (var psu = -halfL + 1.5; psu < halfL - 1; psu += rowPitch * 3) {
            for (var psuSide = -1; psuSide <= 1; psuSide += 2) {
                // PSU strip (Passenger Service Unit)
                var psuPanel = new THREE.Mesh(new THREE.BoxGeometry(0.35, 0.04, 0.2), psuMat);
                psuPanel.position.set(psuSide * (binWallX - binD - 0.05), binY - binH / 2 + 0.02, psu);
                cabinGroup.add(psuPanel);
                // Air nozzle (gasper)
                var nozzleMat = new THREE.MeshStandardMaterial({ color: 0x999999, roughness: 0.3, metalness: 0.5 });
                var gasper = new THREE.Mesh(new THREE.CylinderGeometry(0.025, 0.03, 0.04, 8), nozzleMat);
                gasper.position.set(psuSide * (binWallX - binD - 0.05), binY - binH / 2 - 0.01, psu);
                cabinGroup.add(gasper);
            }
        }

        // ── No-smoking / Seatbelt illuminated signs (on overhead bin faces) ──
        var signLitMat = new THREE.MeshBasicMaterial({ color: 0x224433 });
        for (var sgz = -halfL + 2.5; sgz < halfL - 2; sgz += 6) {
            for (var sgSide = -1; sgSide <= 1; sgSide += 2) {
                // Seatbelt sign
                var sbSign = new THREE.Mesh(new THREE.BoxGeometry(0.006, 0.06, 0.14), signLitMat);
                sbSign.position.set(sgSide * (binWallX - binD - 0.03), binY - 0.05, sgz);
                cabinGroup.add(sbSign);
                // No smoking sign (offset from seatbelt)
                var nsSign = new THREE.Mesh(new THREE.BoxGeometry(0.006, 0.06, 0.14), signLitMat);
                nsSign.position.set(sgSide * (binWallX - binD - 0.03), binY - 0.05, sgz + 0.2);
                cabinGroup.add(nsSign);
            }
        }

        // ── Lavatory (rear of cabin) ──
        var lavZ = -halfL + 0.2;
        // Lavatory wall (partition)
        var lavWall = new THREE.Mesh(new THREE.BoxGeometry(CW, CH * 0.9, 0.06), MAT.plastic);
        lavWall.position.set(0, CH * 0.45, lavZ);
        cabinGroup.add(lavWall);
        // Lavatory door (left side)
        var lavDoorMesh = new THREE.Mesh(new THREE.BoxGeometry(0.65, 1.7, 0.04), MAT.lavDoor);
        lavDoorMesh.position.set(-0.7, 0.85, lavZ + 0.05);
        cabinGroup.add(lavDoorMesh);
        // Door handle
        var lavHandle = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.03, 0.03), MAT.metal);
        lavHandle.position.set(-0.5, 0.9, lavZ + 0.08);
        cabinGroup.add(lavHandle);
        // Occupied sign (red/green indicator)
        var occSign = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.04, 0.01), MAT.emergencyGreen);
        occSign.position.set(-0.7, 1.75, lavZ + 0.06);
        cabinGroup.add(occSign);
        // Lavatory door (right side)
        var lavDoor2 = new THREE.Mesh(new THREE.BoxGeometry(0.65, 1.7, 0.04), MAT.lavDoor);
        lavDoor2.position.set(0.7, 0.85, lavZ + 0.05);
        cabinGroup.add(lavDoor2);

        // ── Galley area (front of cabin, behind cockpit) ──
        var galleyZ = halfL - 0.8;
        // Galley cart slot (stainless steel units)
        var galleyWallX = archXatY(0.5); // arch X at galley unit center height
        for (var gc = -1; gc <= 1; gc += 2) {
            var galleyUnit = new THREE.Mesh(new THREE.BoxGeometry(0.5, 1.0, 0.6), MAT.stainless);
            galleyUnit.position.set(gc * (galleyWallX - 0.35), 0.5, galleyZ);
            cabinGroup.add(galleyUnit);
            // Counter top
            var counter = new THREE.Mesh(new THREE.BoxGeometry(0.55, 0.03, 0.65), MAT.darkPlastic);
            counter.position.set(gc * (galleyWallX - 0.35), 1.02, galleyZ);
            cabinGroup.add(counter);
        }
        // Galley curtain rod
        var curtainRod = new THREE.Mesh(new THREE.CylinderGeometry(0.01, 0.01, CW - 0.5, 6), MAT.metal);
        curtainRod.rotation.z = Math.PI / 2;
        curtainRod.position.set(0, CH - 0.15, galleyZ - 0.3);
        cabinGroup.add(curtainRod);

        // ── Cabin crew jump seats (folded, near doors) ──
        for (var jsSide = -1; jsSide <= 1; jsSide += 2) {
            var jumpSeat = new THREE.Group();
            var jsBack = new THREE.Mesh(new THREE.BoxGeometry(0.45, 0.7, 0.04), MAT.darkPlastic);
            jsBack.position.y = 0.7;
            jumpSeat.add(jsBack);
            var jsCush = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.04, 0.25), MAT.seat);
            jsCush.position.set(0, 0.38, 0.12);
            jumpSeat.add(jsCush);
            jumpSeat.position.set(jsSide * (archXatY(0.7) - 0.3), 0, halfL - 0.5);
            jumpSeat.rotation.y = Math.PI;
            cabinGroup.add(jumpSeat);
        }

        cabinGroup.visible = false;
    }

    // ── Single seat: faces +Z (toward cockpit), x = lateral position, z = row position ──
    // Real economy seat: ~44cm wide, ~42cm deep cushion, back ~60cm tall
    function buildSeat(x, z) {
        var sg = new THREE.Group();
        var W = 0.42, D = 0.42, backH = 0.58, backT = 0.05;
        var legH = 0.40, cushionH = 0.08;
        var seatY = legH; // top of legs = bottom of cushion

        // Legs (two vertical posts)
        sg.add(pm(new THREE.BoxGeometry(0.03, legH, 0.03), MAT.metal, -W/2+0.04, legH/2, 0));
        sg.add(pm(new THREE.BoxGeometry(0.03, legH, 0.03), MAT.metal,  W/2-0.04, legH/2, 0));

        // Seat cushion
        sg.add(pm(new THREE.BoxGeometry(W, cushionH, D), MAT.seat, 0, seatY + cushionH/2, 0));

        // Seat back (behind cushion, angled slightly)
        var back = pm(new THREE.BoxGeometry(W, backH, backT), MAT.seatBack, 0, seatY + cushionH + backH/2, -D/2 + backT/2);
        back.rotation.x = 0.08; // slight recline
        sg.add(back);

        // Headrest
        sg.add(pm(new THREE.BoxGeometry(W*0.6, 0.16, 0.04), MAT.plastic, 0, seatY + cushionH + backH + 0.04, -D/2 + 0.02));

        // Armrests (on left and right edges)
        for (var arm = -1; arm <= 1; arm += 2) {
            sg.add(pm(new THREE.BoxGeometry(0.04, 0.03, D*0.7), MAT.darkPlastic, arm * W/2, seatY + cushionH + 0.04, 0.04));
        }

        // Seat pocket (fabric on back)
        sg.add(pm(new THREE.BoxGeometry(W*0.8, 0.18, 0.008), MAT.darkPlastic, 0, seatY + 0.12, -D/2 + backT + 0.005));

        sg.position.set(x, 0, z);
        return sg;
    }

    function pm(geo, mat, x, y, z) {
        var m = new THREE.Mesh(geo, mat);
        m.position.set(x, y, z);
        return m;
    }

    // ═══════════════════════════════════════════════════
    //  CLOUDS
    // ═══════════════════════════════════════════════════
    function buildCloud(x, y, z, scale, mat) {
        var cg = new THREE.Group();
        mat = mat || new THREE.MeshLambertMaterial({ color: 0xffffff, transparent: true, opacity: 0.88 });
        var count = 4 + Math.floor(Math.random() * 6);
        for (var i = 0; i < count; i++) {
            var r = (0.6 + Math.random() * 1.4) * scale;
            var s = new THREE.Mesh(new THREE.SphereGeometry(r, 7, 7), mat);
            s.position.set(
                (Math.random() - 0.5) * 5 * scale,
                (Math.random() - 0.5) * 1.5 * scale,
                (Math.random() - 0.5) * 4 * scale
            );
            cg.add(s);
        }
        cg.position.set(x, y, z);
        cg.userData.speed = 0.3 + Math.random() * 0.7;
        return cg;
    }

    function populateClouds() {
        for (var i = 0; i < 40; i++) {
            cloudGroup.add(buildCloud(
                (Math.random() - 0.5) * 600,
                25 + Math.random() * 80,
                (Math.random() - 0.5) * 600,
                2 + Math.random() * 4
            ));
        }
    }

    function populateStormClouds() {
        for (var i = 0; i < 30; i++) {
            stormCloudGroup.add(buildCloud(
                (Math.random() - 0.5) * 500,
                20 + Math.random() * 40,
                (Math.random() - 0.5) * 500,
                3 + Math.random() * 6,
                Math.random() < 0.5 ? MAT.stormCloud : MAT.darkCloud
            ));
        }
        stormCloudGroup.visible = false;
    }

    // ═══════════════════════════════════════════════════
    //  SURVIVAL SCENE
    // ═══════════════════════════════════════════════════
    function buildSurvivalScene() {
        // Dark terrain with slight undulation
        var groundGeo = new THREE.PlaneGeometry(200, 200, 20, 20);
        var groundVerts = groundGeo.attributes.position.array;
        for (var gv = 0; gv < groundVerts.length; gv += 3) {
            groundVerts[gv + 2] += (Math.random() - 0.5) * 0.6; // slight bumpiness
        }
        groundGeo.computeVertexNormals();
        var ground = new THREE.Mesh(
            groundGeo,
            new THREE.MeshStandardMaterial({ color: 0x1a2a10, roughness: 0.95 })
        );
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = -0.5;
        survivalGroup.add(ground);

        // ── Broken fuselage section (recognizable tube) ──
        var fuseWreckGeo = new THREE.CylinderGeometry(2.0, 2.0, 12, 16, 1, true, 0, Math.PI * 1.5);
        var fuseWreckMat = new THREE.MeshStandardMaterial({ color: 0xaaaaaa, roughness: 0.8, side: THREE.DoubleSide });
        var fuseWreck = new THREE.Mesh(fuseWreckGeo, fuseWreckMat);
        fuseWreck.rotation.z = Math.PI / 2;
        fuseWreck.rotation.y = 0.3;
        fuseWreck.position.set(-5, 1.5, -8);
        survivalGroup.add(fuseWreck);

        // Broken nose section
        var noseWreck = new THREE.Mesh(
            new THREE.CylinderGeometry(0.5, 2.0, 5, 12, 1, true),
            fuseWreckMat
        );
        noseWreck.rotation.z = Math.PI / 2 + 0.3;
        noseWreck.position.set(-13, 0.8, -10);
        noseWreck.rotation.y = 0.5;
        survivalGroup.add(noseWreck);

        // Broken wing section
        var wingWreck = new THREE.Mesh(
            new THREE.BoxGeometry(8, 0.3, 3),
            new THREE.MeshStandardMaterial({ color: 0xcccccc, roughness: 0.7 })
        );
        wingWreck.position.set(8, 0.3, -5);
        wingWreck.rotation.z = 0.15;
        wingWreck.rotation.y = 0.8;
        survivalGroup.add(wingWreck);

        // Tail section (vertical fin, broken)
        var tailWreckShape = new THREE.Shape();
        tailWreckShape.moveTo(0, 0);
        tailWreckShape.lineTo(3, 0);
        tailWreckShape.lineTo(1.5, 4);
        tailWreckShape.lineTo(0, 0);
        var tailWreck = new THREE.Mesh(
            new THREE.ExtrudeGeometry(tailWreckShape, { depth: 0.12, bevelEnabled: false }),
            MAT.blue
        );
        tailWreck.position.set(-18, 0, -12);
        tailWreck.rotation.z = -0.2;
        survivalGroup.add(tailWreck);

        // ── Scattered debris (metal fragments, seat pieces) ──
        var debrisColors = [0x888888, 0x999999, 0x666666, 0xaaaaaa, 0x1e3a6e, 0xe0d8cc];
        for (var i = 0; i < 30; i++) {
            var dSize = 0.2 + Math.random() * 1.5;
            var debrisMat = new THREE.MeshStandardMaterial({
                color: debrisColors[Math.floor(Math.random() * debrisColors.length)],
                roughness: 0.85
            });
            var debrisGeo = Math.random() < 0.5 ?
                new THREE.BoxGeometry(dSize, dSize * 0.3, dSize * 0.6) :
                new THREE.PlaneGeometry(dSize, dSize * 0.8);
            var debris = new THREE.Mesh(debrisGeo, debrisMat);
            if (debrisGeo.type === 'PlaneGeometry') debris.material.side = THREE.DoubleSide;
            debris.position.set(
                (Math.random() - 0.5) * 50,
                dSize * 0.1,
                (Math.random() - 0.5) * 50
            );
            debris.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * 0.5);
            survivalGroup.add(debris);
        }

        // ── Scattered luggage ──
        var luggageColors = [0x8B0000, 0x1a1a6e, 0x2d5a1e, 0x333333, 0x4a2a0a, 0xcc7722];
        for (var lu = 0; lu < 12; lu++) {
            var lugMat = new THREE.MeshStandardMaterial({
                color: luggageColors[Math.floor(Math.random() * luggageColors.length)],
                roughness: 0.8
            });
            var lugSize = 0.3 + Math.random() * 0.3;
            var lugPiece = new THREE.Mesh(
                new THREE.BoxGeometry(lugSize * 0.8, lugSize * 0.6, lugSize),
                lugMat
            );
            lugPiece.position.set(
                (Math.random() - 0.5) * 30,
                lugSize * 0.3,
                (Math.random() - 0.5) * 30
            );
            lugPiece.rotation.set(Math.random() * 0.8, Math.random() * Math.PI, Math.random() * 0.3);
            survivalGroup.add(lugPiece);
        }

        // ── Dirt/gouge marks (impact trail) ──
        var trailMat = new THREE.MeshStandardMaterial({ color: 0x0f1a08, roughness: 1.0 });
        for (var tr = 0; tr < 6; tr++) {
            var trailPiece = new THREE.Mesh(
                new THREE.PlaneGeometry(3 + Math.random() * 4, 1.5 + Math.random() * 2),
                trailMat
            );
            trailPiece.rotation.x = -Math.PI / 2;
            trailPiece.position.set(-8 + tr * 5, -0.45, -6 + tr * 1.5);
            trailPiece.rotation.z = 0.3;
            survivalGroup.add(trailPiece);
        }

        // ── Tree silhouettes (around the crash site) ──
        function makeTree(x, z) {
            var tg = new THREE.Group();
            var trunkMat = new THREE.MeshStandardMaterial({ color: 0x2a1a0a, roughness: 0.95 });
            var trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.25, 4 + Math.random() * 3, 6), trunkMat);
            trunk.position.y = 2;
            tg.add(trunk);
            var foliageMat = new THREE.MeshStandardMaterial({ color: 0x0a1a05, roughness: 0.95 });
            var foliageH = 3 + Math.random() * 2;
            var foliage = new THREE.Mesh(new THREE.ConeGeometry(1.5 + Math.random(), foliageH, 6), foliageMat);
            foliage.position.y = 4 + foliageH / 2;
            tg.add(foliage);
            tg.position.set(x, -0.5, z);
            return tg;
        }
        // Ring of trees around crash site
        for (var t = 0; t < 20; t++) {
            var angle = (t / 20) * Math.PI * 2;
            var dist = 35 + Math.random() * 15;
            survivalGroup.add(makeTree(Math.cos(angle) * dist, Math.sin(angle) * dist));
        }
        // Some closer trees
        survivalGroup.add(makeTree(20, 15));
        survivalGroup.add(makeTree(-22, 10));
        survivalGroup.add(makeTree(15, -18));

        // Fire glow (multiple lights for realism)
        var fireLight = new THREE.PointLight(0xff6600, 2, 30);
        fireLight.position.set(5, 2, -3);
        survivalGroup.add(fireLight);
        var fireLight2 = new THREE.PointLight(0xff4400, 1.5, 20);
        fireLight2.position.set(-6, 1.5, -7);
        survivalGroup.add(fireLight2);

        // Fire particles (mesh clusters)
        for (var f = 0; f < 12; f++) {
            var fireX = f < 8 ? 5 + (Math.random() - 0.5) * 4 : -6 + (Math.random() - 0.5) * 3;
            var fireZ = f < 8 ? -3 + (Math.random() - 0.5) * 4 : -7 + (Math.random() - 0.5) * 3;
            var flame = new THREE.Mesh(
                new THREE.ConeGeometry(0.3 + Math.random() * 0.5, 1 + Math.random() * 2, 6),
                new THREE.MeshBasicMaterial({
                    color: Math.random() < 0.3 ? 0xff2200 : (Math.random() < 0.6 ? 0xff6600 : 0xffaa00),
                    transparent: true, opacity: 0.8
                })
            );
            flame.position.set(fireX, 0.5 + Math.random(), fireZ);
            flame.userData.baseY = flame.position.y;
            flame.userData.flicker = Math.random() * Math.PI * 2;
            survivalGroup.add(flame);
        }

        // Smoke column (thicker, more realistic)
        for (var sm = 0; sm < 18; sm++) {
            var smokeR = 1.5 + sm * 0.3 + Math.random() * 1.5;
            var smoke = new THREE.Mesh(
                new THREE.SphereGeometry(smokeR, 6, 6),
                new THREE.MeshBasicMaterial({ color: sm < 6 ? 0x333333 : 0x1a1a1a, transparent: true, opacity: 0.35 - sm * 0.015 })
            );
            smoke.position.set(5 + (Math.random() - 0.5) * 3, 4 + sm * 2.5, -3 + (Math.random() - 0.5) * 3);
            survivalGroup.add(smoke);
        }

        // Emergency flashers on ground (scattered)
        for (var ef = 0; ef < 6; ef++) {
            var flasher = new THREE.Mesh(
                new THREE.SphereGeometry(0.1, 6, 6),
                new THREE.MeshBasicMaterial({ color: 0xff0000 })
            );
            flasher.position.set(-12 + ef * 6, 0.1, 10 + Math.sin(ef) * 3);
            flasher.userData.flashPhase = ef * 0.5;
            survivalGroup.add(flasher);
        }

        // ── Scattered papers / documents ──
        var paperMat = new THREE.MeshBasicMaterial({ color: 0xeeeedd, side: THREE.DoubleSide });
        for (var pp = 0; pp < 8; pp++) {
            var paper = new THREE.Mesh(new THREE.PlaneGeometry(0.15, 0.2), paperMat);
            paper.position.set((Math.random() - 0.5) * 20, 0.02 + Math.random() * 0.5, (Math.random() - 0.5) * 20);
            paper.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
            survivalGroup.add(paper);
        }

        survivalGroup.visible = false;
    }

    // ═══════════════════════════════════════════════════
    //  RAIN SYSTEM (2D canvas overlay)
    // ═══════════════════════════════════════════════════
    var rainCanvas = document.getElementById('rain-canvas');
    var rainCtx = rainCanvas.getContext('2d');
    var rainDrops = [];

    function initRain() {
        rainCanvas.width = window.innerWidth;
        rainCanvas.height = window.innerHeight;
        for (var i = 0; i < 200; i++) {
            rainDrops.push({
                x: Math.random() * rainCanvas.width,
                y: Math.random() * rainCanvas.height,
                len: 10 + Math.random() * 20,
                speed: 8 + Math.random() * 12,
                opacity: 0.1 + Math.random() * 0.3
            });
        }
    }

    function updateRain() {
        if (G.rainIntensity <= 0) return;
        rainCtx.clearRect(0, 0, rainCanvas.width, rainCanvas.height);
        for (var i = 0; i < rainDrops.length; i++) {
            var d = rainDrops[i];
            d.y += d.speed * G.rainIntensity;
            d.x -= 2 * G.rainIntensity;
            if (d.y > rainCanvas.height) { d.y = -d.len; d.x = Math.random() * rainCanvas.width; }
            if (d.x < 0) d.x = rainCanvas.width;
            rainCtx.beginPath();
            rainCtx.moveTo(d.x, d.y);
            rainCtx.lineTo(d.x + 1, d.y + d.len * G.rainIntensity);
            rainCtx.strokeStyle = 'rgba(180,200,220,' + (d.opacity * G.rainIntensity) + ')';
            rainCtx.lineWidth = 1;
            rainCtx.stroke();
        }
    }

    // ═══════════════════════════════════════════════════
    //  UI HELPERS
    // ═══════════════════════════════════════════════════
    var $phase = document.getElementById('phase-label');
    var $alt = document.getElementById('altitude-box');
    var $altVal = document.getElementById('alt-val');
    var $spdVal = document.getElementById('spd-val');
    var $hdgVal = document.getElementById('hdg-val');
    var $prompt = document.getElementById('prompt');
    var $sub = document.getElementById('sub-prompt');
    var $warning = document.getElementById('warning');
    var $fade = document.getElementById('fade');
    var $flash = document.getElementById('flash');
    var $eStrip = document.getElementById('emergency-strip');
    var $survival = document.getElementById('survival-text');
    var $continueBtn = document.getElementById('continue-btn');

    function showPrompt(text, dur) {
        $prompt.textContent = text;
        $prompt.classList.add('visible');
        if (dur) setTimeout(function() { $prompt.classList.remove('visible'); }, dur);
    }
    function hidePrompt() { $prompt.classList.remove('visible'); }

    function showSub(text) { $sub.textContent = text; $sub.classList.add('visible'); }
    function hideSub() { $sub.classList.remove('visible'); }


    function showWarning(text) { $warning.textContent = text; $warning.classList.add('visible'); }
    function hideWarning() { $warning.classList.remove('visible'); }

    function fadeIn(dur) {
        $fade.style.transition = 'opacity ' + (dur || 1.5) + 's ease';
        $fade.classList.add('visible');
    }
    function fadeOut(dur) {
        $fade.style.transition = 'opacity ' + (dur || 1.5) + 's ease';
        $fade.classList.remove('visible');
    }

    function doFlash(intensity, dur) {
        $flash.style.opacity = intensity || 0.9;
        $flash.style.transition = 'opacity ' + (dur || 0.5) + 's ease-out';
        setTimeout(function() { $flash.style.opacity = 0; }, 50);
    }

    function setPhaseLabel(txt) { $phase.textContent = txt; }

    function updateHUD() {
        $altVal.textContent = Math.max(0, Math.round(G.altitude)).toLocaleString();
        $spdVal.textContent = Math.round(G.speed);
        $hdgVal.textContent = Math.round(G.heading);
    }

    // ═══════════════════════════════════════════════════
    //  PHASE SYSTEM
    // ═══════════════════════════════════════════════════
    var phaseTimers = [];

    function clearPhaseTimers() {
        for (var i = 0; i < phaseTimers.length; i++) clearTimeout(phaseTimers[i]);
        phaseTimers = [];
    }

    function pt(fn, delay) {
        phaseTimers.push(setTimeout(fn, delay));
    }

    function goPhase(phase) {
        clearPhaseTimers();
        G.phase = phase;
        G.transitioning = true;

        switch (phase) {

        // ─── AIRPORT ───
        case 'airport':
            setPhaseLabel('Airport Terminal');
            document.body.classList.add('fp-mode');
            airportGroup.visible = true;
            planeExtGroup.visible = true;
            cabinGroup.visible = false;
            cloudGroup.visible = true;
            stormCloudGroup.visible = false;
            survivalGroup.visible = false;
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.FogExp2(0x87CEEB, 0.0008);
            // Camera inside terminal 2nd floor at gate 84, looking +X through windows
            camera.position.set(-8, 5.7, 5);
            cameraYaw = 0; cameraPitch = 0;
            G.cameraBasePos.copy(camera.position);
            showPrompt('Gate 84 — Now Boarding', 3500);
            pt(function() {
                showSub('Click to look around — WASD to walk — Board at Gate 84');
                G.canClick = false;
                G.transitioning = false;
            }, 1500);
            break;

        // ─── BOARDING ───
        case 'boarding':
            G.canClick = false;
            setPhaseLabel('Boarding');
            showPrompt('Boarding the aircraft...', 3000);
            hideSub();

            pt(function() {
                fadeIn(1.5);
            }, 2000);

            pt(function() {
                airportGroup.visible = false;
                planeExtGroup.visible = false;
                cabinGroup.visible = true;
                cloudGroup.visible = false;
                document.body.classList.add('fp-mode');

                // Standing in aisle at rear of cabin, looking forward (+Z)
                camera.position.set(0, 1.65, -9);
                camera.rotation.set(0, 0, 0);
                G.cameraBasePos.copy(camera.position);
                cameraYaw = 0; cameraPitch = 0;
                // Re-request pointer lock for cabin walking
                document.body.requestPointerLock();

                // Assign a specific seat and create a glowing marker
                var assignedRow = -11 + 1.5 + 12 * 0.80; // row 12
                G.seatTarget = new THREE.Vector3(1.35, 1.15, assignedRow);
                // Create pulsing seat marker
                if (seatMarker) cabinGroup.remove(seatMarker);
                seatMarker = new THREE.Group();
                // Floating arrow/diamond above the seat
                var markerGeo = new THREE.ConeGeometry(0.15, 0.3, 4);
                var markerMat = new THREE.MeshBasicMaterial({ color: 0x00ff88, transparent: true, opacity: 0.85 });
                var markerMesh = new THREE.Mesh(markerGeo, markerMat);
                markerMesh.rotation.x = Math.PI; // point downward
                markerMesh.position.y = 1.4;
                seatMarker.add(markerMesh);
                // Glowing ring on the seat cushion
                var ringGeo = new THREE.RingGeometry(0.18, 0.25, 16);
                var ringMat = new THREE.MeshBasicMaterial({ color: 0x00ff88, transparent: true, opacity: 0.7, side: THREE.DoubleSide });
                var ringMesh = new THREE.Mesh(ringGeo, ringMat);
                ringMesh.rotation.x = -Math.PI / 2;
                ringMesh.position.y = 0.52;
                seatMarker.add(ringMesh);
                // Vertical glow line
                var lineGeo = new THREE.BoxGeometry(0.02, 0.8, 0.02);
                var lineMesh = new THREE.Mesh(lineGeo, markerMat);
                lineMesh.position.y = 1.0;
                seatMarker.add(lineMesh);
                seatMarker.position.set(1.35, 0, assignedRow);
                cabinGroup.add(seatMarker);

                setCabinVolume(0.15);
                fadeOut(1.5);
            }, 4000);

            pt(function() {
                setPhaseLabel('Finding Your Seat');
                showPrompt('Find your marked seat', 2500);
            }, 5500);

            pt(function() {
                showSub('Click to look around — WASD to walk — Click green marker to sit');
                G.canClick = true;
                G.transitioning = false;
            }, 7000);
            break;

        // ─── SEATED ───
        case 'seated':
            G.canClick = false;
            setPhaseLabel('Seated');
            document.body.classList.add('fp-mode');

            // Animate to chosen seat (or default window seat)
            var seatTarget = G.seatTarget || new THREE.Vector3(1.35, 1.15, -2);
            animateCamera(seatTarget, 1500, function() {
                camera.position.copy(seatTarget);
                G.cameraBasePos.copy(camera.position);
                cameraYaw = -Math.PI / 2; cameraPitch = 0; // face window

                showPrompt('Please fasten your seatbelt.', 2500);
                playDing();
            });

            pt(function() {
                showSub('Press E to fasten seatbelt');
                G.canClick = true;
                G.transitioning = false;
            }, 4000);
            break;

        // ─── TAXI ───
        case 'taxi':
            G.canClick = false;
            setPhaseLabel('Taxiing');
            hideSub();

            showPrompt('Taxiing to runway...', 4000);
            G.shakeAmount = 0.002;
            setEngineVolume(0.15);

            pt(function() {
                showPrompt('Holding short of runway...', 3000);
            }, 8000);

            pt(function() {
                showPrompt('Cleared for takeoff.', 2500);
            }, 13000);

            pt(function() {
                G.transitioning = false;
                goPhase('takeoff');
            }, 18000);
            break;

        // ─── TAKEOFF ───
        case 'takeoff':
            setPhaseLabel('Takeoff');
            $alt.classList.add('visible');
            showPrompt('Prepare for takeoff...', 2500);
            G.speed = 0;
            airportGroup.visible = false;
            planeExtGroup.visible = false;

            setEngineVolume(0.5);

            var toAccel = setInterval(function() {
                G.speed += 3;
                G.shakeAmount = 0.001 + G.speed * 0.00004;
                setEngineVolume(Math.min(0.8, 0.3 + G.speed * 0.003));
                setWindVolume(Math.min(0.3, G.speed * 0.002));
                updateHUD();

                if (G.speed >= 165) {
                    clearInterval(toAccel);
                    showPrompt('Rotate...', 1500);
                    pt(function() { goPhase('climbing'); }, 1800);
                }
            }, 80);
            phaseTimers.push(toAccel);
            break;

        // ─── CLIMBING ───
        case 'climbing':
            setPhaseLabel('Climbing');
            showPrompt('Climbing to cruising altitude...', 3000);
            G.pitch = 5;
            cloudGroup.visible = true;
            airportGroup.visible = false;
            planeExtGroup.visible = false;

            var climbInt = setInterval(function() {
                G.altitude += 400;
                G.shakeAmount = Math.max(0.001, G.shakeAmount * 0.995);

                // Sky color transitions with altitude
                var f = Math.min(G.altitude / 35000, 1);
                var skyCol = new THREE.Color().lerpColors(
                    new THREE.Color(0x87CEEB),
                    new THREE.Color(0x1a3a6e),
                    f
                );
                scene.background = skyCol;
                scene.fog.color = skyCol;
                renderer.toneMappingExposure = 1.0 - f * 0.3;

                updateHUD();

                if (G.altitude >= 35000) {
                    clearInterval(climbInt);
                    G.pitch = 0;
                    goPhase('cruising');
                }
            }, 150);
            phaseTimers.push(climbInt);
            break;

        // ─── CRUISING ───
        case 'cruising':
            setPhaseLabel('Cruising — 35,000 ft');

            G.shakeAmount = 0.0004;
            G.speed = 480;

            showPrompt('You may now move about the cabin.', 3000);
            setEngineVolume(0.2);
            setWindVolume(0.15);
            setCabinVolume(0.2);


            pt(function() {
                showPrompt('Smooth skies ahead...', 3000);
            }, 12000);

            // Transition to turbulence
            pt(function() {
                G.transitioning = false;
                goPhase('turbulence_light');
            }, 18000);
            break;

        // ─── LIGHT TURBULENCE ───
        case 'turbulence_light':
            setPhaseLabel('Light Turbulence');

            playDing();


            var ltLevel = 0;
            var ltInt = setInterval(function() {
                ltLevel += 0.05;
                G.shakeAmount = 0.003 + ltLevel * 0.004;
                G.roll = Math.sin(G.time * 2) * ltLevel * 2;
            }, 200);
            phaseTimers.push(ltInt);

            pt(function() {
                clearInterval(ltInt);
                goPhase('storm');
            }, 8000);
            break;

        // ─── STORM ───
        case 'storm':
            setPhaseLabel('Severe Turbulence');

            // Darken sky
            scene.background = new THREE.Color(0x0a0a15);
            scene.fog = new THREE.FogExp2(0x0a0a15, 0.003);
            renderer.toneMappingExposure = 0.4;

            stormCloudGroup.visible = true;
            cloudGroup.visible = false;

            // Rain
            G.rainIntensity = 0.6;
            rainCanvas.classList.add('visible');

            // Dim cabin lights
            dimCabinLights(true);

            setEngineVolume(0.6);
            setWindVolume(0.5);

            showPrompt('Weather ahead...', 2000);

            var stormLevel = 0;
            var stormInt = setInterval(function() {
                stormLevel += 0.04;
                G.shakeAmount = 0.008 + stormLevel * 0.008;
                G.roll = Math.sin(G.time * 3) * stormLevel * 3;
                G.pitch = Math.sin(G.time * 1.5) * stormLevel;
                G.rainIntensity = Math.min(1.0, 0.6 + stormLevel * 0.2);
                setWindVolume(Math.min(0.8, 0.5 + stormLevel * 0.1));
            }, 200);
            phaseTimers.push(stormInt);

            // Lightning strikes
            pt(function() { triggerLightning(); }, 3000);
            pt(function() { triggerLightning(); }, 5500);
            pt(function() { triggerLightning(); }, 7000);
            pt(function() { triggerLightning(); }, 8200);
            pt(function() { triggerLightning(); triggerLightning(); }, 9500);


            pt(function() {
                clearInterval(stormInt);
                goPhase('lightning_intense');
            }, 12000);
            break;

        // ─── INTENSE LIGHTNING ───
        case 'lightning_intense':
            setPhaseLabel('⚡ Electrical Storm');

            G.shakeAmount = 0.03;
            G.rainIntensity = 1.0;
            setWindVolume(0.9);
            setEngineVolume(0.8);

            // Rapid lightning
            var lnCount = 0;
            var lnInt = setInterval(function() {
                triggerLightning();
                lnCount++;
                G.shakeAmount = 0.03 + Math.random() * 0.02;
                G.roll = (Math.random() - 0.5) * 8;
                G.pitch = (Math.random() - 0.5) * 3;

                // Altitude drops
                G.altitude -= 200 + Math.random() * 300;
                updateHUD();
            }, 800);
            phaseTimers.push(lnInt);

            pt(function() {
                showPrompt('', 100);
                showWarning('SEVERE TURBULENCE');
            }, 1000);

            pt(function() {
                hideWarning();
            }, 3000);

            // Big lightning hit
            pt(function() {
                clearInterval(lnInt);
                doFlash(1.0, 0.8);
                playThunder();
                G.shakeAmount = 0.08;
                showWarning('⚡ LIGHTNING STRIKE');

                // Brief power flicker
                flickerCabinLights();
            }, 6000);

            pt(function() {
                hideWarning();
                goPhase('emergency');
            }, 8500);
            break;

        // ─── EMERGENCY ───
        case 'emergency':
            setPhaseLabel('🔴 EMERGENCY');
            $phase.style.background = 'rgba(200,0,0,0.8)';
            playAlarm();

            // Systems failing
            showWarning('BRACE FOR IMPACT');

            // Drop oxygen masks
            dropOxygenMasks();

            // Emergency lights
            G.emergencyLights = true;
            $eStrip.classList.add('visible');
            for (var i = 0; i < emergencyLightMeshes.length; i++) {
                emergencyLightMeshes[i].visible = true;
            }

            // Kill main cabin lights
            setCabinLightsPower(false);

            G.shakeAmount = 0.06;
            G.rainIntensity = 1.0;
            setWindVolume(1.0);


            // Rapid descent
            var descInt = setInterval(function() {
                G.altitude -= 1500;
                G.speed += 5;
                G.shakeAmount = 0.05 + (35000 - Math.max(0, G.altitude)) / 35000 * 0.08;
                G.pitch = -8 - (35000 - Math.max(0, G.altitude)) / 35000 * 10;

                // Sky changes during descent
                var descF = Math.max(0, G.altitude) / 35000;
                scene.background.lerpColors(
                    new THREE.Color(0x1a0a0a),
                    new THREE.Color(0x0a0a15),
                    descF
                );

                updateHUD();

                if (G.altitude <= 0) {
                    clearInterval(descInt);
                    goPhase('crash');
                }
            }, 100);
            phaseTimers.push(descInt);
            break;

        // ─── CRASH ───
        case 'crash':
            G.altitude = 0;
            G.speed = 0;
            setPhaseLabel('IMPACT');

            playImpact();
            doFlash(1.0, 0.3);
            G.shakeAmount = 0.15;

            setEngineVolume(0);
            setWindVolume(0);
            setCabinVolume(0);

            showWarning('');
            hideWarning();

            // Violent shake then fade
            pt(function() {
                G.shakeAmount = 0.08;
            }, 500);

            pt(function() {
                G.shakeAmount = 0.03;
                fadeIn(2);
            }, 1500);

            pt(function() {
                G.shakeAmount = 0;
                goPhase('survival');
            }, 4000);
            break;

        // ─── SURVIVAL ───
        case 'survival':
            setPhaseLabel('');
            $alt.classList.remove('visible');

            $eStrip.classList.remove('visible');
            hideWarning();
            hideSub();
            $phase.style.background = '';
            G.rainIntensity = 0.3;

            cabinGroup.visible = false;
            cloudGroup.visible = false;
            stormCloudGroup.visible = false;
            airportGroup.visible = false;
            survivalGroup.visible = true;

            scene.background = new THREE.Color(0x050508);
            scene.fog = new THREE.FogExp2(0x050508, 0.02);
            renderer.toneMappingExposure = 0.5;
            ambientLight.intensity = 0.15;

            camera.position.set(0, 1.7, 15);
            camera.lookAt(new THREE.Vector3(5, 1, -3));
            G.cameraBasePos.copy(camera.position);
            G.shakeAmount = 0;

            fadeOut(3);

            pt(function() {
                $survival.innerHTML = 'You survived.';
                $survival.classList.add('visible');
            }, 3000);

            pt(function() {
                $survival.classList.remove('visible');
            }, 6000);

            pt(function() {
                $survival.innerHTML =
                    'In reality, 95.7% of passengers survive plane crashes.<br><br>' +
                    'Flying remains the safest form of long-distance travel.<br><br>' +
                    'Your chances of being in a fatal crash are<br><b style="font-size:2rem">1 in 13,700,000</b>';
                $survival.classList.add('visible');
            }, 7500);

            pt(function() {
                $continueBtn.classList.add('visible');
            }, 12000);
            break;
        }
    }

    // ═══════════════════════════════════════════════════
    //  CABIN LIGHT CONTROLS
    // ═══════════════════════════════════════════════════
    function dimCabinLights(dim) {
        G.cabinLightsDim = dim;
        var targetIntensity = dim ? 0.1 : 0.4;
        for (var i = 0; i < cabinLights.length; i++) {
            cabinLights[i].intensity = targetIntensity;
        }
        for (var j = 0; j < cabinLightMeshes.length; j++) {
            cabinLightMeshes[j].material = dim ? MAT.lightEmitDim : MAT.lightEmit;
        }
    }

    function setCabinLightsPower(on) {
        G.cabinLightsOn = on;
        for (var i = 0; i < cabinLights.length; i++) {
            cabinLights[i].intensity = on ? 0.1 : 0;
        }
        for (var j = 0; j < cabinLightMeshes.length; j++) {
            cabinLightMeshes[j].visible = on;
        }
    }

    function flickerCabinLights() {
        var count = 0;
        var flickInt = setInterval(function() {
            count++;
            var on = count % 2 === 0;
            for (var i = 0; i < cabinLights.length; i++) {
                cabinLights[i].intensity = on ? 0.15 : 0;
            }
            for (var j = 0; j < cabinLightMeshes.length; j++) {
                cabinLightMeshes[j].visible = on;
            }
            if (count > 8) {
                clearInterval(flickInt);
                dimCabinLights(true);
            }
        }, 100);
    }

    // ═══════════════════════════════════════════════════
    //  LIGHTNING EFFECT
    // ═══════════════════════════════════════════════════
    function triggerLightning() {
        doFlash(0.6 + Math.random() * 0.4, 0.3 + Math.random() * 0.4);
        playThunder();

        // Create lightning bolt geometry in scene
        var bolt = createLightningBolt();
        lightningGroup.add(bolt);
        setTimeout(function() { lightningGroup.remove(bolt); }, 200);
    }

    function createLightningBolt() {
        var points = [];
        var x = (Math.random() - 0.5) * 100;
        var z = (Math.random() - 0.5) * 100;
        var y = 50 + Math.random() * 30;
        for (var i = 0; i < 10; i++) {
            points.push(new THREE.Vector3(
                x + (Math.random() - 0.5) * 10,
                y - i * (y / 10),
                z + (Math.random() - 0.5) * 10
            ));
        }
        var geo = new THREE.BufferGeometry().setFromPoints(points);
        var mat = new THREE.LineBasicMaterial({ color: 0xeeeeff, linewidth: 2 });
        return new THREE.Line(geo, mat);
    }

    // ═══════════════════════════════════════════════════
    //  OXYGEN MASKS
    // ═══════════════════════════════════════════════════
    function dropOxygenMasks() {
        var positions = ['25%', '40%', '55%', '70%'];
        for (var i = 0; i < positions.length; i++) {
            (function(idx) {
                pt(function() {
                    var mask = document.createElement('div');
                    mask.className = 'oxygen-mask';
                    mask.style.left = positions[idx];
                    mask.style.top = '-100px';
                    mask.innerHTML = '<div class="mask-tube"></div><div class="mask-cup"></div>';
                    document.body.appendChild(mask);

                    setTimeout(function() {
                        mask.style.opacity = '1';
                        mask.style.transform = 'translateY(200px)';
                    }, 50);
                }, idx * 150);
            })(i);
        }
    }

    // ═══════════════════════════════════════════════════
    //  CAMERA ANIMATION HELPER
    // ═══════════════════════════════════════════════════
    function animateCamera(target, duration, callback) {
        var start = camera.position.clone();
        var startTime = performance.now();
        function step(now) {
            var t = Math.min((now - startTime) / duration, 1);
            t = t * t * (3 - 2 * t); // smoothstep
            camera.position.lerpVectors(start, target, t);
            if (t < 1) {
                requestAnimationFrame(step);
            } else {
                if (callback) callback();
            }
        }
        requestAnimationFrame(step);
    }

    // ═══════════════════════════════════════════════════
    //  INPUT — Pointer-lock camera (darkness-style)
    // ═══════════════════════════════════════════════════
    var audioStarted = false;
    var cameraYaw = 0;
    var cameraPitch = 0;
    var pointerLocked = false;

    document.addEventListener('pointerlockchange', function() {
        pointerLocked = document.pointerLockElement !== null;
    });

    // ── Keyboard state for WASD walking ──
    var keys = { w: false, a: false, s: false, d: false };
    function handleKey(e, val) {
        var k = e.key ? e.key.toLowerCase() : '';
        var c = e.code || '';
        if (k === 'w' || c === 'KeyW' || k === 'arrowup' || c === 'ArrowUp') { keys.w = val; e.preventDefault(); }
        if (k === 'a' || c === 'KeyA' || k === 'arrowleft' || c === 'ArrowLeft') { keys.a = val; e.preventDefault(); }
        if (k === 's' || c === 'KeyS' || k === 'arrowdown' || c === 'ArrowDown') { keys.s = val; e.preventDefault(); }
        if (k === 'd' || c === 'KeyD' || k === 'arrowright' || c === 'ArrowRight') { keys.d = val; e.preventDefault(); }
    }
    window.addEventListener('keydown', function(e) {
        handleKey(e, true);
        // Press E to fasten seatbelt when seated
        if ((e.key === 'e' || e.key === 'E' || e.code === 'KeyE') && G.phase === 'seated' && G.canClick && !G.transitioning) {
            G.canClick = false;
            G.transitioning = true;
            hideSub();
            showPrompt('Seatbelt fastened.', 2000);
            playDing();
            pt(function() { goPhase('taxi'); }, 2500);
        }
    });
    window.addEventListener('keyup', function(e) { handleKey(e, false); });

    document.addEventListener('click', function() {
        // Ensure this window has keyboard focus
        window.focus();
        if (!audioStarted) {
            initAudio();
            audioStarted = true;
        }

        // Request pointer lock for FPS-style mouselook
        if (!pointerLocked && (G.phase === 'airport' || G.phase === 'boarding')) {
            document.body.requestPointerLock();
            return;
        }

        if (G.transitioning) return;
        if (!G.canClick) return;

        switch (G.phase) {
            case 'boarding':
                // Sit at the pre-assigned marked seat
                // Remove seat marker
                if (seatMarker) {
                    cabinGroup.remove(seatMarker);
                    seatMarker = null;
                }
                goPhase('seated');
                break;
        }
    });

    document.addEventListener('mousemove', function(e) {
        G.mouseX = e.clientX;
        G.mouseY = e.clientY;
        if (!pointerLocked) return;
        if (G.phase === 'airport' || G.phase === 'boarding') {
            // Pointer-lock delta-based FPS mouselook
            cameraYaw -= e.movementX * 0.002;
            cameraPitch -= e.movementY * 0.002;
            cameraPitch = Math.max(-Math.PI / 2.5, Math.min(Math.PI / 2.5, cameraPitch));
        } else if (['seated', 'taxi', 'takeoff', 'climbing', 'cruising'].indexOf(G.phase) !== -1) {
            // Still allow mouse look when seated (limited range)
            cameraYaw -= e.movementX * 0.002;
            cameraPitch -= e.movementY * 0.002;
            cameraPitch = Math.max(-Math.PI / 4, Math.min(Math.PI / 4, cameraPitch));
        }
    });

    // Continue button → back to parent
    $continueBtn.addEventListener('click', function() {
        if (window.parent !== window) {
            window.parent.postMessage('simulation-complete', '*');
        }
    });

    // ═══════════════════════════════════════════════════
    //  MAIN ANIMATION LOOP
    // ═══════════════════════════════════════════════════
    var clock = new THREE.Clock();

    function animate() {
        requestAnimationFrame(animate);
        G.delta = Math.min(clock.getDelta(), 0.1);
        G.time += G.delta;

        // ── Update window views based on altitude ──
        updateSkyView();

        // ── Camera shake ──
        if (G.shakeAmount > 0.0001) {
            camera.position.x = G.cameraBasePos.x + (Math.random() - 0.5) * G.shakeAmount * 2;
            camera.position.y = G.cameraBasePos.y + (Math.random() - 0.5) * G.shakeAmount * 2;
            camera.position.z = G.cameraBasePos.z + (Math.random() - 0.5) * G.shakeAmount;
            camera.rotation.z = (Math.random() - 0.5) * G.shakeAmount * 0.4;
        }

        // ── Phase-specific camera (pointer-lock FPS style) ──
        camera.rotation.order = 'YXZ';

        if (G.phase === 'airport') {
            // ── WASD Walking (quaternion-based like darkness experience) ──
            var walkSpeed = 5.0 * G.delta;
            if (pointerLocked) {
                var dir = new THREE.Vector3();
                if (keys.w) dir.z -= 1;
                if (keys.s) dir.z += 1;
                if (keys.a) dir.x -= 1;
                if (keys.d) dir.x += 1;
                dir.normalize();
                if (dir.length() > 0) {
                    var fwd = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
                    fwd.y = 0; fwd.normalize();
                    var right = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
                    right.y = 0; right.normalize();
                    camera.position.addScaledVector(fwd, -dir.z * walkSpeed);
                    camera.position.addScaledVector(right, dir.x * walkSpeed);
                }
            }

            // Keep Y at eye height on 2nd floor
            camera.position.y = 5.7;

            // ── Bounds: terminal interior OR gate 84 jet bridge ──
            var px = camera.position.x;
            var pz = camera.position.z;
            var inTerminal = (px >= -20 && px <= 2 && pz >= -50 && pz <= 50);
            var inBridge = (px > 2 && px <= 16 && pz >= 3.5 && pz <= 6.5);

            if (!inTerminal && !inBridge) {
                if (px > 2) {
                    if (pz >= 3.5 && pz <= 6.5) {
                        camera.position.x = Math.min(16, px);
                    } else {
                        camera.position.x = 2;
                        camera.position.z = Math.max(-50, Math.min(50, pz));
                    }
                } else {
                    camera.position.x = Math.max(-20, Math.min(2, px));
                    camera.position.z = Math.max(-50, Math.min(50, pz));
                }
            }
            if (camera.position.x > 2) {
                camera.position.z = Math.max(3.5, Math.min(6.5, camera.position.z));
            }

            // ── Auto-board when reaching end of jet bridge ──
            if (camera.position.x >= 15 && !G.transitioning) {
                G.transitioning = true;
                goPhase('boarding');
            }

            G.cameraBasePos.copy(camera.position);

            // ── Look direction from pointer lock ──
            camera.rotation.y = cameraYaw;
            camera.rotation.x = cameraPitch;
        }
        if (G.phase === 'boarding') {
            // ── WASD Walking inside cabin (quaternion-based) ──
            var cabinWalkSpeed = 3.0 * G.delta;
            if (pointerLocked) {
                var cDir = new THREE.Vector3();
                if (keys.w) cDir.z -= 1;
                if (keys.s) cDir.z += 1;
                if (keys.a) cDir.x -= 1;
                if (keys.d) cDir.x += 1;
                cDir.normalize();
                if (cDir.length() > 0) {
                    var cFwd = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
                    cFwd.y = 0; cFwd.normalize();
                    var cRight = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
                    cRight.y = 0; cRight.normalize();
                    camera.position.addScaledVector(cFwd, -cDir.z * cabinWalkSpeed);
                    camera.position.addScaledVector(cRight, cDir.x * cabinWalkSpeed);
                }
            }
            // Cabin bounds
            camera.position.x = Math.max(-1.8, Math.min(1.8, camera.position.x));
            camera.position.z = Math.max(-10, Math.min(10, camera.position.z));
            camera.position.y = 1.65;
            G.cameraBasePos.copy(camera.position);

            // Look direction from pointer lock
            camera.rotation.y = cameraYaw;
            camera.rotation.x = cameraPitch;
        }
        if (G.phase === 'seated' || G.phase === 'taxi' || G.phase === 'takeoff' ||
            G.phase === 'climbing') {
            // Free look around cabin via pointer lock
            camera.rotation.y = cameraYaw;
            camera.rotation.x = cameraPitch;
        }
        if (['cruising', 'turbulence_light', 'storm', 'lightning_intense', 'emergency'].indexOf(G.phase) !== -1) {
            // Looking out window with subtle drift + pointer lock adjustment
            camera.rotation.y = -Math.PI / 2 + Math.sin(G.time * 0.15) * 0.02 + (cameraYaw + Math.PI / 2) * 0.4;
            camera.rotation.x = cameraPitch * 0.3 + G.pitch * 0.01;
            camera.rotation.z += G.roll * 0.005;
        }
        if (G.phase === 'crash') {
            camera.rotation.y = -Math.PI / 2;
            camera.rotation.x = G.pitch * 0.015;
        }
        if (G.phase === 'survival') {
            camera.rotation.y = Math.PI * 0.05 + Math.sin(G.time * 0.1) * 0.02 + cameraYaw * 0.2;
            camera.rotation.x = -0.05 + cameraPitch * 0.15;
        }

        // ── Animate seat marker (pulsing) ──
        if (seatMarker && G.phase === 'boarding') {
            var pulse = 0.6 + 0.4 * Math.sin(G.time * 4);
            seatMarker.children[0].position.y = 1.3 + Math.sin(G.time * 3) * 0.1; // bob up/down
            seatMarker.children[0].material.opacity = pulse;
            seatMarker.children[1].material.opacity = pulse * 0.8;
            seatMarker.children[2].material.opacity = pulse * 0.6;
        }

        // ── Animate engine fans ──
        var fanSpeed = G.phase === 'airport' ? 2 : (G.speed > 0 ? 15 + G.speed * 0.05 : 0);
        for (var ef = 0; ef < engineFans.length; ef++) {
            engineFans[ef].rotation.z += fanSpeed * G.delta;
        }

        // ── Animate clouds ──
        var cSpeed = G.speed * 0.08;
        cloudGroup.children.forEach(function(c) {
            c.position.x -= c.userData.speed * G.delta * cSpeed;
            if (c.position.x < -300) {
                c.position.x = 300;
                c.position.z = (Math.random() - 0.5) * 600;
            }
        });
        stormCloudGroup.children.forEach(function(c) {
            c.position.x -= c.userData.speed * G.delta * cSpeed * 0.5;
            if (c.position.x < -250) {
                c.position.x = 250;
                c.position.z = (Math.random() - 0.5) * 500;
            }
        });

        // ── Emergency light flashing ──
        if (G.emergencyLights) {
            var emOn = Math.sin(G.time * 6) > 0;
            for (var el = 0; el < emergencyLightMeshes.length; el++) {
                emergencyLightMeshes[el].visible = (el + (emOn ? 0 : 1)) % 2 === 0;
            }
        }

        // ── Survival fire flicker ──
        if (G.phase === 'survival') {
            survivalGroup.children.forEach(function(child) {
                if (child.userData.flicker !== undefined) {
                    child.userData.flicker += G.delta * 5;
                    child.position.y = child.userData.baseY + Math.sin(child.userData.flicker) * 0.2;
                    child.scale.x = 0.8 + Math.sin(child.userData.flicker * 1.3) * 0.3;
                }
                if (child.userData.flashPhase !== undefined) {
                    child.visible = Math.sin(G.time * 4 + child.userData.flashPhase) > 0.3;
                }
            });
        }

        // ── Rain ──
        updateRain();

        // ── Render ──
        renderer.render(scene, camera);
    }

    // ═══════════════════════════════════════════════════
    //  WINDOW RESIZE
    // ═══════════════════════════════════════════════════
    window.addEventListener('resize', function() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        rainCanvas.width = window.innerWidth;
        rainCanvas.height = window.innerHeight;
    });

    // ═══════════════════════════════════════════════════
    //  INIT & START
    // ═══════════════════════════════════════════════════
    buildAirport();
    buildCabin();
    populateClouds();
    populateStormClouds();
    buildSurvivalScene();
    initRain();

    // Start
    fadeOut(2);
    pt(function() { goPhase('airport'); }, 500);

    animate();

    })();
    </script>
</body>
</html>
