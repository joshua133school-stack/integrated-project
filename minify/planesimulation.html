<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flight Experience - FAAH</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; background: #000; font-family: 'Georgia', serif; cursor: default; }
        canvas { display: block; }

        /* HUD */
        #hud {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 10;
        }
        #hud > * { pointer-events: auto; }

        #phase-label {
            position: fixed; top: 20px; left: 20px;
            color: #fff; font-size: 14px; z-index: 20;
            background: rgba(0,0,0,0.5); padding: 8px 16px; border-radius: 6px;
            text-transform: uppercase; letter-spacing: 2px;
            pointer-events: none;
        }
        #altitude-box {
            position: fixed; top: 20px; right: 20px;
            color: #fff; font-size: 13px; z-index: 20;
            background: rgba(0,0,0,0.5); padding: 8px 16px; border-radius: 6px;
            font-family: 'Courier New', monospace;
            opacity: 0; transition: opacity 0.8s;
            pointer-events: none;
        }
        #altitude-box.visible { opacity: 1; }

        #prompt {
            position: fixed; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: #fff; font-size: 1.6rem; text-align: center;
            pointer-events: none; z-index: 30;
            opacity: 0; transition: opacity 1s ease;
            text-shadow: 0 2px 20px rgba(0,0,0,0.8);
            max-width: 80%; line-height: 1.6;
        }
        #prompt.visible { opacity: 1; }

        #sub-prompt {
            position: fixed; bottom: 10%; left: 50%;
            transform: translateX(-50%);
            color: rgba(255,255,255,0.7); font-size: 0.95rem; text-align: center;
            pointer-events: none; z-index: 30;
            opacity: 0; transition: opacity 0.8s ease;
            text-shadow: 0 1px 10px rgba(0,0,0,0.8);
            background: rgba(0,0,0,0.35); padding: 10px 24px; border-radius: 8px;
        }
        #sub-prompt.visible { opacity: 1; }

        /* Seatbelt sign */
        #seatbelt-sign {
            position: fixed; top: 75px; left: 50%; transform: translateX(-50%);
            background: linear-gradient(145deg, #ff4444, #cc0000);
            color: #fff; padding: 10px 22px; border-radius: 6px;
            font-size: 0.95rem; z-index: 25;
            opacity: 0; transition: opacity 0.4s;
            box-shadow: 0 0 25px rgba(255,0,0,0.4);
            letter-spacing: 2px; text-transform: uppercase;
            pointer-events: none;
        }
        #seatbelt-sign.visible { opacity: 1; animation: pulse-sign 1.2s infinite; }
        @keyframes pulse-sign {
            0%,100% { box-shadow: 0 0 25px rgba(255,0,0,0.4); }
            50% { box-shadow: 0 0 45px rgba(255,0,0,0.8); }
        }

        /* Captain announcement */
        #captain-box {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%,-50%);
            background: rgba(0,0,0,0.85); color: #fff;
            padding: 30px 50px; border-radius: 12px;
            font-size: 1.1rem; z-index: 35;
            opacity: 0; transition: opacity 0.6s;
            max-width: 600px; text-align: center; line-height: 1.8;
            border: 1px solid rgba(255,255,255,0.1);
            pointer-events: none;
        }
        #captain-box.visible { opacity: 1; }
        #captain-box .captain-label {
            font-size: 0.75rem; letter-spacing: 3px; text-transform: uppercase;
            color: rgba(255,255,255,0.4); margin-bottom: 12px;
        }

        /* Fade overlay */
        #fade {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 50; opacity: 0;
            pointer-events: none; transition: opacity 1.5s ease;
        }
        #fade.visible { opacity: 1; pointer-events: all; }

        /* Flash (lightning) */
        #flash {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #fff; z-index: 40; opacity: 0;
            pointer-events: none;
        }

        /* Warning */
        #warning {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%,-50%);
            color: #ff4444; font-size: 2.2rem; z-index: 45;
            opacity: 0; transition: opacity 0.4s;
            text-shadow: 0 0 40px rgba(255,0,0,0.6);
            text-align: center; font-weight: bold;
            letter-spacing: 3px; pointer-events: none;
        }
        #warning.visible { opacity: 1; }

        /* Continue button */
        #continue-btn {
            position: fixed; bottom: 25%; left: 50%; transform: translateX(-50%);
            background: rgba(255,255,255,0.9); color: #222;
            border: none; padding: 14px 44px; font-size: 1.1rem;
            font-family: 'Georgia', serif; cursor: pointer;
            z-index: 55; border-radius: 8px;
            opacity: 0; transition: opacity 0.6s;
            pointer-events: none;
        }
        #continue-btn.visible { opacity: 1; pointer-events: auto; }
        #continue-btn:hover { background: #fff; transform: translateX(-50%) scale(1.05); }

        /* Oxygen masks */
        .oxygen-mask {
            position: fixed; z-index: 32; pointer-events: none;
            width: 40px; opacity: 0;
            transition: transform 1.2s cubic-bezier(0.2,0.8,0.3,1), opacity 0.3s;
        }
        .oxygen-mask .mask-tube {
            width: 3px; height: 60px; background: #888; margin: 0 auto;
        }
        .oxygen-mask .mask-cup {
            width: 36px; height: 28px; background: linear-gradient(145deg, #ffcc00, #e6a800);
            border-radius: 0 0 18px 18px; margin: 0 auto;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        /* Emergency lights */
        .emergency-strip {
            position: fixed; bottom: 0; left: 0; width: 100%; height: 4px;
            z-index: 31; opacity: 0; transition: opacity 0.5s;
            pointer-events: none;
        }
        .emergency-strip.visible {
            opacity: 1;
            background: repeating-linear-gradient(90deg, #00ff00 0px, #00ff00 30px, transparent 30px, transparent 60px);
            animation: floor-lights 1s linear infinite;
        }
        @keyframes floor-lights {
            0% { background-position: 0 0; }
            100% { background-position: 60px 0; }
        }

        /* Rain overlay on window */
        #rain-canvas {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 5; pointer-events: none; opacity: 0;
            transition: opacity 1s;
        }
        #rain-canvas.visible { opacity: 1; }

        /* Survival scene text */
        #survival-text {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%,-50%);
            color: #fff; font-size: 1.4rem; text-align: center;
            z-index: 55; opacity: 0; transition: opacity 1s;
            max-width: 80%; line-height: 2;
            pointer-events: none;
        }
        #survival-text.visible { opacity: 1; }
    </style>
</head>
<body>
    <div id="hud">
        <div id="phase-label">Airport Terminal</div>
        <div id="altitude-box">
            ALT <span id="alt-val">0</span> ft<br>
            SPD <span id="spd-val">0</span> kts<br>
            HDG <span id="hdg-val">270</span>°
        </div>
        <div id="seatbelt-sign">⚠ Fasten Seatbelt</div>
    </div>

    <div id="prompt"></div>
    <div id="sub-prompt"></div>
    <div id="captain-box"><div class="captain-label"></div><div id="captain-text"></div></div>
    <div id="warning"></div>
    <div id="fade"></div>
    <div id="flash"></div>
    <div class="emergency-strip" id="emergency-strip"></div>
    <canvas id="rain-canvas"></canvas>
    <div id="survival-text"></div>
    <button id="continue-btn">Continue</button>

    <script src="https://cdn.jsdelivr.net/npm/three@0.152.0/build/three.min.js"></script>
    <script>
    (function() {
    'use strict';

    // ═══════════════════════════════════════════════════
    //  RENDERER & SCENE
    // ═══════════════════════════════════════════════════
    var renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.0;
    document.body.appendChild(renderer.domElement);

    var scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x87CEEB, 0.0008);

    var camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 5000);

    // ═══════════════════════════════════════════════════
    //  GAME STATE
    // ═══════════════════════════════════════════════════
    var G = {
        phase: 'airport',
        time: 0,
        delta: 0,
        altitude: 0,
        speed: 0,
        heading: 270,
        pitch: 0,
        roll: 0,
        shakeAmount: 0,
        shakeDecay: 0.95,
        cameraBasePos: new THREE.Vector3(),
        cameraBaseRot: new THREE.Euler(),
        lookX: 0, lookY: 0,
        targetLookX: 0, targetLookY: 0,
        mouseX: 0, mouseY: 0,
        canClick: true,
        transitioning: false,
        lightningTimer: 0,
        rainIntensity: 0,
        emergencyLights: false,
        cabinLightsOn: true,
        cabinLightsDim: false
    };

    // ═══════════════════════════════════════════════════
    //  WEB AUDIO - PROCEDURAL SOUND ENGINE
    // ═══════════════════════════════════════════════════
    var audioCtx = null;
    var masterGain = null;
    var engineNode = null, engineGain = null;
    var windNode = null, windGain = null;
    var cabinNode = null, cabinGain = null;

    function initAudio() {
        try {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            masterGain = audioCtx.createGain();
            masterGain.gain.value = 0.3;
            masterGain.connect(audioCtx.destination);

            // Engine rumble (low-frequency noise)
            var bufferSize = 2 * audioCtx.sampleRate;
            engineNode = audioCtx.createBufferSource();
            var engineBuffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            var engineData = engineBuffer.getChannelData(0);
            for (var i = 0; i < bufferSize; i++) {
                engineData[i] = (Math.random() * 2 - 1) * 0.3;
            }
            engineNode.buffer = engineBuffer;
            engineNode.loop = true;

            var engineFilter = audioCtx.createBiquadFilter();
            engineFilter.type = 'lowpass';
            engineFilter.frequency.value = 120;
            engineFilter.Q.value = 1;

            engineGain = audioCtx.createGain();
            engineGain.gain.value = 0;
            engineNode.connect(engineFilter);
            engineFilter.connect(engineGain);
            engineGain.connect(masterGain);
            engineNode.start();

            // Wind noise (high-frequency shaped noise)
            windNode = audioCtx.createBufferSource();
            var windBuffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            var windData = windBuffer.getChannelData(0);
            for (var j = 0; j < bufferSize; j++) {
                windData[j] = (Math.random() * 2 - 1);
            }
            windNode.buffer = windBuffer;
            windNode.loop = true;

            var windFilter = audioCtx.createBiquadFilter();
            windFilter.type = 'bandpass';
            windFilter.frequency.value = 800;
            windFilter.Q.value = 0.5;

            windGain = audioCtx.createGain();
            windGain.gain.value = 0;
            windNode.connect(windFilter);
            windFilter.connect(windGain);
            windGain.connect(masterGain);
            windNode.start();

            // Cabin ambience (very low noise)
            cabinNode = audioCtx.createBufferSource();
            var cabinBuffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            var cabinData = cabinBuffer.getChannelData(0);
            var prev = 0;
            for (var k = 0; k < bufferSize; k++) {
                prev = prev * 0.99 + (Math.random() * 2 - 1) * 0.01;
                cabinData[k] = prev * 3;
            }
            cabinNode.buffer = cabinBuffer;
            cabinNode.loop = true;

            cabinGain = audioCtx.createGain();
            cabinGain.gain.value = 0;
            cabinNode.connect(cabinGain);
            cabinGain.connect(masterGain);
            cabinNode.start();

        } catch(e) { /* Audio not available */ }
    }

    function setEngineVolume(v) {
        if (engineGain) engineGain.gain.linearRampToValueAtTime(v, audioCtx.currentTime + 0.5);
    }
    function setWindVolume(v) {
        if (windGain) windGain.gain.linearRampToValueAtTime(v, audioCtx.currentTime + 0.5);
    }
    function setCabinVolume(v) {
        if (cabinGain) cabinGain.gain.linearRampToValueAtTime(v, audioCtx.currentTime + 0.3);
    }

    function playThunder() {
        if (!audioCtx) return;
        var osc = audioCtx.createOscillator();
        var g = audioCtx.createGain();
        var filter = audioCtx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 200;

        var buf = audioCtx.createBuffer(1, audioCtx.sampleRate * 2, audioCtx.sampleRate);
        var d = buf.getChannelData(0);
        for (var i = 0; i < d.length; i++) d[i] = (Math.random() * 2 - 1);
        var noise = audioCtx.createBufferSource();
        noise.buffer = buf;

        g.gain.setValueAtTime(0.8, audioCtx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 2.5);

        noise.connect(filter);
        filter.connect(g);
        g.connect(masterGain);
        noise.start();
        noise.stop(audioCtx.currentTime + 2.5);
    }

    function playDing() {
        if (!audioCtx) return;
        var osc = audioCtx.createOscillator();
        var g = audioCtx.createGain();
        osc.type = 'sine';
        osc.frequency.value = 1200;
        g.gain.setValueAtTime(0.15, audioCtx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.8);
        osc.connect(g);
        g.connect(masterGain);
        osc.start();
        osc.stop(audioCtx.currentTime + 0.8);
        // Second tone
        setTimeout(function() {
            if (!audioCtx) return;
            var o2 = audioCtx.createOscillator();
            var g2 = audioCtx.createGain();
            o2.type = 'sine'; o2.frequency.value = 900;
            g2.gain.setValueAtTime(0.12, audioCtx.currentTime);
            g2.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.6);
            o2.connect(g2); g2.connect(masterGain);
            o2.start(); o2.stop(audioCtx.currentTime + 0.6);
        }, 300);
    }

    function playAlarm() {
        if (!audioCtx) return;
        var osc = audioCtx.createOscillator();
        var g = audioCtx.createGain();
        osc.type = 'square';
        osc.frequency.setValueAtTime(600, audioCtx.currentTime);
        g.gain.setValueAtTime(0.2, audioCtx.currentTime);
        for (var i = 0; i < 10; i++) {
            osc.frequency.setValueAtTime(600, audioCtx.currentTime + i * 0.4);
            osc.frequency.setValueAtTime(400, audioCtx.currentTime + i * 0.4 + 0.2);
        }
        g.gain.setValueAtTime(0.2, audioCtx.currentTime + 3.8);
        g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 4);
        osc.connect(g); g.connect(masterGain);
        osc.start(); osc.stop(audioCtx.currentTime + 4);
    }

    function playImpact() {
        if (!audioCtx) return;
        var buf = audioCtx.createBuffer(1, audioCtx.sampleRate, audioCtx.sampleRate);
        var d = buf.getChannelData(0);
        for (var i = 0; i < d.length; i++) d[i] = (Math.random() * 2 - 1) * Math.exp(-i / (audioCtx.sampleRate * 0.15));
        var src = audioCtx.createBufferSource();
        src.buffer = buf;
        var filter = audioCtx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 300;
        var g = audioCtx.createGain();
        g.gain.value = 1.0;
        src.connect(filter); filter.connect(g); g.connect(masterGain);
        src.start();
    }

    // ═══════════════════════════════════════════════════
    //  MATERIALS
    // ═══════════════════════════════════════════════════
    var MAT = {
        concrete: new THREE.MeshStandardMaterial({ color: 0x999999, roughness: 0.9 }),
        asphalt: new THREE.MeshStandardMaterial({ color: 0x2a2a2a, roughness: 0.95 }),
        grass: new THREE.MeshStandardMaterial({ color: 0x3d7a1a, roughness: 0.95 }),
        glass: new THREE.MeshPhysicalMaterial({ color: 0x88ccff, transparent: true, opacity: 0.3, roughness: 0.05, metalness: 0.1, transmission: 0.6 }),
        metal: new THREE.MeshStandardMaterial({ color: 0xcccccc, roughness: 0.25, metalness: 0.85 }),
        white: new THREE.MeshStandardMaterial({ color: 0xf0f0f0, roughness: 0.6 }),
        blue: new THREE.MeshStandardMaterial({ color: 0x1a4b8c, roughness: 0.5 }),
        red: new THREE.MeshStandardMaterial({ color: 0xcc2222, roughness: 0.5 }),
        darkRed: new THREE.MeshStandardMaterial({ color: 0x661111, roughness: 0.5 }),
        seat: new THREE.MeshStandardMaterial({ color: 0x1e3a6e, roughness: 0.75 }),
        seatBack: new THREE.MeshStandardMaterial({ color: 0x152a52, roughness: 0.8 }),
        carpet: new THREE.MeshStandardMaterial({ color: 0x2a3040, roughness: 0.95 }),
        plastic: new THREE.MeshStandardMaterial({ color: 0xe0d8cc, roughness: 0.7 }),
        darkPlastic: new THREE.MeshStandardMaterial({ color: 0x3a3a3a, roughness: 0.8 }),
        windowInner: new THREE.MeshPhysicalMaterial({ color: 0xaaddff, transparent: true, opacity: 0.15, roughness: 0.02 }),
        terminalFloor: new THREE.MeshStandardMaterial({ color: 0xccbbaa, roughness: 0.5 }),
        sky: new THREE.MeshBasicMaterial({ color: 0x87CEEB }),
        emergencyGreen: new THREE.MeshBasicMaterial({ color: 0x00ff44 }),
        lightEmit: new THREE.MeshBasicMaterial({ color: 0xffffee }),
        lightEmitWarm: new THREE.MeshBasicMaterial({ color: 0xffeecc }),
        lightEmitDim: new THREE.MeshBasicMaterial({ color: 0x443322 }),
        stormCloud: new THREE.MeshLambertMaterial({ color: 0x333344, transparent: true, opacity: 0.85 }),
        darkCloud: new THREE.MeshLambertMaterial({ color: 0x1a1a22, transparent: true, opacity: 0.9 }),
        yellow: new THREE.MeshStandardMaterial({ color: 0xf0c000, roughness: 0.6 }),
        yellowLine: new THREE.MeshBasicMaterial({ color: 0xf0c000 }),
        orange: new THREE.MeshBasicMaterial({ color: 0xff6600 }),
        navRed: new THREE.MeshBasicMaterial({ color: 0xff0000 }),
        navGreen: new THREE.MeshBasicMaterial({ color: 0x00ff00 }),
        navWhite: new THREE.MeshBasicMaterial({ color: 0xffffff }),
        stainless: new THREE.MeshStandardMaterial({ color: 0xc8c8c8, roughness: 0.2, metalness: 0.9 }),
        fabric: new THREE.MeshStandardMaterial({ color: 0x1a3560, roughness: 0.85 }),
        seatbeltOrange: new THREE.MeshStandardMaterial({ color: 0xd4760a, roughness: 0.7 }),
        lavDoor: new THREE.MeshStandardMaterial({ color: 0x778899, roughness: 0.5, metalness: 0.3 }),
        trayTable: new THREE.MeshStandardMaterial({ color: 0xd0ccc0, roughness: 0.5 }),
        signPanel: new THREE.MeshBasicMaterial({ color: 0x004422 }),
        vehicleBody: new THREE.MeshStandardMaterial({ color: 0xe8d540, roughness: 0.6 }),
        vehicleWheel: new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.9 }),
        windsock: new THREE.MeshStandardMaterial({ color: 0xff6600, roughness: 0.8, side: THREE.DoubleSide }),
        windsockWhite: new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.8, side: THREE.DoubleSide }),
        doorOutline: new THREE.MeshBasicMaterial({ color: 0x444444 }),
        panelLine: new THREE.MeshBasicMaterial({ color: 0xcccccc }),
        fuselageAccent: new THREE.MeshStandardMaterial({ color: 0xcc1e2e, roughness: 0.4 })
    };

    // ═══════════════════════════════════════════════════
    //  SCENE GROUPS
    // ═══════════════════════════════════════════════════
    var airportGroup = new THREE.Group();
    var planeExtGroup = new THREE.Group();
    var cabinGroup = new THREE.Group();
    var cloudGroup = new THREE.Group();
    var stormCloudGroup = new THREE.Group();
    var lightningGroup = new THREE.Group();
    var debrisGroup = new THREE.Group();
    var survivalGroup = new THREE.Group();
    scene.add(airportGroup, planeExtGroup, cabinGroup, cloudGroup, stormCloudGroup, lightningGroup, debrisGroup, survivalGroup);

    // Cabin light refs
    var cabinLights = [];
    var cabinLightMeshes = [];
    var emergencyLightMeshes = [];
    var engineFans = [];

    // ═══════════════════════════════════════════════════
    //  LIGHTING
    // ═══════════════════════════════════════════════════
    var ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
    scene.add(ambientLight);

    var sunLight = new THREE.DirectionalLight(0xfffff0, 1.2);
    sunLight.position.set(80, 120, 60);
    sunLight.castShadow = true;
    sunLight.shadow.mapSize.width = 2048;
    sunLight.shadow.mapSize.height = 2048;
    sunLight.shadow.camera.near = 0.5;
    sunLight.shadow.camera.far = 500;
    sunLight.shadow.camera.left = -100;
    sunLight.shadow.camera.right = 100;
    sunLight.shadow.camera.top = 100;
    sunLight.shadow.camera.bottom = -100;
    scene.add(sunLight);

    var hemiLight = new THREE.HemisphereLight(0x87ceeb, 0x3d5c2d, 0.4);
    scene.add(hemiLight);

    // ═══════════════════════════════════════════════════
    //  AIRPORT CONSTRUCTION
    // ═══════════════════════════════════════════════════
    function buildAirport() {
        // Ground plane
        var groundGeo = new THREE.PlaneGeometry(1000, 1000);
        var ground = new THREE.Mesh(groundGeo, MAT.grass);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        airportGroup.add(ground);

        // Runway
        var rwGeo = new THREE.PlaneGeometry(24, 400);
        var runway = new THREE.Mesh(rwGeo, MAT.asphalt);
        runway.rotation.x = -Math.PI / 2;
        runway.position.set(40, 0.02, 0);
        runway.receiveShadow = true;
        airportGroup.add(runway);

        // Runway center line
        var lineM = new THREE.MeshBasicMaterial({ color: 0xffffff });
        for (var i = -180; i < 180; i += 12) {
            var mark = new THREE.Mesh(new THREE.PlaneGeometry(0.6, 5), lineM);
            mark.rotation.x = -Math.PI / 2;
            mark.position.set(40, 0.03, i);
            airportGroup.add(mark);
        }

        // Runway edge lines
        for (var side = -1; side <= 1; side += 2) {
            var edgeLine = new THREE.Mesh(new THREE.PlaneGeometry(0.4, 380), lineM);
            edgeLine.rotation.x = -Math.PI / 2;
            edgeLine.position.set(40 + side * 11.5, 0.03, 0);
            airportGroup.add(edgeLine);
        }

        // Taxiway
        var twGeo = new THREE.PlaneGeometry(12, 80);
        var taxiway = new THREE.Mesh(twGeo, MAT.asphalt);
        taxiway.rotation.x = -Math.PI / 2;
        taxiway.position.set(15, 0.02, 0);
        airportGroup.add(taxiway);

        // Terminal building (smaller, set further back)
        var termGeo = new THREE.BoxGeometry(50, 12, 25);
        var terminal = new THREE.Mesh(termGeo, MAT.concrete);
        terminal.position.set(-25, 6, 0);
        terminal.castShadow = true;
        terminal.receiveShadow = true;
        airportGroup.add(terminal);

        // Terminal windows - glass facade
        var facadeGeo = new THREE.PlaneGeometry(48, 8);
        var facade = new THREE.Mesh(facadeGeo, MAT.glass);
        facade.position.set(-25, 7, 12.51);
        airportGroup.add(facade);

        // Terminal entrance canopy
        var canopyGeo = new THREE.BoxGeometry(20, 0.4, 6);
        var canopy = new THREE.Mesh(canopyGeo, MAT.metal);
        canopy.position.set(-25, 4, 15);
        airportGroup.add(canopy);

        // Control tower (proportional to smaller terminal)
        var towerBase = new THREE.Mesh(new THREE.CylinderGeometry(3, 3.5, 22, 12), MAT.concrete);
        towerBase.position.set(-55, 11, -35);
        towerBase.castShadow = true;
        airportGroup.add(towerBase);

        var towerCab = new THREE.Mesh(new THREE.CylinderGeometry(5.5, 3.5, 5, 12), MAT.glass);
        towerCab.position.set(-55, 24.5, -35);
        airportGroup.add(towerCab);

        var towerRoof = new THREE.Mesh(new THREE.ConeGeometry(6.5, 2.5, 12), MAT.metal);
        towerRoof.position.set(-55, 28, -35);
        airportGroup.add(towerRoof);

        // Jet bridge (extends from terminal toward plane door, along X)
        var bridgeGeo = new THREE.BoxGeometry(16, 3.0, 4.0);
        var bridge = new THREE.Mesh(bridgeGeo, MAT.metal);
        bridge.position.set(3, 4.2, 0);
        airportGroup.add(bridge);

        // Plane at gate (exterior)
        buildPlaneExterior();

        // Other parked planes (along runway, distant)
        for (var p = 0; p < 3; p++) {
            var miniPlane = buildMiniPlane();
            miniPlane.position.set(40, 2, -60 - p * 50);
            miniPlane.rotation.y = Math.PI / 2; // facing down runway
            miniPlane.scale.set(0.7, 0.7, 0.7);
            airportGroup.add(miniPlane);
        }

        // Runway lights
        for (var rl = -190; rl < 190; rl += 15) {
            for (var rs = -1; rs <= 1; rs += 2) {
                var rlMesh = new THREE.Mesh(
                    new THREE.SphereGeometry(0.15, 6, 6),
                    new THREE.MeshBasicMaterial({ color: rl < -150 ? 0x00ff00 : (rl > 150 ? 0xff0000 : 0xffffff) })
                );
                rlMesh.position.set(40 + rs * 12.5, 0.15, rl);
                airportGroup.add(rlMesh);
            }
        }

        // ── Runway threshold markings (piano keys) ──
        var pianoKeyMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
        for (var te = 0; te < 2; te++) {
            var threshZ = te === 0 ? -188 : 188;
            var threshDir = te === 0 ? 1 : -1;
            for (var pk = 0; pk < 8; pk++) {
                var pkX = 40 + (pk - 3.5) * 2.5;
                var key = new THREE.Mesh(new THREE.PlaneGeometry(1.5, 10), pianoKeyMat);
                key.rotation.x = -Math.PI / 2;
                key.position.set(pkX, 0.035, threshZ + threshDir * 6);
                airportGroup.add(key);
            }
            // Runway number boxes (simple blocks representing "09" and "27")
            var numGeo = new THREE.PlaneGeometry(4, 6);
            var num = new THREE.Mesh(numGeo, pianoKeyMat);
            num.rotation.x = -Math.PI / 2;
            num.position.set(40, 0.035, threshZ + threshDir * 22);
            airportGroup.add(num);
        }

        // ── Taxiway center line (yellow dashed) ──
        for (var ti = -35; ti < 35; ti += 4) {
            var tLine = new THREE.Mesh(new THREE.PlaneGeometry(0.3, 2.5), MAT.yellowLine);
            tLine.rotation.x = -Math.PI / 2;
            tLine.position.set(15, 0.025, ti);
            airportGroup.add(tLine);
        }

        // ── Taxiway connector (from taxiway to runway) ──
        var connGeo = new THREE.PlaneGeometry(15, 10);
        var connector = new THREE.Mesh(connGeo, MAT.asphalt);
        connector.rotation.x = -Math.PI / 2;
        connector.position.set(27.5, 0.015, 0);
        airportGroup.add(connector);

        // ── Apron / ramp area (concrete pad near terminal) ──
        var apronGeo = new THREE.PlaneGeometry(45, 40);
        var apron = new THREE.Mesh(apronGeo, MAT.concrete);
        apron.rotation.x = -Math.PI / 2;
        apron.position.set(5, 0.01, 0);
        apron.receiveShadow = true;
        airportGroup.add(apron);

        // Apron line markings (yellow parking guide lines)
        for (var al = -1; al <= 1; al++) {
            var apronLine = new THREE.Mesh(new THREE.PlaneGeometry(0.15, 30), MAT.yellowLine);
            apronLine.rotation.x = -Math.PI / 2;
            apronLine.position.set(10 + al * 8, 0.02, 0);
            airportGroup.add(apronLine);
        }

        // ── Ground vehicles ──
        // Fuel truck
        var fuelTruck = new THREE.Group();
        var ftBody = new THREE.Mesh(new THREE.BoxGeometry(2, 1.2, 4), MAT.vehicleBody);
        ftBody.position.y = 0.9;
        fuelTruck.add(ftBody);
        var ftTank = new THREE.Mesh(new THREE.CylinderGeometry(0.7, 0.7, 3.2, 12), MAT.stainless);
        ftTank.rotation.x = Math.PI / 2;
        ftTank.position.set(0, 1.8, 0);
        fuelTruck.add(ftTank);
        for (var fw = 0; fw < 4; fw++) {
            var fWheel = new THREE.Mesh(new THREE.CylinderGeometry(0.25, 0.25, 0.15, 8), MAT.vehicleWheel);
            fWheel.rotation.z = Math.PI / 2;
            fWheel.position.set((fw < 2 ? -1 : 1) * 1.1, 0.25, (fw % 2 === 0 ? -1.2 : 1.2));
            fuelTruck.add(fWheel);
        }
        fuelTruck.position.set(10, 0, -15);
        airportGroup.add(fuelTruck);

        // Baggage cart train
        var bagTrain = new THREE.Group();
        var tugBody = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.8, 2), MAT.vehicleBody);
        tugBody.position.y = 0.6;
        bagTrain.add(tugBody);
        var tugRoof = new THREE.Mesh(new THREE.BoxGeometry(1.1, 0.05, 1.4), MAT.darkPlastic);
        tugRoof.position.set(0, 1.25, -0.2);
        bagTrain.add(tugRoof);
        for (var bc = 0; bc < 3; bc++) {
            var cart = new THREE.Mesh(new THREE.BoxGeometry(1.4, 0.4, 1.8), MAT.metal);
            cart.position.set(0, 0.35, -2.5 - bc * 2.2);
            bagTrain.add(cart);
            // Luggage on cart
            for (var lg = 0; lg < 3; lg++) {
                var luggage = new THREE.Mesh(
                    new THREE.BoxGeometry(0.4, 0.3, 0.5),
                    new THREE.MeshStandardMaterial({ color: new THREE.Color().setHSL(Math.random() * 0.1 + 0.55, 0.6, 0.4), roughness: 0.8 })
                );
                luggage.position.set((lg - 1) * 0.45, 0.7, -2.5 - bc * 2.2);
                luggage.rotation.y = Math.random() * 0.3;
                bagTrain.add(luggage);
            }
        }
        bagTrain.position.set(5, 0, 12);
        bagTrain.rotation.y = 0.3;
        airportGroup.add(bagTrain);

        // Pushback tug
        var pushTug = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.7, 2.5), MAT.vehicleBody);
        pushTug.position.set(22, 0.5, 5);
        airportGroup.add(pushTug);

        // ── Windsock ──
        var wsGroup = new THREE.Group();
        var wsPole = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.08, 6, 6), MAT.metal);
        wsPole.position.y = 3;
        wsGroup.add(wsPole);
        // Sock (cone shape, alternating orange/white)
        for (var ws = 0; ws < 5; ws++) {
            var sockR = 0.4 - ws * 0.06;
            var sockSeg = new THREE.Mesh(
                new THREE.CylinderGeometry(sockR - 0.06, sockR, 0.5, 8, 1, true),
                ws % 2 === 0 ? MAT.windsock : MAT.windsockWhite
            );
            sockSeg.rotation.z = -Math.PI / 2;
            sockSeg.position.set(0.3 + ws * 0.45, 5.8, 0);
            wsGroup.add(sockSeg);
        }
        wsGroup.position.set(55, 0, -40);
        airportGroup.add(wsGroup);

        // ── Terminal details ──
        // Entrance awning support columns
        for (var col = -2; col <= 2; col++) {
            var column = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.12, 4, 8), MAT.metal);
            column.position.set(-25 + col * 4.5, 2, 15.5);
            airportGroup.add(column);
        }

        // Terminal window mullions (vertical dividers in glass facade)
        for (var mul = -22; mul <= -28 + 48; mul += 3) {
            var mullion = new THREE.Mesh(new THREE.BoxGeometry(0.08, 8, 0.1), MAT.metal);
            mullion.position.set(mul, 7, 12.52);
            airportGroup.add(mullion);
        }

        // Gate number sign
        var gateSign = new THREE.Mesh(new THREE.BoxGeometry(2, 0.8, 0.1), MAT.signPanel);
        gateSign.position.set(-10, 10.5, 12.52);
        airportGroup.add(gateSign);

        // PAPI approach lights (red/white light pairs)
        var papiColors = [0xff0000, 0xff0000, 0xffffff, 0xffffff];
        for (var pp = 0; pp < 4; pp++) {
            var papiLight = new THREE.Mesh(
                new THREE.BoxGeometry(0.3, 0.3, 0.3),
                new THREE.MeshBasicMaterial({ color: papiColors[pp] })
            );
            papiLight.position.set(40 + (pp - 1.5) * 2, 0.3, -195);
            airportGroup.add(papiLight);
        }

        // Approach lights (lead-in strobe line)
        for (var ap = 0; ap < 8; ap++) {
            var appLight = new THREE.Mesh(
                new THREE.SphereGeometry(0.2, 6, 6),
                new THREE.MeshBasicMaterial({ color: 0xffffff })
            );
            appLight.position.set(40, 0.3, -200 - ap * 8);
            airportGroup.add(appLight);
        }

        // Perimeter fence (simple posts and wire)
        for (var fp = -200; fp <= 200; fp += 15) {
            var fPost = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.04, 2, 4), MAT.metal);
            fPost.position.set(-70, 1, fp);
            airportGroup.add(fPost);
        }
        var fenceWire = new THREE.Mesh(new THREE.BoxGeometry(0.02, 0.02, 400), MAT.metal);
        fenceWire.position.set(-70, 1.8, 0);
        airportGroup.add(fenceWire);
        var fenceWire2 = new THREE.Mesh(new THREE.BoxGeometry(0.02, 0.02, 400), MAT.metal);
        fenceWire2.position.set(-70, 1.2, 0);
        airportGroup.add(fenceWire2);
    }

    // Plane is built along Z-axis: nose = +Z, tail = -Z, wings along X, up = Y
    // All coordinates: (x=left/right, y=up/down, z=fore/aft)
    var PLANE = { len: 38, radius: 2.0, wingSpan: 34, wingChord: 5 };

    function buildMiniPlane() {
        var g = new THREE.Group();
        // Fuselage along Z
        var body = new THREE.Mesh(new THREE.CylinderGeometry(1.2, 1.2, 16, 10), MAT.white);
        body.rotation.x = Math.PI / 2;
        g.add(body);
        // Blue cheatline
        var mStripe = new THREE.Mesh(
            new THREE.CylinderGeometry(1.22, 1.22, 16, 10, 1, false, Math.PI * 0.47, Math.PI * 0.06),
            MAT.blue
        );
        mStripe.rotation.x = Math.PI / 2;
        g.add(mStripe);
        // Nose
        var nose = new THREE.Mesh(new THREE.SphereGeometry(1.2, 10, 8, 0, Math.PI * 2, 0, Math.PI / 2), MAT.white);
        nose.rotation.x = -Math.PI / 2;
        nose.scale.z = 1.5;
        nose.position.z = 8;
        g.add(nose);
        // Tail cone
        var tailC = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 1.2, 4, 10), MAT.white);
        tailC.rotation.x = Math.PI / 2;
        tailC.position.z = -10;
        g.add(tailC);
        // Wings
        var wing = new THREE.Mesh(new THREE.BoxGeometry(14, 0.15, 3), MAT.metal);
        wing.position.set(0, -0.3, -1);
        g.add(wing);
        // Winglets
        for (var wl = -1; wl <= 1; wl += 2) {
            var winglet = new THREE.Mesh(new THREE.BoxGeometry(0.1, 1, 0.6), MAT.white);
            winglet.position.set(wl * 7.1, 0.2, -1);
            g.add(winglet);
        }
        // Engines
        for (var eng = -1; eng <= 1; eng += 2) {
            var nacMini = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.45, 2, 8), MAT.metal);
            nacMini.rotation.x = Math.PI / 2;
            nacMini.position.set(eng * 3.5, -0.8, -0.5);
            g.add(nacMini);
        }
        // Tail fin
        var tailFin = new THREE.Mesh(new THREE.BoxGeometry(0.2, 3, 2), MAT.blue);
        tailFin.position.set(0, 2, -8);
        g.add(tailFin);
        // Horizontal stabilizers
        var hStab = new THREE.Mesh(new THREE.BoxGeometry(5, 0.1, 1.5), MAT.metal);
        hStab.position.set(0, 1, -9);
        g.add(hStab);
        return g;
    }

    // ═══════════════════════════════════════════════════
    //  PLANE EXTERIOR (Z-forward convention)
    // ═══════════════════════════════════════════════════
    function buildPlaneExterior() {
        var R = PLANE.radius;
        var halfLen = PLANE.len / 2;

        // ── Fuselage (cylinder along Z) ──
        var fusGeo = new THREE.CylinderGeometry(R, R, PLANE.len, 32);
        var fuselage = new THREE.Mesh(fusGeo, MAT.white);
        fuselage.rotation.x = Math.PI / 2; // align along Z
        fuselage.castShadow = true;
        planeExtGroup.add(fuselage);

        // ── Blue cheatline stripe ──
        var stripeGeo = new THREE.CylinderGeometry(R + 0.015, R + 0.015, PLANE.len, 32, 1, false, Math.PI * 0.47, Math.PI * 0.06);
        var stripe = new THREE.Mesh(stripeGeo, MAT.blue);
        stripe.rotation.x = Math.PI / 2;
        planeExtGroup.add(stripe);

        // ── Nose cone (ellipsoidal, smooth blend with fuselage) ──
        // Use a hemisphere scaled along Z for a rounded-but-elongated nose
        var noseGeo = new THREE.SphereGeometry(R, 32, 16, 0, Math.PI * 2, 0, Math.PI / 2);
        var nose = new THREE.Mesh(noseGeo, MAT.white);
        nose.rotation.x = -Math.PI / 2; // hemisphere pointing +Z
        nose.scale.set(1, 1, 2.0);      // stretch along Z for elongated airliner nose
        nose.position.z = halfLen;       // flush with cylinder end
        planeExtGroup.add(nose);

        // ── Cockpit windows (on nose, angled) ──
        var cwGeo = new THREE.PlaneGeometry(0.9, 0.5);
        for (var cw = -1; cw <= 1; cw += 2) {
            var cWin = new THREE.Mesh(cwGeo, MAT.glass);
            cWin.position.set(cw * 0.55, R * 0.55, halfLen + 0.3);
            cWin.rotation.x = -0.25;
            cWin.rotation.y = cw * 0.2;
            planeExtGroup.add(cWin);
        }

        // ── Tail cone (gradual taper, not a sharp point) ──
        var tailConeGeo = new THREE.CylinderGeometry(0.3, R, 8, 32);
        var tailCone = new THREE.Mesh(tailConeGeo, MAT.white);
        tailCone.rotation.x = Math.PI / 2; // align along Z, narrow end toward -Z
        tailCone.position.z = -halfLen - 4;
        planeExtGroup.add(tailCone);
        // APU exhaust at very tip
        var apuGeo = new THREE.CylinderGeometry(0.18, 0.3, 0.5, 12);
        var apu = new THREE.Mesh(apuGeo, MAT.darkPlastic);
        apu.rotation.x = Math.PI / 2;
        apu.position.z = -halfLen - 8.1;
        planeExtGroup.add(apu);

        // ── Passenger windows (both sides, with frames) ──
        var wGeo = new THREE.CircleGeometry(0.15, 10);
        var wFrameGeo = new THREE.RingGeometry(0.14, 0.19, 12);
        var wFrameMat = new THREE.MeshBasicMaterial({ color: 0x666666, side: THREE.DoubleSide });
        for (var wz = -halfLen + 4; wz <= halfLen - 3; wz += 1.2) {
            for (var wSide = -1; wSide <= 1; wSide += 2) {
                var wM = new THREE.Mesh(wGeo, MAT.glass);
                wM.position.set(wSide * (R + 0.02), R * 0.35, wz);
                wM.rotation.y = wSide > 0 ? Math.PI / 2 : -Math.PI / 2;
                planeExtGroup.add(wM);
                // Window frame ring
                var wF = new THREE.Mesh(wFrameGeo, wFrameMat);
                wF.position.set(wSide * (R + 0.025), R * 0.35, wz);
                wF.rotation.y = wSide > 0 ? Math.PI / 2 : -Math.PI / 2;
                planeExtGroup.add(wF);
            }
        }

        // ── Fuselage door outlines ──
        var doorOutGeo = new THREE.PlaneGeometry(1.0, 1.8);
        var doorEdges = new THREE.EdgesGeometry(doorOutGeo);
        var doorLineMat = new THREE.LineBasicMaterial({ color: 0x555555, linewidth: 1 });
        // Forward left door (main boarding door)
        var doorFL = new THREE.LineSegments(doorEdges, doorLineMat);
        doorFL.position.set(R + 0.03, R * 0.2, halfLen - 4);
        doorFL.rotation.y = Math.PI / 2;
        planeExtGroup.add(doorFL);
        // Forward right door
        var doorFR = new THREE.LineSegments(doorEdges.clone(), doorLineMat);
        doorFR.position.set(-R - 0.03, R * 0.2, halfLen - 4);
        doorFR.rotation.y = -Math.PI / 2;
        planeExtGroup.add(doorFR);
        // Aft left door
        var doorAL = new THREE.LineSegments(doorEdges.clone(), doorLineMat);
        doorAL.position.set(R + 0.03, R * 0.2, -halfLen + 7);
        doorAL.rotation.y = Math.PI / 2;
        planeExtGroup.add(doorAL);
        // Aft right door
        var doorAR = new THREE.LineSegments(doorEdges.clone(), doorLineMat);
        doorAR.position.set(-R - 0.03, R * 0.2, -halfLen + 7);
        doorAR.rotation.y = -Math.PI / 2;
        planeExtGroup.add(doorAR);

        // ── Panel lines (fuselage detail seams) ──
        for (var plz = -halfLen + 3; plz < halfLen - 2; plz += 6) {
            // Circumferential panel line (ring around fuselage)
            var ringGeo = new THREE.RingGeometry(R + 0.01, R + 0.025, 32);
            var ring = new THREE.Mesh(ringGeo, MAT.panelLine);
            ring.position.z = plz;
            ring.material.transparent = true;
            ring.material.opacity = 0.15;
            planeExtGroup.add(ring);
        }

        // ── Belly fairing (under fuselage between wings) ──
        var fairingGeo = new THREE.BoxGeometry(1.2, 0.25, 5);
        var fairing = new THREE.Mesh(fairingGeo, MAT.metal);
        fairing.position.set(0, -R - 0.1, -1);
        planeExtGroup.add(fairing);

        // ── Fuselage red accent stripe (below windows) ──
        var accentGeo = new THREE.CylinderGeometry(R + 0.018, R + 0.018, PLANE.len, 32, 1, false, Math.PI * 0.40, Math.PI * 0.04);
        var accent = new THREE.Mesh(accentGeo, MAT.fuselageAccent);
        accent.rotation.x = Math.PI / 2;
        planeExtGroup.add(accent);

        // ── Antenna (shark fin on top of fuselage) ──
        var antennaShape = new THREE.Shape();
        antennaShape.moveTo(0, 0);
        antennaShape.lineTo(0.8, 0);
        antennaShape.lineTo(0.3, 0.5);
        antennaShape.lineTo(0, 0);
        var antennaGeo = new THREE.ExtrudeGeometry(antennaShape, { depth: 0.06, bevelEnabled: false });
        var antenna = new THREE.Mesh(antennaGeo, MAT.darkPlastic);
        antenna.rotation.x = Math.PI / 2;
        antenna.rotation.y = Math.PI / 2;
        antenna.position.set(-0.03, R + 0.01, 3);
        planeExtGroup.add(antenna);

        // ── Navigation lights ──
        // Red on left wingtip
        var navRedLight = new THREE.Mesh(new THREE.SphereGeometry(0.08, 6, 6), MAT.navRed);
        navRedLight.position.set(PLANE.wingSpan / 2 + 0.1, -R * 0.35 + 0.1, -1);
        planeExtGroup.add(navRedLight);
        // Green on right wingtip
        var navGreenLight = new THREE.Mesh(new THREE.SphereGeometry(0.08, 6, 6), MAT.navGreen);
        navGreenLight.position.set(-PLANE.wingSpan / 2 - 0.1, -R * 0.35 + 0.1, -1);
        planeExtGroup.add(navGreenLight);
        // White on tail
        var navTailLight = new THREE.Mesh(new THREE.SphereGeometry(0.08, 6, 6), MAT.navWhite);
        navTailLight.position.set(0, R + 0.3, -halfLen - 7.8);
        planeExtGroup.add(navTailLight);
        // Anti-collision beacon (red, on top of fuselage)
        var beaconTop = new THREE.Mesh(new THREE.SphereGeometry(0.1, 6, 6), MAT.navRed);
        beaconTop.position.set(0, R + 0.1, 0);
        planeExtGroup.add(beaconTop);
        // Belly beacon
        var beaconBot = new THREE.Mesh(new THREE.SphereGeometry(0.1, 6, 6), MAT.navRed);
        beaconBot.position.set(0, -R - 0.1, 0);
        planeExtGroup.add(beaconBot);

        // ── Wings (tapered airfoil shape, white) ──
        // Wing uses a custom ExtrudeGeometry for proper airfoil cross-section with taper
        function makeWing(side) {
            // side: 1 = left(+X), -1 = right(-X)
            var wGroup = new THREE.Group();
            var span = PLANE.wingSpan / 2 - R; // ~15m per side
            var rootChord = PLANE.wingChord;     // 5m at root
            var tipChord = rootChord * 0.35;     // 1.75m at tip (tapered)
            var thickness = 0.5;                  // airfoil max thickness at root
            var tipThickness = 0.18;              // thinner at tip

            // Build wing as a custom BufferGeometry (tapered box)
            // 8 vertices: 4 at root, 4 at tip
            var rootX = side * R;           // root starts at fuselage edge
            var tipX = side * (R + span);   // tip at full span
            var rootLE = rootChord * 0.3;   // leading edge forward of spar
            var rootTE = -rootChord * 0.7;  // trailing edge behind spar
            var tipLE = tipChord * 0.3;     // tip leading edge (swept back)
            var tipTE = -tipChord * 0.7;    // tip trailing edge
            var sweep = -2.0;               // sweep: tip is 2m further aft than root

            var verts = new Float32Array([
                // Root: top-LE, top-TE, bot-LE, bot-TE
                rootX, thickness / 2, rootLE,
                rootX, thickness / 2, rootTE,
                rootX, -thickness / 2, rootLE,
                rootX, -thickness / 2, rootTE,
                // Tip: top-LE, top-TE, bot-LE, bot-TE
                tipX, tipThickness / 2, tipLE + sweep,
                tipX, tipThickness / 2, tipTE + sweep,
                tipX, -tipThickness / 2, tipLE + sweep,
                tipX, -tipThickness / 2, tipTE + sweep
            ]);

            // 12 triangles (6 faces, 2 tri each)
            var indices = [
                // Top face (LE-root, TE-root, TE-tip, LE-tip)
                0, 1, 5, 0, 5, 4,
                // Bottom face
                2, 6, 7, 2, 7, 3,
                // Leading edge (front face)
                0, 4, 6, 0, 6, 2,
                // Trailing edge (back face)
                1, 3, 7, 1, 7, 5,
                // Root cap
                0, 2, 3, 0, 3, 1,
                // Tip cap
                4, 5, 7, 4, 7, 6
            ];

            var wingGeo = new THREE.BufferGeometry();
            wingGeo.setAttribute('position', new THREE.BufferAttribute(verts, 3));
            wingGeo.setIndex(indices);
            wingGeo.computeVertexNormals();

            var wingMat = new THREE.MeshStandardMaterial({ color: 0xe8e8e8, roughness: 0.4, metalness: 0.1, side: THREE.DoubleSide });
            var wingMesh = new THREE.Mesh(wingGeo, wingMat);
            wingMesh.castShadow = true;
            wGroup.add(wingMesh);

            // Winglet (blended, curves up at the tip)
            var wingletGeo = new THREE.BoxGeometry(0.12, 1.4, tipChord * 0.5);
            var winglet = new THREE.Mesh(wingletGeo, MAT.white);
            winglet.position.set(tipX + side * 0.06, 0.7, tipLE + sweep - tipChord * 0.15);
            winglet.rotation.z = side * 0.15; // slight outward cant
            wGroup.add(winglet);

            wGroup.position.set(0, -R * 0.35, 0); // wings below fuselage center
            return wGroup;
        }
        planeExtGroup.add(makeWing(1));
        planeExtGroup.add(makeWing(-1));

        // ── Engines (under wings, with spinning fan blades) ──
        function makeEngine(xPos) {
            var eGroup = new THREE.Group();
            // Nacelle (cylinder along Z)
            var nacGeo = new THREE.CylinderGeometry(0.65, 0.75, 3.5, 18);
            var nacelle = new THREE.Mesh(nacGeo, MAT.metal);
            nacelle.rotation.x = Math.PI / 2;
            eGroup.add(nacelle);
            // Exhaust nozzle (rear, darker ring)
            var exhaustGeo = new THREE.CylinderGeometry(0.55, 0.62, 0.4, 18);
            var exhaust = new THREE.Mesh(exhaustGeo, MAT.darkPlastic);
            exhaust.rotation.x = Math.PI / 2;
            exhaust.position.z = -1.8;
            eGroup.add(exhaust);
            // Intake ring (thick lip)
            var intakeGeo = new THREE.TorusGeometry(0.65, 0.06, 8, 24);
            var intake = new THREE.Mesh(intakeGeo, MAT.metal);
            intake.position.z = 1.75;
            eGroup.add(intake);
            // Inner dark circle (engine interior)
            var innerGeo = new THREE.CircleGeometry(0.62, 18);
            var inner = new THREE.Mesh(innerGeo, new THREE.MeshBasicMaterial({ color: 0x0a0a0a }));
            inner.position.z = 1.73;
            eGroup.add(inner);
            // Spinner cone (center hub)
            var spinnerGeo = new THREE.ConeGeometry(0.12, 0.35, 12);
            var spinner = new THREE.Mesh(spinnerGeo, MAT.metal);
            spinner.rotation.x = -Math.PI / 2;
            spinner.position.z = 1.85;
            eGroup.add(spinner);
            // Fan blade disc (group that rotates)
            var fanGroup = new THREE.Group();
            fanGroup.position.z = 1.72;
            var bladeCount = 18;
            var bladeMat = new THREE.MeshStandardMaterial({ color: 0x888899, roughness: 0.3, metalness: 0.8, side: THREE.DoubleSide });
            for (var b = 0; b < bladeCount; b++) {
                var angle = (b / bladeCount) * Math.PI * 2;
                var bladeGeo = new THREE.PlaneGeometry(0.04, 0.48);
                var blade = new THREE.Mesh(bladeGeo, bladeMat);
                blade.position.set(Math.cos(angle) * 0.35, Math.sin(angle) * 0.35, 0);
                blade.rotation.z = angle;
                // Slight twist to simulate airfoil
                blade.rotation.x = 0.3;
                fanGroup.add(blade);
            }
            eGroup.add(fanGroup);
            engineFans.push(fanGroup);
            // Pylon (connects engine to wing)
            var pylonGeo = new THREE.BoxGeometry(0.15, 0.7, 2.5);
            var pylon = new THREE.Mesh(pylonGeo, MAT.metal);
            pylon.position.y = 0.7;
            pylon.position.z = -0.2;
            eGroup.add(pylon);

            eGroup.position.set(xPos, -R - 0.6, 0);
            return eGroup;
        }
        planeExtGroup.add(makeEngine(6.0));
        planeExtGroup.add(makeEngine(-6.0));

        // ── Vertical Stabilizer (swept tail fin) ──
        // Build as a thin tapered shape lying in XY, then rotate to stand upright on the tail
        // Shape drawn in a local 2D plane: X = fore/aft, Y = height
        var vfinShape = new THREE.Shape();
        // Base (on fuselage top): from tail end forward along fuselage
        vfinShape.moveTo(0, 0);        // trailing edge base (tail tip)
        vfinShape.lineTo(6, 0);        // leading edge base (forward on fuselage)
        // Sweep up: leading edge rises steeply
        vfinShape.lineTo(2.5, 6);      // tip - leading edge (swept back)
        // Tip curves back
        vfinShape.lineTo(0.5, 6);      // tip - trailing edge
        // Trailing edge back down
        vfinShape.lineTo(0, 0);        // close
        var vfinGeo = new THREE.ExtrudeGeometry(vfinShape, { depth: 0.15, bevelEnabled: true, bevelThickness: 0.05, bevelSize: 0.05, bevelSegments: 2 });
        var vfin = new THREE.Mesh(vfinGeo, MAT.blue);
        // Rotate so the shape stands upright: the local Y (height) becomes world Y, local X (fore/aft) aligns with Z
        vfin.rotation.x = Math.PI / 2;   // stand up from XY-plane to XZ
        vfin.rotation.y = Math.PI / 2;   // rotate so fore/aft aligns with Z
        // Position: on top of fuselage, at the tail
        vfin.position.set(-0.075, R, -halfLen + 2);
        planeExtGroup.add(vfin);

        // ── Tail livery accent (red swoosh on vertical fin) ──
        var liveryShape = new THREE.Shape();
        liveryShape.moveTo(0, 0);
        liveryShape.lineTo(6, 0);
        liveryShape.lineTo(2.5, 3);
        liveryShape.lineTo(0, 0);
        var liveryGeo = new THREE.ExtrudeGeometry(liveryShape, { depth: 0.18, bevelEnabled: false });
        var livery = new THREE.Mesh(liveryGeo, MAT.fuselageAccent);
        livery.rotation.x = Math.PI / 2;
        livery.rotation.y = Math.PI / 2;
        livery.position.set(-0.09, R, -halfLen + 2);
        planeExtGroup.add(livery);

        // ── Horizontal Stabilizers (with taper) ──
        for (var hs = -1; hs <= 1; hs += 2) {
            var hsGroup = new THREE.Group();
            var hsGeo = new THREE.BoxGeometry(6, 0.15, 3);
            var hStab = new THREE.Mesh(hsGeo, MAT.metal);
            hsGroup.add(hStab);
            // Tip fairing
            var hsTip = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.18, 1.5), MAT.metal);
            hsTip.position.set(hs * 3.1, 0, -0.5);
            hsGroup.add(hsTip);
            hsGroup.position.set(hs * 3.5, R + 0.2, -halfLen - 1);
            planeExtGroup.add(hsGroup);
        }

        // ── Landing Gear ──
        function makeGear(x, z, numWheels) {
            var gGroup = new THREE.Group();
            // Strut
            var strut = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.06, 1.5, 8), MAT.darkPlastic);
            gGroup.add(strut);
            // Wheels
            for (var w = 0; w < numWheels; w++) {
                var wheel = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.3, 0.3, 0.18, 16),
                    MAT.darkPlastic
                );
                wheel.rotation.z = Math.PI / 2; // axle along X
                wheel.position.set((w - (numWheels - 1) / 2) * 0.5, -0.75, 0);
                gGroup.add(wheel);
            }
            gGroup.position.set(x, -R, z);
            return gGroup;
        }
        // Nose gear (single pair, forward)
        planeExtGroup.add(makeGear(0, halfLen - 5, 2));
        // Main gear (double pair, under wings)
        planeExtGroup.add(makeGear(1.5, -3, 2));
        planeExtGroup.add(makeGear(-1.5, -3, 2));

        // Position the whole plane: nose pointing +Z, at the gate
        // Ground clearance: bottom of wheels should touch y=0
        planeExtGroup.position.set(18, R + 1.5, 0);
    }

    // ═══════════════════════════════════════════════════
    //  CABIN INTERIOR
    // ═══════════════════════════════════════════════════
    // ── CABIN: Z-forward, X = left/right, Y = up ──
    // Real 737 cabin: ~3.54m wide, ~2.2m tall inside, ~24m passenger cabin length
    // Scale: 1 unit ≈ 1 meter
    function buildCabin() {
        var CW = 3.54; // cabin width (meters)
        var CH = 2.2;  // cabin height
        var CL = 22;   // cabin length (passenger section)
        var halfW = CW / 2;
        var halfL = CL / 2;

        // ── Fuselage shell (half-cylinder arch, inside face) ──
        var archSegs = 20;
        for (var wp = 0; wp < archSegs; wp++) {
            // Arch from -halfW to +halfW, height 0 to CH
            var a0 = (wp / archSegs) * Math.PI;
            var a1 = ((wp + 1) / archSegs) * Math.PI;
            var x0 = Math.cos(a0) * halfW;
            var y0 = Math.sin(a0) * (CH * 0.55) + CH * 0.3;
            var x1 = Math.cos(a1) * halfW;
            var y1 = Math.sin(a1) * (CH * 0.55) + CH * 0.3;

            var verts = new Float32Array([
                x0, y0, -halfL,  x0, y0, halfL,  x1, y1, halfL,  x1, y1, -halfL
            ]);
            var idx = [0, 2, 1, 0, 3, 2]; // inward-facing normals
            var geo = new THREE.BufferGeometry();
            geo.setAttribute('position', new THREE.BufferAttribute(verts, 3));
            geo.setIndex(idx);
            geo.computeVertexNormals();
            cabinGroup.add(new THREE.Mesh(geo, MAT.plastic));
        }

        // ── Floor ──
        var floor = new THREE.Mesh(new THREE.PlaneGeometry(CW, CL), MAT.carpet);
        floor.rotation.x = -Math.PI / 2;
        cabinGroup.add(floor);

        // ── Aisle strip (center of floor) ──
        var aisleMat = new THREE.MeshStandardMaterial({ color: 0x222830, roughness: 0.9 });
        var aisle = new THREE.Mesh(new THREE.PlaneGeometry(0.5, CL), aisleMat);
        aisle.rotation.x = -Math.PI / 2;
        aisle.position.y = 0.005;
        cabinGroup.add(aisle);

        // ── Seats: 3-3 layout (A B C | aisle | D E F) ──
        // Real economy seat: ~44cm wide, ~80cm pitch (row spacing)
        var seatWidth = 0.44;
        var rowPitch = 0.80;
        var aisleHalfW = 0.25;
        // Left group: seats at x = aisleHalfW + seatWidth*0.5, +seatWidth, +seatWidth*2
        // Right group: mirrored
        var seatPositionsX = [];
        for (var s = 0; s < 3; s++) {
            var leftX = aisleHalfW + seatWidth * 0.5 + s * seatWidth;
            seatPositionsX.push(leftX);   // left side (+X)
            seatPositionsX.push(-leftX);  // right side (-X)
        }

        var firstRowZ = -halfL + 1.5;
        var numRows = Math.floor((CL - 2) / rowPitch);
        for (var row = 0; row < numRows; row++) {
            var rz = firstRowZ + row * rowPitch;
            for (var si = 0; si < seatPositionsX.length; si++) {
                cabinGroup.add(buildSeat(seatPositionsX[si], rz));
            }
        }

        // ── Overhead bins (both sides, continuous panels) ──
        var binH = 0.4, binD = 0.55;
        var binY = CH - 0.45;
        for (var bSide = -1; bSide <= 1; bSide += 2) {
            for (var bz = -halfL + 1; bz < halfL - 1; bz += 3) {
                var segLen = Math.min(2.8, halfL - 1 - bz);
                if (segLen < 0.5) continue;
                var bin = new THREE.Mesh(new THREE.BoxGeometry(binD, binH, segLen), MAT.plastic);
                bin.position.set(bSide * (halfW - binD / 2 - 0.05), binY, bz + segLen / 2);
                cabinGroup.add(bin);
                // Handle
                var handle = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.03, segLen * 0.5), MAT.darkPlastic);
                handle.position.set(bSide * (halfW - binD - 0.07), binY - binH / 2 - 0.02, bz + segLen / 2);
                cabinGroup.add(handle);
            }
        }

        // ── Windows (interior, on walls) ──
        for (var wz = -halfL + 1.5; wz < halfL - 1; wz += rowPitch) {
            for (var wSide = -1; wSide <= 1; wSide += 2) {
                // Rounded-rect window frame
                var frame = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.28, 0.20), MAT.darkPlastic);
                frame.position.set(wSide * (halfW - 0.02), 1.15, wz);
                cabinGroup.add(frame);
                // Glass
                var glass = new THREE.Mesh(new THREE.PlaneGeometry(0.24, 0.16), MAT.windowInner);
                glass.position.set(wSide * (halfW - 0.01), 1.15, wz);
                glass.rotation.y = wSide > 0 ? -Math.PI / 2 : Math.PI / 2;
                cabinGroup.add(glass);
            }
        }

        // ── Ceiling light panels (along center) ──
        for (var lz = -halfL + 1; lz < halfL - 1; lz += 2) {
            var lPanel = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.03, 1.8), MAT.lightEmit);
            lPanel.position.set(0, CH - 0.02, lz);
            cabinGroup.add(lPanel);
            cabinLightMeshes.push(lPanel);

            // Actual point light every 4m
            if (Math.abs(lz % 4) < 1) {
                var pLight = new THREE.PointLight(0xffffee, 0.4, 6);
                pLight.position.set(0, CH - 0.1, lz);
                cabinGroup.add(pLight);
                cabinLights.push(pLight);
            }
        }

        // ── Reading light nozzles (under overhead bins) ──
        for (var rlz = -halfL + 1.5; rlz < halfL - 1; rlz += rowPitch) {
            for (var rlSide = -1; rlSide <= 1; rlSide += 2) {
                var nozzle = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.03, 0.06, 8), MAT.darkPlastic);
                nozzle.position.set(rlSide * (halfW - binD - 0.1), binY - binH / 2 - 0.06, rlz);
                cabinGroup.add(nozzle);
            }
        }

        // ── Cockpit door (front, centered) ──
        var cDoor = new THREE.Mesh(new THREE.BoxGeometry(0.9, 1.9, 0.08), MAT.metal);
        cDoor.position.set(0, 0.95, halfL - 0.04);
        cabinGroup.add(cDoor);

        // ── EXIT signs (front and rear) ──
        var exitMat = new THREE.MeshBasicMaterial({ color: 0x00ff44 });
        var ex1 = new THREE.Mesh(new THREE.BoxGeometry(0.35, 0.12, 0.02), exitMat);
        ex1.position.set(0, CH - 0.1, halfL - 0.5);
        cabinGroup.add(ex1);
        var ex2 = new THREE.Mesh(new THREE.BoxGeometry(0.35, 0.12, 0.02), exitMat);
        ex2.position.set(0, CH - 0.1, -halfL + 0.5);
        cabinGroup.add(ex2);

        // ── Emergency floor LEDs (hidden initially, along aisle edges) ──
        for (var elz = -halfL + 1; elz < halfL - 1; elz += 1.2) {
            for (var elSide = -1; elSide <= 1; elSide += 2) {
                var eled = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.015, 0.06), MAT.emergencyGreen);
                eled.position.set(elSide * 0.3, 0.01, elz);
                eled.visible = false;
                cabinGroup.add(eled);
                emergencyLightMeshes.push(eled);
            }
        }

        // ── Row numbers (on overhead bins, every row) ──
        var rowNumMat = new THREE.MeshBasicMaterial({ color: 0x88aacc });
        for (var rn = 0; rn < numRows; rn++) {
            var rnZ = firstRowZ + rn * rowPitch;
            for (var rnSide = -1; rnSide <= 1; rnSide += 2) {
                var rowTag = new THREE.Mesh(new THREE.PlaneGeometry(0.12, 0.08), rowNumMat);
                rowTag.position.set(rnSide * (halfW - binD - 0.06), binY - binH / 2 - 0.01, rnZ);
                rowTag.rotation.y = rnSide > 0 ? -Math.PI / 2 : Math.PI / 2;
                cabinGroup.add(rowTag);
            }
        }

        // ── Air vent / reading light panel (PSU panel above each seat group) ──
        var psuMat = new THREE.MeshStandardMaterial({ color: 0xd0ccc0, roughness: 0.6 });
        for (var psu = -halfL + 1.5; psu < halfL - 1; psu += rowPitch * 3) {
            for (var psuSide = -1; psuSide <= 1; psuSide += 2) {
                // PSU strip (Passenger Service Unit)
                var psuPanel = new THREE.Mesh(new THREE.BoxGeometry(0.35, 0.04, 0.2), psuMat);
                psuPanel.position.set(psuSide * (halfW - binD - 0.12), binY - binH / 2 + 0.02, psu);
                cabinGroup.add(psuPanel);
                // Air nozzle (gasper)
                var nozzleMat = new THREE.MeshStandardMaterial({ color: 0x999999, roughness: 0.3, metalness: 0.5 });
                var gasper = new THREE.Mesh(new THREE.CylinderGeometry(0.025, 0.03, 0.04, 8), nozzleMat);
                gasper.position.set(psuSide * (halfW - binD - 0.12), binY - binH / 2 - 0.01, psu);
                cabinGroup.add(gasper);
            }
        }

        // ── No-smoking / Seatbelt illuminated signs (on overhead bin faces) ──
        var signLitMat = new THREE.MeshBasicMaterial({ color: 0x224433 });
        for (var sgz = -halfL + 2.5; sgz < halfL - 2; sgz += 6) {
            for (var sgSide = -1; sgSide <= 1; sgSide += 2) {
                // Seatbelt sign
                var sbSign = new THREE.Mesh(new THREE.BoxGeometry(0.006, 0.06, 0.14), signLitMat);
                sbSign.position.set(sgSide * (halfW - binD - 0.053), binY - 0.05, sgz);
                cabinGroup.add(sbSign);
                // No smoking sign (offset from seatbelt)
                var nsSign = new THREE.Mesh(new THREE.BoxGeometry(0.006, 0.06, 0.14), signLitMat);
                nsSign.position.set(sgSide * (halfW - binD - 0.053), binY - 0.05, sgz + 0.2);
                cabinGroup.add(nsSign);
            }
        }

        // ── Lavatory (rear of cabin) ──
        var lavZ = -halfL + 0.2;
        // Lavatory wall (partition)
        var lavWall = new THREE.Mesh(new THREE.BoxGeometry(CW, CH * 0.9, 0.06), MAT.plastic);
        lavWall.position.set(0, CH * 0.45, lavZ);
        cabinGroup.add(lavWall);
        // Lavatory door (left side)
        var lavDoorMesh = new THREE.Mesh(new THREE.BoxGeometry(0.65, 1.7, 0.04), MAT.lavDoor);
        lavDoorMesh.position.set(-0.7, 0.85, lavZ + 0.05);
        cabinGroup.add(lavDoorMesh);
        // Door handle
        var lavHandle = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.03, 0.03), MAT.metal);
        lavHandle.position.set(-0.5, 0.9, lavZ + 0.08);
        cabinGroup.add(lavHandle);
        // Occupied sign (red/green indicator)
        var occSign = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.04, 0.01), MAT.emergencyGreen);
        occSign.position.set(-0.7, 1.75, lavZ + 0.06);
        cabinGroup.add(occSign);
        // Lavatory door (right side)
        var lavDoor2 = new THREE.Mesh(new THREE.BoxGeometry(0.65, 1.7, 0.04), MAT.lavDoor);
        lavDoor2.position.set(0.7, 0.85, lavZ + 0.05);
        cabinGroup.add(lavDoor2);

        // ── Galley area (front of cabin, behind cockpit) ──
        var galleyZ = halfL - 0.8;
        // Galley cart slot (stainless steel units)
        for (var gc = -1; gc <= 1; gc += 2) {
            var galleyUnit = new THREE.Mesh(new THREE.BoxGeometry(0.5, 1.0, 0.6), MAT.stainless);
            galleyUnit.position.set(gc * (halfW - 0.35), 0.5, galleyZ);
            cabinGroup.add(galleyUnit);
            // Counter top
            var counter = new THREE.Mesh(new THREE.BoxGeometry(0.55, 0.03, 0.65), MAT.darkPlastic);
            counter.position.set(gc * (halfW - 0.35), 1.02, galleyZ);
            cabinGroup.add(counter);
        }
        // Galley curtain rod
        var curtainRod = new THREE.Mesh(new THREE.CylinderGeometry(0.01, 0.01, CW - 0.5, 6), MAT.metal);
        curtainRod.rotation.z = Math.PI / 2;
        curtainRod.position.set(0, CH - 0.15, galleyZ - 0.3);
        cabinGroup.add(curtainRod);

        // ── Cabin crew jump seats (folded, near doors) ──
        for (var jsSide = -1; jsSide <= 1; jsSide += 2) {
            var jumpSeat = new THREE.Group();
            var jsBack = new THREE.Mesh(new THREE.BoxGeometry(0.45, 0.7, 0.04), MAT.darkPlastic);
            jsBack.position.y = 0.7;
            jumpSeat.add(jsBack);
            var jsCush = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.04, 0.25), MAT.seat);
            jsCush.position.set(0, 0.38, 0.12);
            jumpSeat.add(jsCush);
            jumpSeat.position.set(jsSide * (halfW - 0.3), 0, halfL - 0.5);
            jumpSeat.rotation.y = Math.PI;
            cabinGroup.add(jumpSeat);
        }

        cabinGroup.visible = false;
    }

    // ── Single seat: faces +Z (toward cockpit), x = lateral position, z = row position ──
    // Real economy seat: ~44cm wide, ~42cm deep cushion, back ~60cm tall
    function buildSeat(x, z) {
        var sg = new THREE.Group();
        var W = 0.42, D = 0.42, backH = 0.58, backT = 0.05;
        var legH = 0.40, cushionH = 0.08;
        var seatY = legH; // top of legs = bottom of cushion

        // Legs (two vertical posts)
        sg.add(pm(new THREE.BoxGeometry(0.03, legH, 0.03), MAT.metal, -W/2+0.04, legH/2, 0));
        sg.add(pm(new THREE.BoxGeometry(0.03, legH, 0.03), MAT.metal,  W/2-0.04, legH/2, 0));

        // Seat cushion
        sg.add(pm(new THREE.BoxGeometry(W, cushionH, D), MAT.seat, 0, seatY + cushionH/2, 0));

        // Seat back (behind cushion, angled slightly)
        var back = pm(new THREE.BoxGeometry(W, backH, backT), MAT.seatBack, 0, seatY + cushionH + backH/2, -D/2 + backT/2);
        back.rotation.x = 0.08; // slight recline
        sg.add(back);

        // Headrest
        sg.add(pm(new THREE.BoxGeometry(W*0.6, 0.16, 0.04), MAT.plastic, 0, seatY + cushionH + backH + 0.04, -D/2 + 0.02));

        // Armrests (on left and right edges)
        for (var arm = -1; arm <= 1; arm += 2) {
            sg.add(pm(new THREE.BoxGeometry(0.04, 0.03, D*0.7), MAT.darkPlastic, arm * W/2, seatY + cushionH + 0.04, 0.04));
        }

        // Seat pocket (fabric on back)
        sg.add(pm(new THREE.BoxGeometry(W*0.8, 0.18, 0.008), MAT.darkPlastic, 0, seatY + 0.12, -D/2 + backT + 0.005));

        // Tray table (folded, on back of seat in front)
        var tray = pm(new THREE.BoxGeometry(W*0.75, 0.015, 0.25), MAT.trayTable, 0, seatY + cushionH + backH * 0.35, -D/2 + backT + 0.01);
        sg.add(tray);
        // Tray latch
        sg.add(pm(new THREE.BoxGeometry(0.06, 0.03, 0.03), MAT.darkPlastic, 0, seatY + cushionH + backH * 0.35 + 0.02, -D/2 + backT + 0.02));

        // Seatbelt (draped on cushion)
        var beltL = pm(new THREE.BoxGeometry(0.025, 0.008, D*0.4), MAT.seatbeltOrange, -W*0.15, seatY + cushionH + 0.01, 0.05);
        sg.add(beltL);
        var beltR = pm(new THREE.BoxGeometry(0.025, 0.008, D*0.4), MAT.seatbeltOrange, W*0.15, seatY + cushionH + 0.01, 0.05);
        sg.add(beltR);
        // Belt buckle (center)
        sg.add(pm(new THREE.BoxGeometry(0.05, 0.015, 0.03), MAT.metal, 0, seatY + cushionH + 0.015, 0.1));

        sg.position.set(x, 0, z);
        return sg;
    }

    function pm(geo, mat, x, y, z) {
        var m = new THREE.Mesh(geo, mat);
        m.position.set(x, y, z);
        return m;
    }

    // ═══════════════════════════════════════════════════
    //  CLOUDS
    // ═══════════════════════════════════════════════════
    function buildCloud(x, y, z, scale, mat) {
        var cg = new THREE.Group();
        mat = mat || new THREE.MeshLambertMaterial({ color: 0xffffff, transparent: true, opacity: 0.88 });
        var count = 4 + Math.floor(Math.random() * 6);
        for (var i = 0; i < count; i++) {
            var r = (0.6 + Math.random() * 1.4) * scale;
            var s = new THREE.Mesh(new THREE.SphereGeometry(r, 7, 7), mat);
            s.position.set(
                (Math.random() - 0.5) * 5 * scale,
                (Math.random() - 0.5) * 1.5 * scale,
                (Math.random() - 0.5) * 4 * scale
            );
            cg.add(s);
        }
        cg.position.set(x, y, z);
        cg.userData.speed = 0.3 + Math.random() * 0.7;
        return cg;
    }

    function populateClouds() {
        for (var i = 0; i < 40; i++) {
            cloudGroup.add(buildCloud(
                (Math.random() - 0.5) * 600,
                25 + Math.random() * 80,
                (Math.random() - 0.5) * 600,
                2 + Math.random() * 4
            ));
        }
    }

    function populateStormClouds() {
        for (var i = 0; i < 30; i++) {
            stormCloudGroup.add(buildCloud(
                (Math.random() - 0.5) * 500,
                20 + Math.random() * 40,
                (Math.random() - 0.5) * 500,
                3 + Math.random() * 6,
                Math.random() < 0.5 ? MAT.stormCloud : MAT.darkCloud
            ));
        }
        stormCloudGroup.visible = false;
    }

    // ═══════════════════════════════════════════════════
    //  SURVIVAL SCENE
    // ═══════════════════════════════════════════════════
    function buildSurvivalScene() {
        // Dark terrain with slight undulation
        var groundGeo = new THREE.PlaneGeometry(200, 200, 20, 20);
        var groundVerts = groundGeo.attributes.position.array;
        for (var gv = 0; gv < groundVerts.length; gv += 3) {
            groundVerts[gv + 2] += (Math.random() - 0.5) * 0.6; // slight bumpiness
        }
        groundGeo.computeVertexNormals();
        var ground = new THREE.Mesh(
            groundGeo,
            new THREE.MeshStandardMaterial({ color: 0x1a2a10, roughness: 0.95 })
        );
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = -0.5;
        survivalGroup.add(ground);

        // ── Broken fuselage section (recognizable tube) ──
        var fuseWreckGeo = new THREE.CylinderGeometry(2.0, 2.0, 12, 16, 1, true, 0, Math.PI * 1.5);
        var fuseWreckMat = new THREE.MeshStandardMaterial({ color: 0xaaaaaa, roughness: 0.8, side: THREE.DoubleSide });
        var fuseWreck = new THREE.Mesh(fuseWreckGeo, fuseWreckMat);
        fuseWreck.rotation.z = Math.PI / 2;
        fuseWreck.rotation.y = 0.3;
        fuseWreck.position.set(-5, 1.5, -8);
        survivalGroup.add(fuseWreck);

        // Broken nose section
        var noseWreck = new THREE.Mesh(
            new THREE.CylinderGeometry(0.5, 2.0, 5, 12, 1, true),
            fuseWreckMat
        );
        noseWreck.rotation.z = Math.PI / 2 + 0.3;
        noseWreck.position.set(-13, 0.8, -10);
        noseWreck.rotation.y = 0.5;
        survivalGroup.add(noseWreck);

        // Broken wing section
        var wingWreck = new THREE.Mesh(
            new THREE.BoxGeometry(8, 0.3, 3),
            new THREE.MeshStandardMaterial({ color: 0xcccccc, roughness: 0.7 })
        );
        wingWreck.position.set(8, 0.3, -5);
        wingWreck.rotation.z = 0.15;
        wingWreck.rotation.y = 0.8;
        survivalGroup.add(wingWreck);

        // Tail section (vertical fin, broken)
        var tailWreckShape = new THREE.Shape();
        tailWreckShape.moveTo(0, 0);
        tailWreckShape.lineTo(3, 0);
        tailWreckShape.lineTo(1.5, 4);
        tailWreckShape.lineTo(0, 0);
        var tailWreck = new THREE.Mesh(
            new THREE.ExtrudeGeometry(tailWreckShape, { depth: 0.12, bevelEnabled: false }),
            MAT.blue
        );
        tailWreck.position.set(-18, 0, -12);
        tailWreck.rotation.z = -0.2;
        survivalGroup.add(tailWreck);

        // ── Scattered debris (metal fragments, seat pieces) ──
        var debrisColors = [0x888888, 0x999999, 0x666666, 0xaaaaaa, 0x1e3a6e, 0xe0d8cc];
        for (var i = 0; i < 30; i++) {
            var dSize = 0.2 + Math.random() * 1.5;
            var debrisMat = new THREE.MeshStandardMaterial({
                color: debrisColors[Math.floor(Math.random() * debrisColors.length)],
                roughness: 0.85
            });
            var debrisGeo = Math.random() < 0.5 ?
                new THREE.BoxGeometry(dSize, dSize * 0.3, dSize * 0.6) :
                new THREE.PlaneGeometry(dSize, dSize * 0.8);
            var debris = new THREE.Mesh(debrisGeo, debrisMat);
            if (debrisGeo.type === 'PlaneGeometry') debris.material.side = THREE.DoubleSide;
            debris.position.set(
                (Math.random() - 0.5) * 50,
                dSize * 0.1,
                (Math.random() - 0.5) * 50
            );
            debris.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * 0.5);
            survivalGroup.add(debris);
        }

        // ── Scattered luggage ──
        var luggageColors = [0x8B0000, 0x1a1a6e, 0x2d5a1e, 0x333333, 0x4a2a0a, 0xcc7722];
        for (var lu = 0; lu < 12; lu++) {
            var lugMat = new THREE.MeshStandardMaterial({
                color: luggageColors[Math.floor(Math.random() * luggageColors.length)],
                roughness: 0.8
            });
            var lugSize = 0.3 + Math.random() * 0.3;
            var lugPiece = new THREE.Mesh(
                new THREE.BoxGeometry(lugSize * 0.8, lugSize * 0.6, lugSize),
                lugMat
            );
            lugPiece.position.set(
                (Math.random() - 0.5) * 30,
                lugSize * 0.3,
                (Math.random() - 0.5) * 30
            );
            lugPiece.rotation.set(Math.random() * 0.8, Math.random() * Math.PI, Math.random() * 0.3);
            survivalGroup.add(lugPiece);
        }

        // ── Dirt/gouge marks (impact trail) ──
        var trailMat = new THREE.MeshStandardMaterial({ color: 0x0f1a08, roughness: 1.0 });
        for (var tr = 0; tr < 6; tr++) {
            var trailPiece = new THREE.Mesh(
                new THREE.PlaneGeometry(3 + Math.random() * 4, 1.5 + Math.random() * 2),
                trailMat
            );
            trailPiece.rotation.x = -Math.PI / 2;
            trailPiece.position.set(-8 + tr * 5, -0.45, -6 + tr * 1.5);
            trailPiece.rotation.z = 0.3;
            survivalGroup.add(trailPiece);
        }

        // ── Tree silhouettes (around the crash site) ──
        function makeTree(x, z) {
            var tg = new THREE.Group();
            var trunkMat = new THREE.MeshStandardMaterial({ color: 0x2a1a0a, roughness: 0.95 });
            var trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.25, 4 + Math.random() * 3, 6), trunkMat);
            trunk.position.y = 2;
            tg.add(trunk);
            var foliageMat = new THREE.MeshStandardMaterial({ color: 0x0a1a05, roughness: 0.95 });
            var foliageH = 3 + Math.random() * 2;
            var foliage = new THREE.Mesh(new THREE.ConeGeometry(1.5 + Math.random(), foliageH, 6), foliageMat);
            foliage.position.y = 4 + foliageH / 2;
            tg.add(foliage);
            tg.position.set(x, -0.5, z);
            return tg;
        }
        // Ring of trees around crash site
        for (var t = 0; t < 20; t++) {
            var angle = (t / 20) * Math.PI * 2;
            var dist = 35 + Math.random() * 15;
            survivalGroup.add(makeTree(Math.cos(angle) * dist, Math.sin(angle) * dist));
        }
        // Some closer trees
        survivalGroup.add(makeTree(20, 15));
        survivalGroup.add(makeTree(-22, 10));
        survivalGroup.add(makeTree(15, -18));

        // Fire glow (multiple lights for realism)
        var fireLight = new THREE.PointLight(0xff6600, 2, 30);
        fireLight.position.set(5, 2, -3);
        survivalGroup.add(fireLight);
        var fireLight2 = new THREE.PointLight(0xff4400, 1.5, 20);
        fireLight2.position.set(-6, 1.5, -7);
        survivalGroup.add(fireLight2);

        // Fire particles (mesh clusters)
        for (var f = 0; f < 12; f++) {
            var fireX = f < 8 ? 5 + (Math.random() - 0.5) * 4 : -6 + (Math.random() - 0.5) * 3;
            var fireZ = f < 8 ? -3 + (Math.random() - 0.5) * 4 : -7 + (Math.random() - 0.5) * 3;
            var flame = new THREE.Mesh(
                new THREE.ConeGeometry(0.3 + Math.random() * 0.5, 1 + Math.random() * 2, 6),
                new THREE.MeshBasicMaterial({
                    color: Math.random() < 0.3 ? 0xff2200 : (Math.random() < 0.6 ? 0xff6600 : 0xffaa00),
                    transparent: true, opacity: 0.8
                })
            );
            flame.position.set(fireX, 0.5 + Math.random(), fireZ);
            flame.userData.baseY = flame.position.y;
            flame.userData.flicker = Math.random() * Math.PI * 2;
            survivalGroup.add(flame);
        }

        // Smoke column (thicker, more realistic)
        for (var sm = 0; sm < 18; sm++) {
            var smokeR = 1.5 + sm * 0.3 + Math.random() * 1.5;
            var smoke = new THREE.Mesh(
                new THREE.SphereGeometry(smokeR, 6, 6),
                new THREE.MeshBasicMaterial({ color: sm < 6 ? 0x333333 : 0x1a1a1a, transparent: true, opacity: 0.35 - sm * 0.015 })
            );
            smoke.position.set(5 + (Math.random() - 0.5) * 3, 4 + sm * 2.5, -3 + (Math.random() - 0.5) * 3);
            survivalGroup.add(smoke);
        }

        // Emergency flashers on ground (scattered)
        for (var ef = 0; ef < 6; ef++) {
            var flasher = new THREE.Mesh(
                new THREE.SphereGeometry(0.1, 6, 6),
                new THREE.MeshBasicMaterial({ color: 0xff0000 })
            );
            flasher.position.set(-12 + ef * 6, 0.1, 10 + Math.sin(ef) * 3);
            flasher.userData.flashPhase = ef * 0.5;
            survivalGroup.add(flasher);
        }

        // ── Scattered papers / documents ──
        var paperMat = new THREE.MeshBasicMaterial({ color: 0xeeeedd, side: THREE.DoubleSide });
        for (var pp = 0; pp < 8; pp++) {
            var paper = new THREE.Mesh(new THREE.PlaneGeometry(0.15, 0.2), paperMat);
            paper.position.set((Math.random() - 0.5) * 20, 0.02 + Math.random() * 0.5, (Math.random() - 0.5) * 20);
            paper.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
            survivalGroup.add(paper);
        }

        survivalGroup.visible = false;
    }

    // ═══════════════════════════════════════════════════
    //  RAIN SYSTEM (2D canvas overlay)
    // ═══════════════════════════════════════════════════
    var rainCanvas = document.getElementById('rain-canvas');
    var rainCtx = rainCanvas.getContext('2d');
    var rainDrops = [];

    function initRain() {
        rainCanvas.width = window.innerWidth;
        rainCanvas.height = window.innerHeight;
        for (var i = 0; i < 200; i++) {
            rainDrops.push({
                x: Math.random() * rainCanvas.width,
                y: Math.random() * rainCanvas.height,
                len: 10 + Math.random() * 20,
                speed: 8 + Math.random() * 12,
                opacity: 0.1 + Math.random() * 0.3
            });
        }
    }

    function updateRain() {
        if (G.rainIntensity <= 0) return;
        rainCtx.clearRect(0, 0, rainCanvas.width, rainCanvas.height);
        for (var i = 0; i < rainDrops.length; i++) {
            var d = rainDrops[i];
            d.y += d.speed * G.rainIntensity;
            d.x -= 2 * G.rainIntensity;
            if (d.y > rainCanvas.height) { d.y = -d.len; d.x = Math.random() * rainCanvas.width; }
            if (d.x < 0) d.x = rainCanvas.width;
            rainCtx.beginPath();
            rainCtx.moveTo(d.x, d.y);
            rainCtx.lineTo(d.x + 1, d.y + d.len * G.rainIntensity);
            rainCtx.strokeStyle = 'rgba(180,200,220,' + (d.opacity * G.rainIntensity) + ')';
            rainCtx.lineWidth = 1;
            rainCtx.stroke();
        }
    }

    // ═══════════════════════════════════════════════════
    //  UI HELPERS
    // ═══════════════════════════════════════════════════
    var $phase = document.getElementById('phase-label');
    var $alt = document.getElementById('altitude-box');
    var $altVal = document.getElementById('alt-val');
    var $spdVal = document.getElementById('spd-val');
    var $hdgVal = document.getElementById('hdg-val');
    var $prompt = document.getElementById('prompt');
    var $sub = document.getElementById('sub-prompt');
    var $seatbelt = document.getElementById('seatbelt-sign');
    var $captain = document.getElementById('captain-box');
    var $captainText = document.getElementById('captain-text');
    var $warning = document.getElementById('warning');
    var $fade = document.getElementById('fade');
    var $flash = document.getElementById('flash');
    var $eStrip = document.getElementById('emergency-strip');
    var $survival = document.getElementById('survival-text');
    var $continueBtn = document.getElementById('continue-btn');

    function showPrompt(text, dur) {
        $prompt.textContent = text;
        $prompt.classList.add('visible');
        if (dur) setTimeout(function() { $prompt.classList.remove('visible'); }, dur);
    }
    function hidePrompt() { $prompt.classList.remove('visible'); }

    function showSub(text) { $sub.textContent = text; $sub.classList.add('visible'); }
    function hideSub() { $sub.classList.remove('visible'); }

    function showCaptain(text, dur) {
        $captain.querySelector('.captain-label').textContent = '— Captain Speaking —';
        $captainText.textContent = text;
        $captain.classList.add('visible');
        playDing();
        if (dur) setTimeout(function() { $captain.classList.remove('visible'); }, dur);
    }
    function hideCaptain() { $captain.classList.remove('visible'); }

    function showWarning(text) { $warning.textContent = text; $warning.classList.add('visible'); }
    function hideWarning() { $warning.classList.remove('visible'); }

    function fadeIn(dur) {
        $fade.style.transition = 'opacity ' + (dur || 1.5) + 's ease';
        $fade.classList.add('visible');
    }
    function fadeOut(dur) {
        $fade.style.transition = 'opacity ' + (dur || 1.5) + 's ease';
        $fade.classList.remove('visible');
    }

    function doFlash(intensity, dur) {
        $flash.style.opacity = intensity || 0.9;
        $flash.style.transition = 'opacity ' + (dur || 0.5) + 's ease-out';
        setTimeout(function() { $flash.style.opacity = 0; }, 50);
    }

    function setPhaseLabel(txt) { $phase.textContent = txt; }

    function updateHUD() {
        $altVal.textContent = Math.max(0, Math.round(G.altitude)).toLocaleString();
        $spdVal.textContent = Math.round(G.speed);
        $hdgVal.textContent = Math.round(G.heading);
    }

    // ═══════════════════════════════════════════════════
    //  PHASE SYSTEM
    // ═══════════════════════════════════════════════════
    var phaseTimers = [];

    function clearPhaseTimers() {
        for (var i = 0; i < phaseTimers.length; i++) clearTimeout(phaseTimers[i]);
        phaseTimers = [];
    }

    function pt(fn, delay) {
        phaseTimers.push(setTimeout(fn, delay));
    }

    function goPhase(phase) {
        clearPhaseTimers();
        G.phase = phase;
        G.transitioning = true;

        switch (phase) {

        // ─── AIRPORT ───
        case 'airport':
            setPhaseLabel('Airport Terminal');
            airportGroup.visible = true;
            planeExtGroup.visible = true;
            cabinGroup.visible = false;
            stormCloudGroup.visible = false;
            survivalGroup.visible = false;
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.FogExp2(0x87CEEB, 0.0008);
            // Camera offset showing the plane prominently with terminal in background
            camera.position.set(5, 5.0, 28);
            camera.lookAt(new THREE.Vector3(18, 3.5, 0));
            G.cameraBasePos.copy(camera.position);
            showPrompt('Welcome to the airport.', 3500);
            pt(function() {
                showSub('Click to begin boarding');
                G.canClick = true;
                G.transitioning = false;
            }, 1500);
            break;

        // ─── BOARDING ───
        case 'boarding':
            G.canClick = false;
            setPhaseLabel('Boarding');
            showPrompt('Boarding the aircraft...', 3000);
            hideSub();

            pt(function() {
                fadeIn(1.5);
            }, 2000);

            pt(function() {
                airportGroup.visible = false;
                planeExtGroup.visible = false;
                cabinGroup.visible = true;

                // Standing in aisle at rear of cabin, looking forward (+Z)
                camera.position.set(0, 1.65, -9);
                camera.rotation.set(0, 0, 0);
                G.cameraBasePos.copy(camera.position);
                G.lookX = 0; G.lookY = 0;
                G.targetLookX = 0; G.targetLookY = 0;

                setCabinVolume(0.15);
                fadeOut(1.5);
            }, 4000);

            pt(function() {
                setPhaseLabel('Finding Your Seat');
                showPrompt('Find your seat...', 2500);
            }, 5500);

            pt(function() {
                showSub('Click to take your window seat');
                G.canClick = true;
                G.transitioning = false;
            }, 7000);
            break;

        // ─── SEATED ───
        case 'seated':
            G.canClick = false;
            setPhaseLabel('Seated');

            // Animate to window seat (seat A, left side +X, mid-cabin)
            // Eye height when seated: ~1.15m (seat at 0.48m + torso)
            var seatTarget = new THREE.Vector3(1.45, 1.15, -2);
            animateCamera(seatTarget, 1500, function() {
                camera.position.copy(seatTarget);
                G.cameraBasePos.copy(camera.position);
                G.lookX = 0; G.lookY = 0;

                showPrompt('Please fasten your seatbelt.', 2500);
                playDing();
            });

            pt(function() {
                showCaptain(
                    'Good afternoon, ladies and gentlemen. Welcome aboard. ' +
                    'This is your captain speaking. We\'ll be cruising at 35,000 feet today. ' +
                    'Flight time will be approximately three hours. ' +
                    'Please fasten your seatbelts and ensure your tray tables are in the upright position.',
                    9000
                );
            }, 4000);

            pt(function() {
                $seatbelt.classList.add('visible');
            }, 4500);

            pt(function() {
                showSub('Click when ready for departure');
                G.canClick = true;
                G.transitioning = false;
            }, 13500);
            break;

        // ─── TAXI ───
        case 'taxi':
            G.canClick = false;
            setPhaseLabel('Taxiing');
            hideSub();

            showPrompt('Taxiing to runway...', 3000);
            G.shakeAmount = 0.003;
            setEngineVolume(0.15);

            pt(function() {
                showCaptain(
                    'Cabin crew, please prepare for takeoff.',
                    3500
                );
            }, 3500);

            pt(function() {
                G.transitioning = false;
                goPhase('takeoff');
            }, 8000);
            break;

        // ─── TAKEOFF ───
        case 'takeoff':
            setPhaseLabel('Takeoff');
            $alt.classList.add('visible');
            showPrompt('Prepare for takeoff...', 2500);
            G.speed = 0;

            setEngineVolume(0.5);

            var toAccel = setInterval(function() {
                G.speed += 3;
                G.shakeAmount = 0.004 + G.speed * 0.00015;
                setEngineVolume(Math.min(0.8, 0.3 + G.speed * 0.003));
                setWindVolume(Math.min(0.3, G.speed * 0.002));
                updateHUD();

                if (G.speed >= 165) {
                    clearInterval(toAccel);
                    showPrompt('Rotate...', 1500);
                    pt(function() { goPhase('climbing'); }, 1800);
                }
            }, 80);
            phaseTimers.push(toAccel);
            break;

        // ─── CLIMBING ───
        case 'climbing':
            setPhaseLabel('Climbing');
            showPrompt('Climbing to cruising altitude...', 3000);
            G.pitch = 5;

            var climbInt = setInterval(function() {
                G.altitude += 400;
                G.shakeAmount = Math.max(0.001, G.shakeAmount * 0.995);

                // Sky color transitions with altitude
                var f = Math.min(G.altitude / 35000, 1);
                var skyCol = new THREE.Color().lerpColors(
                    new THREE.Color(0x87CEEB),
                    new THREE.Color(0x1a3a6e),
                    f
                );
                scene.background = skyCol;
                scene.fog.color = skyCol;
                renderer.toneMappingExposure = 1.0 - f * 0.3;

                updateHUD();

                if (G.altitude >= 35000) {
                    clearInterval(climbInt);
                    G.pitch = 0;
                    goPhase('cruising');
                }
            }, 150);
            phaseTimers.push(climbInt);
            break;

        // ─── CRUISING ───
        case 'cruising':
            setPhaseLabel('Cruising — 35,000 ft');
            $seatbelt.classList.remove('visible');
            G.shakeAmount = 0.0004;
            G.speed = 480;

            showPrompt('You may now move about the cabin.', 3000);
            setEngineVolume(0.2);
            setWindVolume(0.15);
            setCabinVolume(0.2);

            pt(function() {
                showCaptain(
                    'We\'ve reached our cruising altitude of 35,000 feet. ' +
                    'The seatbelt sign has been turned off. ' +
                    'Sit back and enjoy the flight.',
                    6000
                );
            }, 4000);

            pt(function() {
                showPrompt('Smooth skies ahead...', 3000);
            }, 12000);

            // Transition to turbulence
            pt(function() {
                G.transitioning = false;
                goPhase('turbulence_light');
            }, 18000);
            break;

        // ─── LIGHT TURBULENCE ───
        case 'turbulence_light':
            setPhaseLabel('Light Turbulence');
            $seatbelt.classList.add('visible');
            playDing();

            pt(function() {
                showCaptain(
                    'Ladies and gentlemen, we\'re experiencing some light turbulence. ' +
                    'Please return to your seats and fasten your seatbelts.',
                    5000
                );
            }, 500);

            var ltLevel = 0;
            var ltInt = setInterval(function() {
                ltLevel += 0.05;
                G.shakeAmount = 0.003 + ltLevel * 0.004;
                G.roll = Math.sin(G.time * 2) * ltLevel * 2;
            }, 200);
            phaseTimers.push(ltInt);

            pt(function() {
                clearInterval(ltInt);
                goPhase('storm');
            }, 8000);
            break;

        // ─── STORM ───
        case 'storm':
            setPhaseLabel('Severe Turbulence');

            // Darken sky
            scene.background = new THREE.Color(0x0a0a15);
            scene.fog = new THREE.FogExp2(0x0a0a15, 0.003);
            renderer.toneMappingExposure = 0.4;

            stormCloudGroup.visible = true;
            cloudGroup.visible = false;

            // Rain
            G.rainIntensity = 0.6;
            rainCanvas.classList.add('visible');

            // Dim cabin lights
            dimCabinLights(true);

            setEngineVolume(0.6);
            setWindVolume(0.5);

            showPrompt('Weather ahead...', 2000);

            var stormLevel = 0;
            var stormInt = setInterval(function() {
                stormLevel += 0.04;
                G.shakeAmount = 0.008 + stormLevel * 0.008;
                G.roll = Math.sin(G.time * 3) * stormLevel * 3;
                G.pitch = Math.sin(G.time * 1.5) * stormLevel;
                G.rainIntensity = Math.min(1.0, 0.6 + stormLevel * 0.2);
                setWindVolume(Math.min(0.8, 0.5 + stormLevel * 0.1));
            }, 200);
            phaseTimers.push(stormInt);

            // Lightning strikes
            pt(function() { triggerLightning(); }, 3000);
            pt(function() { triggerLightning(); }, 5500);
            pt(function() { triggerLightning(); }, 7000);
            pt(function() { triggerLightning(); }, 8200);
            pt(function() { triggerLightning(); triggerLightning(); }, 9500);

            pt(function() {
                showCaptain(
                    'We are passing through a severe storm cell. ' +
                    'Please remain calm and keep your seatbelts tightly fastened.',
                    5000
                );
            }, 4000);

            pt(function() {
                clearInterval(stormInt);
                goPhase('lightning_intense');
            }, 12000);
            break;

        // ─── INTENSE LIGHTNING ───
        case 'lightning_intense':
            setPhaseLabel('⚡ Electrical Storm');

            G.shakeAmount = 0.03;
            G.rainIntensity = 1.0;
            setWindVolume(0.9);
            setEngineVolume(0.8);

            // Rapid lightning
            var lnCount = 0;
            var lnInt = setInterval(function() {
                triggerLightning();
                lnCount++;
                G.shakeAmount = 0.03 + Math.random() * 0.02;
                G.roll = (Math.random() - 0.5) * 8;
                G.pitch = (Math.random() - 0.5) * 3;

                // Altitude drops
                G.altitude -= 200 + Math.random() * 300;
                updateHUD();
            }, 800);
            phaseTimers.push(lnInt);

            pt(function() {
                showPrompt('', 100);
                showWarning('SEVERE TURBULENCE');
            }, 1000);

            pt(function() {
                hideWarning();
            }, 3000);

            // Big lightning hit
            pt(function() {
                clearInterval(lnInt);
                doFlash(1.0, 0.8);
                playThunder();
                G.shakeAmount = 0.08;
                showWarning('⚡ LIGHTNING STRIKE');

                // Brief power flicker
                flickerCabinLights();
            }, 6000);

            pt(function() {
                hideWarning();
                goPhase('emergency');
            }, 8500);
            break;

        // ─── EMERGENCY ───
        case 'emergency':
            setPhaseLabel('🔴 EMERGENCY');
            $phase.style.background = 'rgba(200,0,0,0.8)';
            playAlarm();

            // Systems failing
            showWarning('BRACE FOR IMPACT');

            // Drop oxygen masks
            dropOxygenMasks();

            // Emergency lights
            G.emergencyLights = true;
            $eStrip.classList.add('visible');
            for (var i = 0; i < emergencyLightMeshes.length; i++) {
                emergencyLightMeshes[i].visible = true;
            }

            // Kill main cabin lights
            setCabinLightsPower(false);

            G.shakeAmount = 0.06;
            G.rainIntensity = 1.0;
            setWindVolume(1.0);

            pt(function() {
                showCaptain(
                    'BRACE BRACE BRACE! Heads down, stay down!',
                    4000
                );
            }, 2000);

            // Rapid descent
            var descInt = setInterval(function() {
                G.altitude -= 1500;
                G.speed += 5;
                G.shakeAmount = 0.05 + (35000 - Math.max(0, G.altitude)) / 35000 * 0.08;
                G.pitch = -8 - (35000 - Math.max(0, G.altitude)) / 35000 * 10;

                // Sky changes during descent
                var descF = Math.max(0, G.altitude) / 35000;
                scene.background.lerpColors(
                    new THREE.Color(0x1a0a0a),
                    new THREE.Color(0x0a0a15),
                    descF
                );

                updateHUD();

                if (G.altitude <= 0) {
                    clearInterval(descInt);
                    goPhase('crash');
                }
            }, 100);
            phaseTimers.push(descInt);
            break;

        // ─── CRASH ───
        case 'crash':
            G.altitude = 0;
            G.speed = 0;
            setPhaseLabel('IMPACT');

            playImpact();
            doFlash(1.0, 0.3);
            G.shakeAmount = 0.15;

            setEngineVolume(0);
            setWindVolume(0);
            setCabinVolume(0);

            showWarning('');
            hideWarning();

            // Violent shake then fade
            pt(function() {
                G.shakeAmount = 0.08;
            }, 500);

            pt(function() {
                G.shakeAmount = 0.03;
                fadeIn(2);
            }, 1500);

            pt(function() {
                G.shakeAmount = 0;
                goPhase('survival');
            }, 4000);
            break;

        // ─── SURVIVAL ───
        case 'survival':
            setPhaseLabel('');
            $alt.classList.remove('visible');
            $seatbelt.classList.remove('visible');
            $eStrip.classList.remove('visible');
            hideWarning();
            hideSub();
            $phase.style.background = '';
            G.rainIntensity = 0.3;

            cabinGroup.visible = false;
            stormCloudGroup.visible = false;
            airportGroup.visible = false;
            survivalGroup.visible = true;

            scene.background = new THREE.Color(0x050508);
            scene.fog = new THREE.FogExp2(0x050508, 0.02);
            renderer.toneMappingExposure = 0.5;
            ambientLight.intensity = 0.15;

            camera.position.set(0, 1.7, 15);
            camera.lookAt(new THREE.Vector3(5, 1, -3));
            G.cameraBasePos.copy(camera.position);
            G.shakeAmount = 0;

            fadeOut(3);

            pt(function() {
                $survival.innerHTML = 'You survived.';
                $survival.classList.add('visible');
            }, 3000);

            pt(function() {
                $survival.classList.remove('visible');
            }, 6000);

            pt(function() {
                $survival.innerHTML =
                    'In reality, 95.7% of passengers survive plane crashes.<br><br>' +
                    'Flying remains the safest form of long-distance travel.<br><br>' +
                    'Your chances of being in a fatal crash are<br><b style="font-size:2rem">1 in 13,700,000</b>';
                $survival.classList.add('visible');
            }, 7500);

            pt(function() {
                $continueBtn.classList.add('visible');
            }, 12000);
            break;
        }
    }

    // ═══════════════════════════════════════════════════
    //  CABIN LIGHT CONTROLS
    // ═══════════════════════════════════════════════════
    function dimCabinLights(dim) {
        G.cabinLightsDim = dim;
        var targetIntensity = dim ? 0.1 : 0.4;
        for (var i = 0; i < cabinLights.length; i++) {
            cabinLights[i].intensity = targetIntensity;
        }
        for (var j = 0; j < cabinLightMeshes.length; j++) {
            cabinLightMeshes[j].material = dim ? MAT.lightEmitDim : MAT.lightEmit;
        }
    }

    function setCabinLightsPower(on) {
        G.cabinLightsOn = on;
        for (var i = 0; i < cabinLights.length; i++) {
            cabinLights[i].intensity = on ? 0.1 : 0;
        }
        for (var j = 0; j < cabinLightMeshes.length; j++) {
            cabinLightMeshes[j].visible = on;
        }
    }

    function flickerCabinLights() {
        var count = 0;
        var flickInt = setInterval(function() {
            count++;
            var on = count % 2 === 0;
            for (var i = 0; i < cabinLights.length; i++) {
                cabinLights[i].intensity = on ? 0.15 : 0;
            }
            for (var j = 0; j < cabinLightMeshes.length; j++) {
                cabinLightMeshes[j].visible = on;
            }
            if (count > 8) {
                clearInterval(flickInt);
                dimCabinLights(true);
            }
        }, 100);
    }

    // ═══════════════════════════════════════════════════
    //  LIGHTNING EFFECT
    // ═══════════════════════════════════════════════════
    function triggerLightning() {
        doFlash(0.6 + Math.random() * 0.4, 0.3 + Math.random() * 0.4);
        playThunder();

        // Create lightning bolt geometry in scene
        var bolt = createLightningBolt();
        lightningGroup.add(bolt);
        setTimeout(function() { lightningGroup.remove(bolt); }, 200);
    }

    function createLightningBolt() {
        var points = [];
        var x = (Math.random() - 0.5) * 100;
        var z = (Math.random() - 0.5) * 100;
        var y = 50 + Math.random() * 30;
        for (var i = 0; i < 10; i++) {
            points.push(new THREE.Vector3(
                x + (Math.random() - 0.5) * 10,
                y - i * (y / 10),
                z + (Math.random() - 0.5) * 10
            ));
        }
        var geo = new THREE.BufferGeometry().setFromPoints(points);
        var mat = new THREE.LineBasicMaterial({ color: 0xeeeeff, linewidth: 2 });
        return new THREE.Line(geo, mat);
    }

    // ═══════════════════════════════════════════════════
    //  OXYGEN MASKS
    // ═══════════════════════════════════════════════════
    function dropOxygenMasks() {
        var positions = ['25%', '40%', '55%', '70%'];
        for (var i = 0; i < positions.length; i++) {
            (function(idx) {
                pt(function() {
                    var mask = document.createElement('div');
                    mask.className = 'oxygen-mask';
                    mask.style.left = positions[idx];
                    mask.style.top = '-100px';
                    mask.innerHTML = '<div class="mask-tube"></div><div class="mask-cup"></div>';
                    document.body.appendChild(mask);

                    setTimeout(function() {
                        mask.style.opacity = '1';
                        mask.style.transform = 'translateY(200px)';
                    }, 50);
                }, idx * 150);
            })(i);
        }
    }

    // ═══════════════════════════════════════════════════
    //  CAMERA ANIMATION HELPER
    // ═══════════════════════════════════════════════════
    function animateCamera(target, duration, callback) {
        var start = camera.position.clone();
        var startTime = performance.now();
        function step(now) {
            var t = Math.min((now - startTime) / duration, 1);
            t = t * t * (3 - 2 * t); // smoothstep
            camera.position.lerpVectors(start, target, t);
            if (t < 1) {
                requestAnimationFrame(step);
            } else {
                if (callback) callback();
            }
        }
        requestAnimationFrame(step);
    }

    // ═══════════════════════════════════════════════════
    //  INPUT
    // ═══════════════════════════════════════════════════
    var audioStarted = false;

    document.addEventListener('click', function() {
        if (!audioStarted) {
            initAudio();
            audioStarted = true;
        }

        if (G.transitioning) return;
        if (!G.canClick) return;

        switch (G.phase) {
            case 'airport': goPhase('boarding'); break;
            case 'boarding': goPhase('seated'); break;
            case 'seated': goPhase('taxi'); break;
        }
    });

    document.addEventListener('mousemove', function(e) {
        G.mouseX = e.clientX;
        G.mouseY = e.clientY;
        if (['airport', 'boarding', 'seated', 'cruising'].indexOf(G.phase) !== -1) {
            G.targetLookX = (e.clientX / window.innerWidth - 0.5) * 0.6;
            G.targetLookY = (e.clientY / window.innerHeight - 0.5) * 0.3;
        }
    });

    // Continue button → back to parent
    $continueBtn.addEventListener('click', function() {
        if (window.parent !== window) {
            window.parent.postMessage('simulation-complete', '*');
        }
    });

    // ═══════════════════════════════════════════════════
    //  MAIN ANIMATION LOOP
    // ═══════════════════════════════════════════════════
    var clock = new THREE.Clock();

    function animate() {
        requestAnimationFrame(animate);
        G.delta = Math.min(clock.getDelta(), 0.1);
        G.time += G.delta;

        // ── Smooth look ──
        G.lookX += (G.targetLookX - G.lookX) * 0.04;
        G.lookY += (G.targetLookY - G.lookY) * 0.04;

        // ── Camera shake ──
        if (G.shakeAmount > 0.0001) {
            camera.position.x = G.cameraBasePos.x + (Math.random() - 0.5) * G.shakeAmount * 2;
            camera.position.y = G.cameraBasePos.y + (Math.random() - 0.5) * G.shakeAmount * 2;
            camera.position.z = G.cameraBasePos.z + (Math.random() - 0.5) * G.shakeAmount;
            camera.rotation.z = (Math.random() - 0.5) * G.shakeAmount * 0.4;
        }

        // ── Phase-specific camera ──
        if (G.phase === 'airport') {
            // Looking from terminal toward plane
            camera.rotation.y = -1.1 + G.lookX;
            camera.rotation.x = -0.05 + G.lookY * 0.3;
        }
        if (G.phase === 'boarding') {
            // Standing in aisle, looking forward (+Z)
            camera.rotation.y = G.lookX * 0.8;
            camera.rotation.x = G.lookY * 0.3;
        }
        if (G.phase === 'seated' || G.phase === 'taxi' || G.phase === 'takeoff' ||
            G.phase === 'climbing') {
            // Looking out left window (+X direction) = camera rotY ~ -PI/2
            camera.rotation.y = -Math.PI / 2 + G.lookX * 0.5;
            camera.rotation.x = G.lookY * 0.3;
        }
        if (['cruising', 'turbulence_light', 'storm', 'lightning_intense', 'emergency'].indexOf(G.phase) !== -1) {
            // Mostly looking out window with subtle drift
            camera.rotation.y = -Math.PI / 2 + Math.sin(G.time * 0.15) * 0.02 + G.lookX * 0.4;
            camera.rotation.x = G.lookY * 0.2 + G.pitch * 0.01;
            camera.rotation.z += G.roll * 0.005;
        }
        if (G.phase === 'crash') {
            camera.rotation.y = -Math.PI / 2;
            camera.rotation.x = G.pitch * 0.015;
        }
        if (G.phase === 'survival') {
            // Looking at wreckage/fire
            camera.rotation.y = Math.PI * 0.05 + Math.sin(G.time * 0.1) * 0.02 + G.lookX * 0.2;
            camera.rotation.x = -0.05 + G.lookY * 0.1;
        }

        // ── Animate engine fans ──
        var fanSpeed = G.phase === 'airport' ? 2 : (G.speed > 0 ? 15 + G.speed * 0.05 : 0);
        for (var ef = 0; ef < engineFans.length; ef++) {
            engineFans[ef].rotation.z += fanSpeed * G.delta;
        }

        // ── Animate clouds ──
        var cSpeed = G.speed * 0.08;
        cloudGroup.children.forEach(function(c) {
            c.position.x -= c.userData.speed * G.delta * cSpeed;
            if (c.position.x < -300) {
                c.position.x = 300;
                c.position.z = (Math.random() - 0.5) * 600;
            }
        });
        stormCloudGroup.children.forEach(function(c) {
            c.position.x -= c.userData.speed * G.delta * cSpeed * 0.5;
            if (c.position.x < -250) {
                c.position.x = 250;
                c.position.z = (Math.random() - 0.5) * 500;
            }
        });

        // ── Emergency light flashing ──
        if (G.emergencyLights) {
            var emOn = Math.sin(G.time * 6) > 0;
            for (var el = 0; el < emergencyLightMeshes.length; el++) {
                emergencyLightMeshes[el].visible = (el + (emOn ? 0 : 1)) % 2 === 0;
            }
        }

        // ── Survival fire flicker ──
        if (G.phase === 'survival') {
            survivalGroup.children.forEach(function(child) {
                if (child.userData.flicker !== undefined) {
                    child.userData.flicker += G.delta * 5;
                    child.position.y = child.userData.baseY + Math.sin(child.userData.flicker) * 0.2;
                    child.scale.x = 0.8 + Math.sin(child.userData.flicker * 1.3) * 0.3;
                }
                if (child.userData.flashPhase !== undefined) {
                    child.visible = Math.sin(G.time * 4 + child.userData.flashPhase) > 0.3;
                }
            });
        }

        // ── Rain ──
        updateRain();

        // ── Render ──
        renderer.render(scene, camera);
    }

    // ═══════════════════════════════════════════════════
    //  WINDOW RESIZE
    // ═══════════════════════════════════════════════════
    window.addEventListener('resize', function() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        rainCanvas.width = window.innerWidth;
        rainCanvas.height = window.innerHeight;
    });

    // ═══════════════════════════════════════════════════
    //  INIT & START
    // ═══════════════════════════════════════════════════
    buildAirport();
    buildCabin();
    populateClouds();
    populateStormClouds();
    buildSurvivalScene();
    initRain();

    // Start
    fadeOut(2);
    pt(function() { goPhase('airport'); }, 500);

    animate();

    })();
    </script>
</body>
</html>
