<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flight Experience - FAAH</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; background: #000; font-family: 'Georgia', serif; cursor: default; }
        canvas { display: block; }

        /* HUD */
        #hud {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 10;
        }
        #hud > * { pointer-events: auto; }

        #phase-label {
            position: fixed; top: 20px; left: 20px;
            color: #fff; font-size: 14px; z-index: 20;
            background: rgba(0,0,0,0.5); padding: 8px 16px; border-radius: 6px;
            text-transform: uppercase; letter-spacing: 2px;
            pointer-events: none;
        }
        #altitude-box {
            position: fixed; top: 20px; right: 20px;
            color: #fff; font-size: 13px; z-index: 20;
            background: rgba(0,0,0,0.5); padding: 8px 16px; border-radius: 6px;
            font-family: 'Courier New', monospace;
            opacity: 0; transition: opacity 0.8s;
            pointer-events: none;
        }
        #altitude-box.visible { opacity: 1; }

        #prompt {
            position: fixed; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: #fff; font-size: 1.6rem; text-align: center;
            pointer-events: none; z-index: 30;
            opacity: 0; transition: opacity 1s ease;
            text-shadow: 0 2px 20px rgba(0,0,0,0.8);
            max-width: 80%; line-height: 1.6;
        }
        #prompt.visible { opacity: 1; }

        #sub-prompt {
            position: fixed; bottom: 10%; left: 50%;
            transform: translateX(-50%);
            color: rgba(255,255,255,0.7); font-size: 0.95rem; text-align: center;
            pointer-events: none; z-index: 30;
            opacity: 0; transition: opacity 0.8s ease;
            text-shadow: 0 1px 10px rgba(0,0,0,0.8);
            background: rgba(0,0,0,0.35); padding: 10px 24px; border-radius: 8px;
        }
        #sub-prompt.visible { opacity: 1; }

        /* Seatbelt sign */
        #seatbelt-sign {
            position: fixed; top: 75px; left: 50%; transform: translateX(-50%);
            background: linear-gradient(145deg, #ff4444, #cc0000);
            color: #fff; padding: 10px 22px; border-radius: 6px;
            font-size: 0.95rem; z-index: 25;
            opacity: 0; transition: opacity 0.4s;
            box-shadow: 0 0 25px rgba(255,0,0,0.4);
            letter-spacing: 2px; text-transform: uppercase;
            pointer-events: none;
        }
        #seatbelt-sign.visible { opacity: 1; animation: pulse-sign 1.2s infinite; }
        @keyframes pulse-sign {
            0%,100% { box-shadow: 0 0 25px rgba(255,0,0,0.4); }
            50% { box-shadow: 0 0 45px rgba(255,0,0,0.8); }
        }

        /* Captain announcement */
        #captain-box {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%,-50%);
            background: rgba(0,0,0,0.85); color: #fff;
            padding: 30px 50px; border-radius: 12px;
            font-size: 1.1rem; z-index: 35;
            opacity: 0; transition: opacity 0.6s;
            max-width: 600px; text-align: center; line-height: 1.8;
            border: 1px solid rgba(255,255,255,0.1);
            pointer-events: none;
        }
        #captain-box.visible { opacity: 1; }
        #captain-box .captain-label {
            font-size: 0.75rem; letter-spacing: 3px; text-transform: uppercase;
            color: rgba(255,255,255,0.4); margin-bottom: 12px;
        }

        /* Fade overlay */
        #fade {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 50; opacity: 0;
            pointer-events: none; transition: opacity 1.5s ease;
        }
        #fade.visible { opacity: 1; pointer-events: all; }

        /* Flash (lightning) */
        #flash {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #fff; z-index: 40; opacity: 0;
            pointer-events: none;
        }

        /* Warning */
        #warning {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%,-50%);
            color: #ff4444; font-size: 2.2rem; z-index: 45;
            opacity: 0; transition: opacity 0.4s;
            text-shadow: 0 0 40px rgba(255,0,0,0.6);
            text-align: center; font-weight: bold;
            letter-spacing: 3px; pointer-events: none;
        }
        #warning.visible { opacity: 1; }

        /* Continue button */
        #continue-btn {
            position: fixed; bottom: 25%; left: 50%; transform: translateX(-50%);
            background: rgba(255,255,255,0.9); color: #222;
            border: none; padding: 14px 44px; font-size: 1.1rem;
            font-family: 'Georgia', serif; cursor: pointer;
            z-index: 55; border-radius: 8px;
            opacity: 0; transition: opacity 0.6s;
            pointer-events: none;
        }
        #continue-btn.visible { opacity: 1; pointer-events: auto; }
        #continue-btn:hover { background: #fff; transform: translateX(-50%) scale(1.05); }

        /* Oxygen masks */
        .oxygen-mask {
            position: fixed; z-index: 32; pointer-events: none;
            width: 40px; opacity: 0;
            transition: transform 1.2s cubic-bezier(0.2,0.8,0.3,1), opacity 0.3s;
        }
        .oxygen-mask .mask-tube {
            width: 3px; height: 60px; background: #888; margin: 0 auto;
        }
        .oxygen-mask .mask-cup {
            width: 36px; height: 28px; background: linear-gradient(145deg, #ffcc00, #e6a800);
            border-radius: 0 0 18px 18px; margin: 0 auto;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        /* Emergency lights */
        .emergency-strip {
            position: fixed; bottom: 0; left: 0; width: 100%; height: 4px;
            z-index: 31; opacity: 0; transition: opacity 0.5s;
            pointer-events: none;
        }
        .emergency-strip.visible {
            opacity: 1;
            background: repeating-linear-gradient(90deg, #00ff00 0px, #00ff00 30px, transparent 30px, transparent 60px);
            animation: floor-lights 1s linear infinite;
        }
        @keyframes floor-lights {
            0% { background-position: 0 0; }
            100% { background-position: 60px 0; }
        }

        /* Rain overlay on window */
        #rain-canvas {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 5; pointer-events: none; opacity: 0;
            transition: opacity 1s;
        }
        #rain-canvas.visible { opacity: 1; }

        /* Survival scene text */
        #survival-text {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%,-50%);
            color: #fff; font-size: 1.4rem; text-align: center;
            z-index: 55; opacity: 0; transition: opacity 1s;
            max-width: 80%; line-height: 2;
            pointer-events: none;
        }
        #survival-text.visible { opacity: 1; }
    </style>
</head>
<body>
    <div id="hud">
        <div id="phase-label">Airport Terminal</div>
        <div id="altitude-box">
            ALT <span id="alt-val">0</span> ft<br>
            SPD <span id="spd-val">0</span> kts<br>
            HDG <span id="hdg-val">270</span>°
        </div>
        <div id="seatbelt-sign">⚠ Fasten Seatbelt</div>
    </div>

    <div id="prompt"></div>
    <div id="sub-prompt"></div>
    <div id="captain-box"><div class="captain-label"></div><div id="captain-text"></div></div>
    <div id="warning"></div>
    <div id="fade"></div>
    <div id="flash"></div>
    <div class="emergency-strip" id="emergency-strip"></div>
    <canvas id="rain-canvas"></canvas>
    <div id="survival-text"></div>
    <button id="continue-btn">Continue</button>

    <script src="https://cdn.jsdelivr.net/npm/three@0.152.0/build/three.min.js"></script>
    <script>
    (function() {
    'use strict';

    // ═══════════════════════════════════════════════════
    //  RENDERER & SCENE
    // ═══════════════════════════════════════════════════
    var renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.0;
    document.body.appendChild(renderer.domElement);

    var scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x87CEEB, 0.0008);

    var camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 5000);

    // ═══════════════════════════════════════════════════
    //  GAME STATE
    // ═══════════════════════════════════════════════════
    var G = {
        phase: 'airport',
        time: 0,
        delta: 0,
        altitude: 0,
        speed: 0,
        heading: 270,
        pitch: 0,
        roll: 0,
        shakeAmount: 0,
        shakeDecay: 0.95,
        cameraBasePos: new THREE.Vector3(),
        cameraBaseRot: new THREE.Euler(),
        lookX: 0, lookY: 0,
        targetLookX: 0, targetLookY: 0,
        mouseX: 0, mouseY: 0,
        canClick: true,
        transitioning: false,
        lightningTimer: 0,
        rainIntensity: 0,
        emergencyLights: false,
        cabinLightsOn: true,
        cabinLightsDim: false
    };

    // ═══════════════════════════════════════════════════
    //  WEB AUDIO - PROCEDURAL SOUND ENGINE
    // ═══════════════════════════════════════════════════
    var audioCtx = null;
    var masterGain = null;
    var engineNode = null, engineGain = null;
    var windNode = null, windGain = null;
    var cabinNode = null, cabinGain = null;

    function initAudio() {
        try {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            masterGain = audioCtx.createGain();
            masterGain.gain.value = 0.3;
            masterGain.connect(audioCtx.destination);

            // Engine rumble (low-frequency noise)
            var bufferSize = 2 * audioCtx.sampleRate;
            engineNode = audioCtx.createBufferSource();
            var engineBuffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            var engineData = engineBuffer.getChannelData(0);
            for (var i = 0; i < bufferSize; i++) {
                engineData[i] = (Math.random() * 2 - 1) * 0.3;
            }
            engineNode.buffer = engineBuffer;
            engineNode.loop = true;

            var engineFilter = audioCtx.createBiquadFilter();
            engineFilter.type = 'lowpass';
            engineFilter.frequency.value = 120;
            engineFilter.Q.value = 1;

            engineGain = audioCtx.createGain();
            engineGain.gain.value = 0;
            engineNode.connect(engineFilter);
            engineFilter.connect(engineGain);
            engineGain.connect(masterGain);
            engineNode.start();

            // Wind noise (high-frequency shaped noise)
            windNode = audioCtx.createBufferSource();
            var windBuffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            var windData = windBuffer.getChannelData(0);
            for (var j = 0; j < bufferSize; j++) {
                windData[j] = (Math.random() * 2 - 1);
            }
            windNode.buffer = windBuffer;
            windNode.loop = true;

            var windFilter = audioCtx.createBiquadFilter();
            windFilter.type = 'bandpass';
            windFilter.frequency.value = 800;
            windFilter.Q.value = 0.5;

            windGain = audioCtx.createGain();
            windGain.gain.value = 0;
            windNode.connect(windFilter);
            windFilter.connect(windGain);
            windGain.connect(masterGain);
            windNode.start();

            // Cabin ambience (very low noise)
            cabinNode = audioCtx.createBufferSource();
            var cabinBuffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            var cabinData = cabinBuffer.getChannelData(0);
            var prev = 0;
            for (var k = 0; k < bufferSize; k++) {
                prev = prev * 0.99 + (Math.random() * 2 - 1) * 0.01;
                cabinData[k] = prev * 3;
            }
            cabinNode.buffer = cabinBuffer;
            cabinNode.loop = true;

            cabinGain = audioCtx.createGain();
            cabinGain.gain.value = 0;
            cabinNode.connect(cabinGain);
            cabinGain.connect(masterGain);
            cabinNode.start();

        } catch(e) { /* Audio not available */ }
    }

    function setEngineVolume(v) {
        if (engineGain) engineGain.gain.linearRampToValueAtTime(v, audioCtx.currentTime + 0.5);
    }
    function setWindVolume(v) {
        if (windGain) windGain.gain.linearRampToValueAtTime(v, audioCtx.currentTime + 0.5);
    }
    function setCabinVolume(v) {
        if (cabinGain) cabinGain.gain.linearRampToValueAtTime(v, audioCtx.currentTime + 0.3);
    }

    function playThunder() {
        if (!audioCtx) return;
        var osc = audioCtx.createOscillator();
        var g = audioCtx.createGain();
        var filter = audioCtx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 200;

        var buf = audioCtx.createBuffer(1, audioCtx.sampleRate * 2, audioCtx.sampleRate);
        var d = buf.getChannelData(0);
        for (var i = 0; i < d.length; i++) d[i] = (Math.random() * 2 - 1);
        var noise = audioCtx.createBufferSource();
        noise.buffer = buf;

        g.gain.setValueAtTime(0.8, audioCtx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 2.5);

        noise.connect(filter);
        filter.connect(g);
        g.connect(masterGain);
        noise.start();
        noise.stop(audioCtx.currentTime + 2.5);
    }

    function playDing() {
        if (!audioCtx) return;
        var osc = audioCtx.createOscillator();
        var g = audioCtx.createGain();
        osc.type = 'sine';
        osc.frequency.value = 1200;
        g.gain.setValueAtTime(0.15, audioCtx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.8);
        osc.connect(g);
        g.connect(masterGain);
        osc.start();
        osc.stop(audioCtx.currentTime + 0.8);
        // Second tone
        setTimeout(function() {
            if (!audioCtx) return;
            var o2 = audioCtx.createOscillator();
            var g2 = audioCtx.createGain();
            o2.type = 'sine'; o2.frequency.value = 900;
            g2.gain.setValueAtTime(0.12, audioCtx.currentTime);
            g2.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.6);
            o2.connect(g2); g2.connect(masterGain);
            o2.start(); o2.stop(audioCtx.currentTime + 0.6);
        }, 300);
    }

    function playAlarm() {
        if (!audioCtx) return;
        var osc = audioCtx.createOscillator();
        var g = audioCtx.createGain();
        osc.type = 'square';
        osc.frequency.setValueAtTime(600, audioCtx.currentTime);
        g.gain.setValueAtTime(0.2, audioCtx.currentTime);
        for (var i = 0; i < 10; i++) {
            osc.frequency.setValueAtTime(600, audioCtx.currentTime + i * 0.4);
            osc.frequency.setValueAtTime(400, audioCtx.currentTime + i * 0.4 + 0.2);
        }
        g.gain.setValueAtTime(0.2, audioCtx.currentTime + 3.8);
        g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 4);
        osc.connect(g); g.connect(masterGain);
        osc.start(); osc.stop(audioCtx.currentTime + 4);
    }

    function playImpact() {
        if (!audioCtx) return;
        var buf = audioCtx.createBuffer(1, audioCtx.sampleRate, audioCtx.sampleRate);
        var d = buf.getChannelData(0);
        for (var i = 0; i < d.length; i++) d[i] = (Math.random() * 2 - 1) * Math.exp(-i / (audioCtx.sampleRate * 0.15));
        var src = audioCtx.createBufferSource();
        src.buffer = buf;
        var filter = audioCtx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 300;
        var g = audioCtx.createGain();
        g.gain.value = 1.0;
        src.connect(filter); filter.connect(g); g.connect(masterGain);
        src.start();
    }

    // ═══════════════════════════════════════════════════
    //  MATERIALS
    // ═══════════════════════════════════════════════════
    var MAT = {
        concrete: new THREE.MeshStandardMaterial({ color: 0x999999, roughness: 0.9 }),
        asphalt: new THREE.MeshStandardMaterial({ color: 0x2a2a2a, roughness: 0.95 }),
        grass: new THREE.MeshStandardMaterial({ color: 0x3d7a1a, roughness: 0.95 }),
        glass: new THREE.MeshPhysicalMaterial({ color: 0x88ccff, transparent: true, opacity: 0.3, roughness: 0.05, metalness: 0.1, transmission: 0.6 }),
        metal: new THREE.MeshStandardMaterial({ color: 0xcccccc, roughness: 0.25, metalness: 0.85 }),
        white: new THREE.MeshStandardMaterial({ color: 0xf0f0f0, roughness: 0.6 }),
        blue: new THREE.MeshStandardMaterial({ color: 0x1a4b8c, roughness: 0.5 }),
        red: new THREE.MeshStandardMaterial({ color: 0xcc2222, roughness: 0.5 }),
        darkRed: new THREE.MeshStandardMaterial({ color: 0x661111, roughness: 0.5 }),
        seat: new THREE.MeshStandardMaterial({ color: 0x1e3a6e, roughness: 0.75 }),
        seatBack: new THREE.MeshStandardMaterial({ color: 0x152a52, roughness: 0.8 }),
        carpet: new THREE.MeshStandardMaterial({ color: 0x2a3040, roughness: 0.95 }),
        plastic: new THREE.MeshStandardMaterial({ color: 0xe0d8cc, roughness: 0.7 }),
        darkPlastic: new THREE.MeshStandardMaterial({ color: 0x3a3a3a, roughness: 0.8 }),
        windowInner: new THREE.MeshPhysicalMaterial({ color: 0xaaddff, transparent: true, opacity: 0.15, roughness: 0.02 }),
        terminalFloor: new THREE.MeshStandardMaterial({ color: 0xccbbaa, roughness: 0.5 }),
        sky: new THREE.MeshBasicMaterial({ color: 0x87CEEB }),
        emergencyGreen: new THREE.MeshBasicMaterial({ color: 0x00ff44 }),
        lightEmit: new THREE.MeshBasicMaterial({ color: 0xffffee }),
        lightEmitWarm: new THREE.MeshBasicMaterial({ color: 0xffeecc }),
        lightEmitDim: new THREE.MeshBasicMaterial({ color: 0x443322 }),
        stormCloud: new THREE.MeshLambertMaterial({ color: 0x333344, transparent: true, opacity: 0.85 }),
        darkCloud: new THREE.MeshLambertMaterial({ color: 0x1a1a22, transparent: true, opacity: 0.9 })
    };

    // ═══════════════════════════════════════════════════
    //  SCENE GROUPS
    // ═══════════════════════════════════════════════════
    var airportGroup = new THREE.Group();
    var planeExtGroup = new THREE.Group();
    var cabinGroup = new THREE.Group();
    var cloudGroup = new THREE.Group();
    var stormCloudGroup = new THREE.Group();
    var lightningGroup = new THREE.Group();
    var debrisGroup = new THREE.Group();
    var survivalGroup = new THREE.Group();
    scene.add(airportGroup, planeExtGroup, cabinGroup, cloudGroup, stormCloudGroup, lightningGroup, debrisGroup, survivalGroup);

    // Cabin light refs
    var cabinLights = [];
    var cabinLightMeshes = [];
    var emergencyLightMeshes = [];

    // ═══════════════════════════════════════════════════
    //  LIGHTING
    // ═══════════════════════════════════════════════════
    var ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
    scene.add(ambientLight);

    var sunLight = new THREE.DirectionalLight(0xfffff0, 1.2);
    sunLight.position.set(80, 120, 60);
    sunLight.castShadow = true;
    sunLight.shadow.mapSize.width = 2048;
    sunLight.shadow.mapSize.height = 2048;
    sunLight.shadow.camera.near = 0.5;
    sunLight.shadow.camera.far = 500;
    sunLight.shadow.camera.left = -100;
    sunLight.shadow.camera.right = 100;
    sunLight.shadow.camera.top = 100;
    sunLight.shadow.camera.bottom = -100;
    scene.add(sunLight);

    var hemiLight = new THREE.HemisphereLight(0x87ceeb, 0x3d5c2d, 0.4);
    scene.add(hemiLight);

    // ═══════════════════════════════════════════════════
    //  AIRPORT CONSTRUCTION
    // ═══════════════════════════════════════════════════
    function buildAirport() {
        // Ground plane
        var groundGeo = new THREE.PlaneGeometry(1000, 1000);
        var ground = new THREE.Mesh(groundGeo, MAT.grass);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        airportGroup.add(ground);

        // Runway
        var rwGeo = new THREE.PlaneGeometry(24, 400);
        var runway = new THREE.Mesh(rwGeo, MAT.asphalt);
        runway.rotation.x = -Math.PI / 2;
        runway.position.set(40, 0.02, 0);
        runway.receiveShadow = true;
        airportGroup.add(runway);

        // Runway center line
        var lineM = new THREE.MeshBasicMaterial({ color: 0xffffff });
        for (var i = -180; i < 180; i += 12) {
            var mark = new THREE.Mesh(new THREE.PlaneGeometry(0.6, 5), lineM);
            mark.rotation.x = -Math.PI / 2;
            mark.position.set(40, 0.03, i);
            airportGroup.add(mark);
        }

        // Runway edge lines
        for (var side = -1; side <= 1; side += 2) {
            var edgeLine = new THREE.Mesh(new THREE.PlaneGeometry(0.4, 380), lineM);
            edgeLine.rotation.x = -Math.PI / 2;
            edgeLine.position.set(40 + side * 11.5, 0.03, 0);
            airportGroup.add(edgeLine);
        }

        // Taxiway
        var twGeo = new THREE.PlaneGeometry(12, 80);
        var taxiway = new THREE.Mesh(twGeo, MAT.asphalt);
        taxiway.rotation.x = -Math.PI / 2;
        taxiway.position.set(15, 0.02, 0);
        airportGroup.add(taxiway);

        // Terminal building (large)
        var termGeo = new THREE.BoxGeometry(80, 18, 40);
        var terminal = new THREE.Mesh(termGeo, MAT.concrete);
        terminal.position.set(-25, 9, 0);
        terminal.castShadow = true;
        terminal.receiveShadow = true;
        airportGroup.add(terminal);

        // Terminal windows - large glass facade
        var facadeGeo = new THREE.PlaneGeometry(78, 12);
        var facade = new THREE.Mesh(facadeGeo, MAT.glass);
        facade.position.set(-25, 10, 20.01);
        airportGroup.add(facade);

        // Terminal entrance canopy
        var canopyGeo = new THREE.BoxGeometry(30, 0.5, 8);
        var canopy = new THREE.Mesh(canopyGeo, MAT.metal);
        canopy.position.set(-25, 5, 24);
        airportGroup.add(canopy);

        // Control tower
        var towerBase = new THREE.Mesh(new THREE.CylinderGeometry(4, 5, 30, 12), MAT.concrete);
        towerBase.position.set(-60, 15, -40);
        towerBase.castShadow = true;
        airportGroup.add(towerBase);

        var towerCab = new THREE.Mesh(new THREE.CylinderGeometry(8, 5, 7, 12), MAT.glass);
        towerCab.position.set(-60, 33, -40);
        airportGroup.add(towerCab);

        var towerRoof = new THREE.Mesh(new THREE.ConeGeometry(9, 3, 12), MAT.metal);
        towerRoof.position.set(-60, 38, -40);
        airportGroup.add(towerRoof);

        // Jet bridge
        var bridgeGeo = new THREE.BoxGeometry(18, 3.2, 4.5);
        var bridge = new THREE.Mesh(bridgeGeo, MAT.metal);
        bridge.position.set(5, 4.5, 0);
        airportGroup.add(bridge);

        // Plane at gate (exterior)
        buildPlaneExterior();

        // Other parked planes (distant)
        for (var p = 0; p < 3; p++) {
            var miniPlane = buildMiniPlane();
            miniPlane.position.set(40 + p * 5, 2, -80 - p * 50);
            miniPlane.scale.set(0.6, 0.6, 0.6);
            airportGroup.add(miniPlane);
        }

        // Runway lights
        for (var rl = -190; rl < 190; rl += 15) {
            for (var rs = -1; rs <= 1; rs += 2) {
                var rlMesh = new THREE.Mesh(
                    new THREE.SphereGeometry(0.15, 6, 6),
                    new THREE.MeshBasicMaterial({ color: rl < -150 ? 0x00ff00 : (rl > 150 ? 0xff0000 : 0xffffff) })
                );
                rlMesh.position.set(40 + rs * 12.5, 0.15, rl);
                airportGroup.add(rlMesh);
            }
        }
    }

    function buildMiniPlane() {
        var g = new THREE.Group();
        var body = new THREE.Mesh(new THREE.CylinderGeometry(1.5, 1.5, 20, 12), MAT.white);
        body.rotation.z = Math.PI / 2;
        g.add(body);
        var nose = new THREE.Mesh(new THREE.ConeGeometry(1.5, 4, 12), MAT.white);
        nose.rotation.z = -Math.PI / 2;
        nose.position.x = 12;
        g.add(nose);
        var wing = new THREE.Mesh(new THREE.BoxGeometry(4, 0.2, 16), MAT.metal);
        wing.position.set(-2, 0, 0);
        g.add(wing);
        var tail = new THREE.Mesh(new THREE.BoxGeometry(3, 4, 0.2), MAT.blue);
        tail.position.set(-10, 2.5, 0);
        g.add(tail);
        return g;
    }

    // ═══════════════════════════════════════════════════
    //  PLANE EXTERIOR
    // ═══════════════════════════════════════════════════
    function buildPlaneExterior() {
        var fLen = 44;
        var fRad = 2.8;

        // Fuselage
        var fusGeo = new THREE.CylinderGeometry(fRad, fRad, fLen, 32, 1, false);
        var fuselage = new THREE.Mesh(fusGeo, MAT.white);
        fuselage.rotation.z = Math.PI / 2;
        fuselage.castShadow = true;
        planeExtGroup.add(fuselage);

        // Blue stripe
        var stripeGeo = new THREE.CylinderGeometry(fRad + 0.02, fRad + 0.02, fLen, 32, 1, false, -0.15, 0.3);
        var stripe = new THREE.Mesh(stripeGeo, MAT.blue);
        stripe.rotation.z = Math.PI / 2;
        planeExtGroup.add(stripe);

        // Nose
        var noseGeo = new THREE.SphereGeometry(fRad, 32, 16, 0, Math.PI * 2, 0, Math.PI / 2);
        var nose = new THREE.Mesh(noseGeo, MAT.white);
        nose.rotation.x = Math.PI / 2;
        nose.rotation.z = -Math.PI / 2;
        nose.position.x = fLen / 2;
        planeExtGroup.add(nose);

        // Cockpit windows
        var cwGeo = new THREE.PlaneGeometry(1.8, 0.9);
        for (var cw = -1; cw <= 1; cw += 2) {
            var cWin = new THREE.Mesh(cwGeo, MAT.glass);
            cWin.position.set(fLen / 2 - 0.5, 1.5, cw * 0.8);
            cWin.rotation.y = cw * 0.3;
            cWin.rotation.x = -0.2;
            planeExtGroup.add(cWin);
        }

        // Tail cone
        var tailGeo = new THREE.ConeGeometry(fRad, 10, 32);
        var tail = new THREE.Mesh(tailGeo, MAT.white);
        tail.rotation.z = Math.PI / 2;
        tail.position.x = -fLen / 2 - 5;
        planeExtGroup.add(tail);

        // Windows
        for (var wi = -17; wi <= 17; wi += 1.8) {
            var wGeo = new THREE.CircleGeometry(0.28, 12);
            var wL = new THREE.Mesh(wGeo, MAT.glass);
            wL.position.set(wi, 1.5, fRad + 0.02);
            planeExtGroup.add(wL);
            var wR = new THREE.Mesh(wGeo, MAT.glass);
            wR.position.set(wi, 1.5, -fRad - 0.02);
            wR.rotation.y = Math.PI;
            planeExtGroup.add(wR);
        }

        // Wings
        var wingShape = new THREE.Shape();
        wingShape.moveTo(0, 0);
        wingShape.lineTo(18, -3);
        wingShape.lineTo(19, -3.5);
        wingShape.lineTo(16, -0.5);
        wingShape.lineTo(0, 0.8);
        var wingGeo = new THREE.ExtrudeGeometry(wingShape, { depth: 0.4, bevelEnabled: false });

        for (var ws = -1; ws <= 1; ws += 2) {
            var wing = new THREE.Mesh(wingGeo, MAT.metal);
            wing.position.set(-3, -1, ws * (fRad - 0.5));
            wing.rotation.x = ws * Math.PI / 2;
            if (ws < 0) wing.scale.z = -1;
            wing.castShadow = true;
            planeExtGroup.add(wing);
        }

        // Engines
        for (var es = -1; es <= 1; es += 2) {
            var engGroup = new THREE.Group();
            var nacelle = new THREE.Mesh(new THREE.CylinderGeometry(0.9, 1.1, 5, 20), MAT.metal);
            nacelle.rotation.z = Math.PI / 2;
            engGroup.add(nacelle);
            var intake = new THREE.Mesh(new THREE.RingGeometry(0.35, 0.9, 20), new THREE.MeshBasicMaterial({ color: 0x111111 }));
            intake.position.x = 2.5;
            intake.rotation.y = Math.PI / 2;
            engGroup.add(intake);
            var fan = new THREE.Mesh(new THREE.CircleGeometry(0.8, 6), MAT.darkPlastic);
            fan.position.x = 2.4;
            fan.rotation.y = Math.PI / 2;
            engGroup.add(fan);
            engGroup.position.set(-5, -2, es * 9);
            planeExtGroup.add(engGroup);
        }

        // Vertical stabilizer
        var vStabShape = new THREE.Shape();
        vStabShape.moveTo(0, 0);
        vStabShape.lineTo(-2, 7);
        vStabShape.lineTo(-6, 7);
        vStabShape.lineTo(-4, 0);
        var vStabGeo = new THREE.ExtrudeGeometry(vStabShape, { depth: 0.3, bevelEnabled: false });
        var vStab = new THREE.Mesh(vStabGeo, MAT.blue);
        vStab.position.set(-fLen / 2 + 2, 2, -0.15);
        planeExtGroup.add(vStab);

        // Horizontal stabilizers
        for (var hs = -1; hs <= 1; hs += 2) {
            var hStab = new THREE.Mesh(new THREE.BoxGeometry(5, 0.2, 7), MAT.metal);
            hStab.position.set(-fLen / 2 - 2, 1.5, hs * 5);
            planeExtGroup.add(hStab);
        }

        // Landing gear
        for (var lg = 0; lg < 3; lg++) {
            var gearGroup = new THREE.Group();
            var strut = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.08, 1.8, 8), MAT.darkPlastic);
            gearGroup.add(strut);
            var wheel = new THREE.Mesh(new THREE.TorusGeometry(0.35, 0.15, 8, 16), MAT.darkPlastic);
            wheel.position.y = -0.9;
            wheel.rotation.x = Math.PI / 2;
            gearGroup.add(wheel);
            var xOff = lg === 0 ? 15 : -5;
            var zOff = lg === 0 ? 0 : (lg === 1 ? 1.5 : -1.5);
            gearGroup.position.set(xOff, -fRad - 0.5, zOff);
            planeExtGroup.add(gearGroup);
        }

        planeExtGroup.position.set(18, 3.5, 0);
    }

    // ═══════════════════════════════════════════════════
    //  CABIN INTERIOR
    // ═══════════════════════════════════════════════════
    function buildCabin() {
        var L = 34, W = 5.0, H = 2.5;

        // Floor
        var floor = new THREE.Mesh(new THREE.PlaneGeometry(L, W), MAT.carpet);
        floor.rotation.x = -Math.PI / 2;
        cabinGroup.add(floor);

        // Ceiling
        var ceil = new THREE.Mesh(new THREE.PlaneGeometry(L, W), MAT.plastic);
        ceil.rotation.x = Math.PI / 2;
        ceil.position.y = H;
        cabinGroup.add(ceil);

        // Curved walls using segments
        var wallPanels = 16;
        for (var wp = 0; wp < wallPanels; wp++) {
            var a0 = (wp / wallPanels) * Math.PI;
            var a1 = ((wp + 1) / wallPanels) * Math.PI;
            var y0 = Math.sin(a0) * H * 0.5 + H * 0.5;
            var y1 = Math.sin(a1) * H * 0.5 + H * 0.5;
            var z0 = Math.cos(a0) * W * 0.5;
            var z1 = Math.cos(a1) * W * 0.5;

            var panelVerts = new Float32Array([
                -L/2, y0, z0, L/2, y0, z0, L/2, y1, z1, -L/2, y1, z1
            ]);
            var panelIdx = [0, 1, 2, 0, 2, 3];
            var panGeo = new THREE.BufferGeometry();
            panGeo.setAttribute('position', new THREE.BufferAttribute(panelVerts, 3));
            panGeo.setIndex(panelIdx);
            panGeo.computeVertexNormals();
            cabinGroup.add(new THREE.Mesh(panGeo, MAT.plastic));
        }

        // Aisle (darker strip on floor)
        var aisle = new THREE.Mesh(new THREE.PlaneGeometry(L, 1.0), new THREE.MeshStandardMaterial({ color: 0x222830, roughness: 0.9 }));
        aisle.rotation.x = -Math.PI / 2;
        aisle.position.y = 0.005;
        cabinGroup.add(aisle);

        // Seats (3-3 config)
        for (var row = -14; row <= 12; row += 2.2) {
            // Left: A, B, C
            cabinGroup.add(buildSeat(row, 1.95));
            cabinGroup.add(buildSeat(row, 1.35));
            cabinGroup.add(buildSeat(row, 0.75));
            // Right: D, E, F
            cabinGroup.add(buildSeat(row, -0.75));
            cabinGroup.add(buildSeat(row, -1.35));
            cabinGroup.add(buildSeat(row, -1.95));
        }

        // Overhead bins
        for (var bx = -14; bx <= 12; bx += 4) {
            for (var bs = -1; bs <= 1; bs += 2) {
                var bin = new THREE.Mesh(new THREE.BoxGeometry(3.6, 0.45, 0.7), MAT.plastic);
                bin.position.set(bx, H - 0.35, bs * 2.0);
                cabinGroup.add(bin);
                // Bin handle
                var handle = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.04, 0.04), MAT.darkPlastic);
                handle.position.set(bx, H - 0.6, bs * (2.0 - 0.35 * Math.sign(bs)));
                cabinGroup.add(handle);
            }
        }

        // Windows (interior)
        for (var wx = -14; wx <= 12; wx += 2.2) {
            for (var wside = -1; wside <= 1; wside += 2) {
                // Window frame
                var frame = new THREE.Mesh(new THREE.RingGeometry(0.22, 0.3, 4), MAT.plastic);
                frame.position.set(wx, 1.35, wside * (W / 2 - 0.06));
                frame.rotation.y = wside < 0 ? Math.PI / 2 : -Math.PI / 2;
                cabinGroup.add(frame);
                // Window glass
                var glass = new THREE.Mesh(new THREE.PlaneGeometry(0.42, 0.42), MAT.windowInner);
                glass.position.set(wx, 1.35, wside * (W / 2 - 0.05));
                glass.rotation.y = wside < 0 ? Math.PI / 2 : -Math.PI / 2;
                cabinGroup.add(glass);
            }
        }

        // Cabin ceiling lights
        for (var lx = -14; lx <= 12; lx += 3) {
            var lightPanel = new THREE.Mesh(new THREE.BoxGeometry(2.5, 0.04, 0.5), MAT.lightEmit);
            lightPanel.position.set(lx, H - 0.02, 0);
            cabinGroup.add(lightPanel);
            cabinLightMeshes.push(lightPanel);

            // Actual point light every 6 units
            if (lx % 6 === 0) {
                var pl = new THREE.PointLight(0xffffee, 0.4, 8);
                pl.position.set(lx, H - 0.1, 0);
                cabinGroup.add(pl);
                cabinLights.push(pl);
            }
        }

        // Reading light nozzles (on overhead bins)
        for (var rlx = -14; rlx <= 12; rlx += 2.2) {
            for (var rls = -1; rls <= 1; rls += 2) {
                var nozzle = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.05, 0.08, 8), MAT.darkPlastic);
                nozzle.position.set(rlx, H - 0.55, rls * 1.6);
                cabinGroup.add(nozzle);
            }
        }

        // Cockpit door
        var cDoor = new THREE.Mesh(new THREE.BoxGeometry(0.12, 2.1, 1.6), MAT.metal);
        cDoor.position.set(L / 2 - 0.06, 1.05, 0);
        cabinGroup.add(cDoor);

        // EXIT signs
        var exitMat = new THREE.MeshBasicMaterial({ color: 0x00ff44 });
        var ex1 = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.18, 0.03), exitMat);
        ex1.position.set(L / 2 - 1, H - 0.15, 0);
        cabinGroup.add(ex1);
        var ex2 = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.18, 0.03), exitMat);
        ex2.position.set(-L / 2 + 1, H - 0.15, 0);
        cabinGroup.add(ex2);

        // Emergency floor lighting (hidden initially)
        for (var elx = -14; elx <= 12; elx += 2) {
            var eled = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.02, 0.08), MAT.emergencyGreen);
            eled.position.set(elx, 0.01, 0.5);
            eled.visible = false;
            cabinGroup.add(eled);
            emergencyLightMeshes.push(eled);

            var eled2 = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.02, 0.08), MAT.emergencyGreen);
            eled2.position.set(elx, 0.01, -0.5);
            eled2.visible = false;
            cabinGroup.add(eled2);
            emergencyLightMeshes.push(eled2);
        }

        cabinGroup.visible = false;
    }

    function buildSeat(x, z) {
        var sg = new THREE.Group();
        // Cushion
        sg.add(positionMesh(new THREE.BoxGeometry(0.52, 0.12, 0.48), MAT.seat, 0, 0.46, 0));
        // Back
        sg.add(positionMesh(new THREE.BoxGeometry(0.52, 0.72, 0.07), MAT.seatBack, 0, 0.85, -0.22));
        // Headrest
        sg.add(positionMesh(new THREE.BoxGeometry(0.32, 0.22, 0.06), MAT.plastic, 0, 1.25, -0.24));
        // Armrests
        sg.add(positionMesh(new THREE.BoxGeometry(0.52, 0.04, 0.07), MAT.darkPlastic, 0, 0.52, 0.24));
        sg.add(positionMesh(new THREE.BoxGeometry(0.52, 0.04, 0.07), MAT.darkPlastic, 0, 0.52, -0.3));
        // Legs
        sg.add(positionMesh(new THREE.BoxGeometry(0.04, 0.42, 0.4), MAT.metal, -0.22, 0.21, 0));
        sg.add(positionMesh(new THREE.BoxGeometry(0.04, 0.42, 0.4), MAT.metal, 0.22, 0.21, 0));
        // Tray table (folded)
        sg.add(positionMesh(new THREE.BoxGeometry(0.35, 0.25, 0.02), MAT.plastic, 0, 0.7, -0.24));
        // Seat pocket
        sg.add(positionMesh(new THREE.BoxGeometry(0.4, 0.15, 0.01), MAT.darkPlastic, 0, 0.35, -0.21));
        sg.position.set(x, 0, z);
        return sg;
    }

    function positionMesh(geo, mat, x, y, z) {
        var m = new THREE.Mesh(geo, mat);
        m.position.set(x, y, z);
        return m;
    }

    // ═══════════════════════════════════════════════════
    //  CLOUDS
    // ═══════════════════════════════════════════════════
    function buildCloud(x, y, z, scale, mat) {
        var cg = new THREE.Group();
        mat = mat || new THREE.MeshLambertMaterial({ color: 0xffffff, transparent: true, opacity: 0.88 });
        var count = 4 + Math.floor(Math.random() * 6);
        for (var i = 0; i < count; i++) {
            var r = (0.6 + Math.random() * 1.4) * scale;
            var s = new THREE.Mesh(new THREE.SphereGeometry(r, 7, 7), mat);
            s.position.set(
                (Math.random() - 0.5) * 5 * scale,
                (Math.random() - 0.5) * 1.5 * scale,
                (Math.random() - 0.5) * 4 * scale
            );
            cg.add(s);
        }
        cg.position.set(x, y, z);
        cg.userData.speed = 0.3 + Math.random() * 0.7;
        return cg;
    }

    function populateClouds() {
        for (var i = 0; i < 40; i++) {
            cloudGroup.add(buildCloud(
                (Math.random() - 0.5) * 600,
                25 + Math.random() * 80,
                (Math.random() - 0.5) * 600,
                2 + Math.random() * 4
            ));
        }
    }

    function populateStormClouds() {
        for (var i = 0; i < 30; i++) {
            stormCloudGroup.add(buildCloud(
                (Math.random() - 0.5) * 500,
                20 + Math.random() * 40,
                (Math.random() - 0.5) * 500,
                3 + Math.random() * 6,
                Math.random() < 0.5 ? MAT.stormCloud : MAT.darkCloud
            ));
        }
        stormCloudGroup.visible = false;
    }

    // ═══════════════════════════════════════════════════
    //  SURVIVAL SCENE
    // ═══════════════════════════════════════════════════
    function buildSurvivalScene() {
        // Dark terrain
        var ground = new THREE.Mesh(
            new THREE.PlaneGeometry(200, 200),
            new THREE.MeshStandardMaterial({ color: 0x1a2a10, roughness: 0.95 })
        );
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = -0.5;
        survivalGroup.add(ground);

        // Wreckage pieces
        for (var i = 0; i < 20; i++) {
            var size = 0.5 + Math.random() * 3;
            var piece = new THREE.Mesh(
                new THREE.BoxGeometry(size, size * 0.5, size * 0.7),
                new THREE.MeshStandardMaterial({
                    color: new THREE.Color().setHSL(0, 0, 0.3 + Math.random() * 0.4),
                    roughness: 0.9
                })
            );
            piece.position.set(
                (Math.random() - 0.5) * 40,
                size * 0.2,
                (Math.random() - 0.5) * 40
            );
            piece.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * 0.5);
            survivalGroup.add(piece);
        }

        // Fire glow (simple)
        var fireLight = new THREE.PointLight(0xff6600, 2, 30);
        fireLight.position.set(5, 2, -3);
        survivalGroup.add(fireLight);

        // Fire particles (simple mesh clusters)
        for (var f = 0; f < 8; f++) {
            var flame = new THREE.Mesh(
                new THREE.ConeGeometry(0.3 + Math.random() * 0.4, 1 + Math.random() * 1.5, 6),
                new THREE.MeshBasicMaterial({ color: Math.random() < 0.5 ? 0xff4400 : 0xff8800, transparent: true, opacity: 0.8 })
            );
            flame.position.set(5 + (Math.random() - 0.5) * 3, 0.5 + Math.random(), -3 + (Math.random() - 0.5) * 3);
            flame.userData.baseY = flame.position.y;
            flame.userData.flicker = Math.random() * Math.PI * 2;
            survivalGroup.add(flame);
        }

        // Smoke column
        for (var sm = 0; sm < 12; sm++) {
            var smoke = new THREE.Mesh(
                new THREE.SphereGeometry(1 + Math.random() * 2, 6, 6),
                new THREE.MeshBasicMaterial({ color: 0x222222, transparent: true, opacity: 0.3 + Math.random() * 0.3 })
            );
            smoke.position.set(5 + (Math.random() - 0.5) * 2, 4 + sm * 2, -3 + (Math.random() - 0.5) * 2);
            survivalGroup.add(smoke);
        }

        // Emergency flashers on ground
        for (var ef = 0; ef < 5; ef++) {
            var flasher = new THREE.Mesh(
                new THREE.SphereGeometry(0.1, 6, 6),
                new THREE.MeshBasicMaterial({ color: 0xff0000 })
            );
            flasher.position.set(-10 + ef * 5, 0.1, 8);
            flasher.userData.flashPhase = ef * 0.5;
            survivalGroup.add(flasher);
        }

        survivalGroup.visible = false;
    }

    // ═══════════════════════════════════════════════════
    //  RAIN SYSTEM (2D canvas overlay)
    // ═══════════════════════════════════════════════════
    var rainCanvas = document.getElementById('rain-canvas');
    var rainCtx = rainCanvas.getContext('2d');
    var rainDrops = [];

    function initRain() {
        rainCanvas.width = window.innerWidth;
        rainCanvas.height = window.innerHeight;
        for (var i = 0; i < 200; i++) {
            rainDrops.push({
                x: Math.random() * rainCanvas.width,
                y: Math.random() * rainCanvas.height,
                len: 10 + Math.random() * 20,
                speed: 8 + Math.random() * 12,
                opacity: 0.1 + Math.random() * 0.3
            });
        }
    }

    function updateRain() {
        if (G.rainIntensity <= 0) return;
        rainCtx.clearRect(0, 0, rainCanvas.width, rainCanvas.height);
        for (var i = 0; i < rainDrops.length; i++) {
            var d = rainDrops[i];
            d.y += d.speed * G.rainIntensity;
            d.x -= 2 * G.rainIntensity;
            if (d.y > rainCanvas.height) { d.y = -d.len; d.x = Math.random() * rainCanvas.width; }
            if (d.x < 0) d.x = rainCanvas.width;
            rainCtx.beginPath();
            rainCtx.moveTo(d.x, d.y);
            rainCtx.lineTo(d.x + 1, d.y + d.len * G.rainIntensity);
            rainCtx.strokeStyle = 'rgba(180,200,220,' + (d.opacity * G.rainIntensity) + ')';
            rainCtx.lineWidth = 1;
            rainCtx.stroke();
        }
    }

    // ═══════════════════════════════════════════════════
    //  UI HELPERS
    // ═══════════════════════════════════════════════════
    var $phase = document.getElementById('phase-label');
    var $alt = document.getElementById('altitude-box');
    var $altVal = document.getElementById('alt-val');
    var $spdVal = document.getElementById('spd-val');
    var $hdgVal = document.getElementById('hdg-val');
    var $prompt = document.getElementById('prompt');
    var $sub = document.getElementById('sub-prompt');
    var $seatbelt = document.getElementById('seatbelt-sign');
    var $captain = document.getElementById('captain-box');
    var $captainText = document.getElementById('captain-text');
    var $warning = document.getElementById('warning');
    var $fade = document.getElementById('fade');
    var $flash = document.getElementById('flash');
    var $eStrip = document.getElementById('emergency-strip');
    var $survival = document.getElementById('survival-text');
    var $continueBtn = document.getElementById('continue-btn');

    function showPrompt(text, dur) {
        $prompt.textContent = text;
        $prompt.classList.add('visible');
        if (dur) setTimeout(function() { $prompt.classList.remove('visible'); }, dur);
    }
    function hidePrompt() { $prompt.classList.remove('visible'); }

    function showSub(text) { $sub.textContent = text; $sub.classList.add('visible'); }
    function hideSub() { $sub.classList.remove('visible'); }

    function showCaptain(text, dur) {
        $captain.querySelector('.captain-label').textContent = '— Captain Speaking —';
        $captainText.textContent = text;
        $captain.classList.add('visible');
        playDing();
        if (dur) setTimeout(function() { $captain.classList.remove('visible'); }, dur);
    }
    function hideCaptain() { $captain.classList.remove('visible'); }

    function showWarning(text) { $warning.textContent = text; $warning.classList.add('visible'); }
    function hideWarning() { $warning.classList.remove('visible'); }

    function fadeIn(dur) {
        $fade.style.transition = 'opacity ' + (dur || 1.5) + 's ease';
        $fade.classList.add('visible');
    }
    function fadeOut(dur) {
        $fade.style.transition = 'opacity ' + (dur || 1.5) + 's ease';
        $fade.classList.remove('visible');
    }

    function doFlash(intensity, dur) {
        $flash.style.opacity = intensity || 0.9;
        $flash.style.transition = 'opacity ' + (dur || 0.5) + 's ease-out';
        setTimeout(function() { $flash.style.opacity = 0; }, 50);
    }

    function setPhaseLabel(txt) { $phase.textContent = txt; }

    function updateHUD() {
        $altVal.textContent = Math.max(0, Math.round(G.altitude)).toLocaleString();
        $spdVal.textContent = Math.round(G.speed);
        $hdgVal.textContent = Math.round(G.heading);
    }

    // ═══════════════════════════════════════════════════
    //  PHASE SYSTEM
    // ═══════════════════════════════════════════════════
    var phaseTimers = [];

    function clearPhaseTimers() {
        for (var i = 0; i < phaseTimers.length; i++) clearTimeout(phaseTimers[i]);
        phaseTimers = [];
    }

    function pt(fn, delay) {
        phaseTimers.push(setTimeout(fn, delay));
    }

    function goPhase(phase) {
        clearPhaseTimers();
        G.phase = phase;
        G.transitioning = true;

        switch (phase) {

        // ─── AIRPORT ───
        case 'airport':
            setPhaseLabel('Airport Terminal');
            airportGroup.visible = true;
            planeExtGroup.visible = true;
            cabinGroup.visible = false;
            stormCloudGroup.visible = false;
            survivalGroup.visible = false;
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.FogExp2(0x87CEEB, 0.0008);
            camera.position.set(-12, 2.0, 12);
            camera.lookAt(new THREE.Vector3(18, 3, 0));
            G.cameraBasePos.copy(camera.position);
            showPrompt('Welcome to the airport.', 3500);
            pt(function() {
                showSub('Click to begin boarding');
                G.canClick = true;
                G.transitioning = false;
            }, 1500);
            break;

        // ─── BOARDING ───
        case 'boarding':
            G.canClick = false;
            setPhaseLabel('Boarding');
            showPrompt('Boarding the aircraft...', 3000);
            hideSub();

            pt(function() {
                fadeIn(1.5);
            }, 2000);

            pt(function() {
                airportGroup.visible = false;
                planeExtGroup.visible = false;
                cabinGroup.visible = true;

                // Standing in aisle, back of plane
                camera.position.set(-10, 1.6, 0);
                camera.rotation.set(0, 0, 0);
                G.cameraBasePos.copy(camera.position);
                G.lookX = 0; G.lookY = 0;
                G.targetLookX = 0; G.targetLookY = 0;

                setCabinVolume(0.15);
                fadeOut(1.5);
            }, 4000);

            pt(function() {
                setPhaseLabel('Finding Your Seat');
                showPrompt('Find your seat...', 2500);
            }, 5500);

            pt(function() {
                showSub('Click to take your window seat');
                G.canClick = true;
                G.transitioning = false;
            }, 7000);
            break;

        // ─── SEATED ───
        case 'seated':
            G.canClick = false;
            setPhaseLabel('Seated');

            // Animate to window seat position
            var seatTarget = new THREE.Vector3(-4, 1.3, 1.75);
            animateCamera(seatTarget, 1500, function() {
                camera.position.copy(seatTarget);
                G.cameraBasePos.copy(camera.position);
                G.lookX = 0; G.lookY = 0;

                showPrompt('Please fasten your seatbelt.', 2500);
                playDing();
            });

            pt(function() {
                showCaptain(
                    'Good afternoon, ladies and gentlemen. Welcome aboard. ' +
                    'This is your captain speaking. We\'ll be cruising at 35,000 feet today. ' +
                    'Flight time will be approximately three hours. ' +
                    'Please fasten your seatbelts and ensure your tray tables are in the upright position.',
                    9000
                );
            }, 4000);

            pt(function() {
                $seatbelt.classList.add('visible');
            }, 4500);

            pt(function() {
                showSub('Click when ready for departure');
                G.canClick = true;
                G.transitioning = false;
            }, 13500);
            break;

        // ─── TAXI ───
        case 'taxi':
            G.canClick = false;
            setPhaseLabel('Taxiing');
            hideSub();

            showPrompt('Taxiing to runway...', 3000);
            G.shakeAmount = 0.003;
            setEngineVolume(0.15);

            pt(function() {
                showCaptain(
                    'Cabin crew, please prepare for takeoff.',
                    3500
                );
            }, 3500);

            pt(function() {
                G.transitioning = false;
                goPhase('takeoff');
            }, 8000);
            break;

        // ─── TAKEOFF ───
        case 'takeoff':
            setPhaseLabel('Takeoff');
            $alt.classList.add('visible');
            showPrompt('Prepare for takeoff...', 2500);
            G.speed = 0;

            setEngineVolume(0.5);

            var toAccel = setInterval(function() {
                G.speed += 3;
                G.shakeAmount = 0.004 + G.speed * 0.00015;
                setEngineVolume(Math.min(0.8, 0.3 + G.speed * 0.003));
                setWindVolume(Math.min(0.3, G.speed * 0.002));
                updateHUD();

                if (G.speed >= 165) {
                    clearInterval(toAccel);
                    showPrompt('Rotate...', 1500);
                    pt(function() { goPhase('climbing'); }, 1800);
                }
            }, 80);
            phaseTimers.push(toAccel);
            break;

        // ─── CLIMBING ───
        case 'climbing':
            setPhaseLabel('Climbing');
            showPrompt('Climbing to cruising altitude...', 3000);
            G.pitch = 5;

            var climbInt = setInterval(function() {
                G.altitude += 400;
                G.shakeAmount = Math.max(0.001, G.shakeAmount * 0.995);

                // Sky color transitions with altitude
                var f = Math.min(G.altitude / 35000, 1);
                var skyCol = new THREE.Color().lerpColors(
                    new THREE.Color(0x87CEEB),
                    new THREE.Color(0x1a3a6e),
                    f
                );
                scene.background = skyCol;
                scene.fog.color = skyCol;
                renderer.toneMappingExposure = 1.0 - f * 0.3;

                updateHUD();

                if (G.altitude >= 35000) {
                    clearInterval(climbInt);
                    G.pitch = 0;
                    goPhase('cruising');
                }
            }, 150);
            phaseTimers.push(climbInt);
            break;

        // ─── CRUISING ───
        case 'cruising':
            setPhaseLabel('Cruising — 35,000 ft');
            $seatbelt.classList.remove('visible');
            G.shakeAmount = 0.0004;
            G.speed = 480;

            showPrompt('You may now move about the cabin.', 3000);
            setEngineVolume(0.2);
            setWindVolume(0.15);
            setCabinVolume(0.2);

            pt(function() {
                showCaptain(
                    'We\'ve reached our cruising altitude of 35,000 feet. ' +
                    'The seatbelt sign has been turned off. ' +
                    'Sit back and enjoy the flight.',
                    6000
                );
            }, 4000);

            pt(function() {
                showPrompt('Smooth skies ahead...', 3000);
            }, 12000);

            // Transition to turbulence
            pt(function() {
                G.transitioning = false;
                goPhase('turbulence_light');
            }, 18000);
            break;

        // ─── LIGHT TURBULENCE ───
        case 'turbulence_light':
            setPhaseLabel('Light Turbulence');
            $seatbelt.classList.add('visible');
            playDing();

            pt(function() {
                showCaptain(
                    'Ladies and gentlemen, we\'re experiencing some light turbulence. ' +
                    'Please return to your seats and fasten your seatbelts.',
                    5000
                );
            }, 500);

            var ltLevel = 0;
            var ltInt = setInterval(function() {
                ltLevel += 0.05;
                G.shakeAmount = 0.003 + ltLevel * 0.004;
                G.roll = Math.sin(G.time * 2) * ltLevel * 2;
            }, 200);
            phaseTimers.push(ltInt);

            pt(function() {
                clearInterval(ltInt);
                goPhase('storm');
            }, 8000);
            break;

        // ─── STORM ───
        case 'storm':
            setPhaseLabel('Severe Turbulence');

            // Darken sky
            scene.background = new THREE.Color(0x0a0a15);
            scene.fog = new THREE.FogExp2(0x0a0a15, 0.003);
            renderer.toneMappingExposure = 0.4;

            stormCloudGroup.visible = true;
            cloudGroup.visible = false;

            // Rain
            G.rainIntensity = 0.6;
            rainCanvas.classList.add('visible');

            // Dim cabin lights
            dimCabinLights(true);

            setEngineVolume(0.6);
            setWindVolume(0.5);

            showPrompt('Weather ahead...', 2000);

            var stormLevel = 0;
            var stormInt = setInterval(function() {
                stormLevel += 0.04;
                G.shakeAmount = 0.008 + stormLevel * 0.008;
                G.roll = Math.sin(G.time * 3) * stormLevel * 3;
                G.pitch = Math.sin(G.time * 1.5) * stormLevel;
                G.rainIntensity = Math.min(1.0, 0.6 + stormLevel * 0.2);
                setWindVolume(Math.min(0.8, 0.5 + stormLevel * 0.1));
            }, 200);
            phaseTimers.push(stormInt);

            // Lightning strikes
            pt(function() { triggerLightning(); }, 3000);
            pt(function() { triggerLightning(); }, 5500);
            pt(function() { triggerLightning(); }, 7000);
            pt(function() { triggerLightning(); }, 8200);
            pt(function() { triggerLightning(); triggerLightning(); }, 9500);

            pt(function() {
                showCaptain(
                    'We are passing through a severe storm cell. ' +
                    'Please remain calm and keep your seatbelts tightly fastened.',
                    5000
                );
            }, 4000);

            pt(function() {
                clearInterval(stormInt);
                goPhase('lightning_intense');
            }, 12000);
            break;

        // ─── INTENSE LIGHTNING ───
        case 'lightning_intense':
            setPhaseLabel('⚡ Electrical Storm');

            G.shakeAmount = 0.03;
            G.rainIntensity = 1.0;
            setWindVolume(0.9);
            setEngineVolume(0.8);

            // Rapid lightning
            var lnCount = 0;
            var lnInt = setInterval(function() {
                triggerLightning();
                lnCount++;
                G.shakeAmount = 0.03 + Math.random() * 0.02;
                G.roll = (Math.random() - 0.5) * 8;
                G.pitch = (Math.random() - 0.5) * 3;

                // Altitude drops
                G.altitude -= 200 + Math.random() * 300;
                updateHUD();
            }, 800);
            phaseTimers.push(lnInt);

            pt(function() {
                showPrompt('', 100);
                showWarning('SEVERE TURBULENCE');
            }, 1000);

            pt(function() {
                hideWarning();
            }, 3000);

            // Big lightning hit
            pt(function() {
                clearInterval(lnInt);
                doFlash(1.0, 0.8);
                playThunder();
                G.shakeAmount = 0.08;
                showWarning('⚡ LIGHTNING STRIKE');

                // Brief power flicker
                flickerCabinLights();
            }, 6000);

            pt(function() {
                hideWarning();
                goPhase('emergency');
            }, 8500);
            break;

        // ─── EMERGENCY ───
        case 'emergency':
            setPhaseLabel('🔴 EMERGENCY');
            $phase.style.background = 'rgba(200,0,0,0.8)';
            playAlarm();

            // Systems failing
            showWarning('BRACE FOR IMPACT');

            // Drop oxygen masks
            dropOxygenMasks();

            // Emergency lights
            G.emergencyLights = true;
            $eStrip.classList.add('visible');
            for (var i = 0; i < emergencyLightMeshes.length; i++) {
                emergencyLightMeshes[i].visible = true;
            }

            // Kill main cabin lights
            setCabinLightsPower(false);

            G.shakeAmount = 0.06;
            G.rainIntensity = 1.0;
            setWindVolume(1.0);

            pt(function() {
                showCaptain(
                    'BRACE BRACE BRACE! Heads down, stay down!',
                    4000
                );
            }, 2000);

            // Rapid descent
            var descInt = setInterval(function() {
                G.altitude -= 1500;
                G.speed += 5;
                G.shakeAmount = 0.05 + (35000 - Math.max(0, G.altitude)) / 35000 * 0.08;
                G.pitch = -8 - (35000 - Math.max(0, G.altitude)) / 35000 * 10;

                // Sky changes during descent
                var descF = Math.max(0, G.altitude) / 35000;
                scene.background.lerpColors(
                    new THREE.Color(0x1a0a0a),
                    new THREE.Color(0x0a0a15),
                    descF
                );

                updateHUD();

                if (G.altitude <= 0) {
                    clearInterval(descInt);
                    goPhase('crash');
                }
            }, 100);
            phaseTimers.push(descInt);
            break;

        // ─── CRASH ───
        case 'crash':
            G.altitude = 0;
            G.speed = 0;
            setPhaseLabel('IMPACT');

            playImpact();
            doFlash(1.0, 0.3);
            G.shakeAmount = 0.15;

            setEngineVolume(0);
            setWindVolume(0);
            setCabinVolume(0);

            showWarning('');
            hideWarning();

            // Violent shake then fade
            pt(function() {
                G.shakeAmount = 0.08;
            }, 500);

            pt(function() {
                G.shakeAmount = 0.03;
                fadeIn(2);
            }, 1500);

            pt(function() {
                G.shakeAmount = 0;
                goPhase('survival');
            }, 4000);
            break;

        // ─── SURVIVAL ───
        case 'survival':
            setPhaseLabel('');
            $alt.classList.remove('visible');
            $seatbelt.classList.remove('visible');
            $eStrip.classList.remove('visible');
            hideWarning();
            hideSub();
            $phase.style.background = '';
            G.rainIntensity = 0.3;

            cabinGroup.visible = false;
            stormCloudGroup.visible = false;
            airportGroup.visible = false;
            survivalGroup.visible = true;

            scene.background = new THREE.Color(0x050508);
            scene.fog = new THREE.FogExp2(0x050508, 0.02);
            renderer.toneMappingExposure = 0.5;
            ambientLight.intensity = 0.15;

            camera.position.set(0, 1.7, 15);
            camera.lookAt(new THREE.Vector3(5, 1, -3));
            G.cameraBasePos.copy(camera.position);
            G.shakeAmount = 0;

            fadeOut(3);

            pt(function() {
                $survival.innerHTML = 'You survived.';
                $survival.classList.add('visible');
            }, 3000);

            pt(function() {
                $survival.classList.remove('visible');
            }, 6000);

            pt(function() {
                $survival.innerHTML =
                    'In reality, 95.7% of passengers survive plane crashes.<br><br>' +
                    'Flying remains the safest form of long-distance travel.<br><br>' +
                    'Your chances of being in a fatal crash are<br><b style="font-size:2rem">1 in 13,700,000</b>';
                $survival.classList.add('visible');
            }, 7500);

            pt(function() {
                $continueBtn.classList.add('visible');
            }, 12000);
            break;
        }
    }

    // ═══════════════════════════════════════════════════
    //  CABIN LIGHT CONTROLS
    // ═══════════════════════════════════════════════════
    function dimCabinLights(dim) {
        G.cabinLightsDim = dim;
        var targetIntensity = dim ? 0.1 : 0.4;
        for (var i = 0; i < cabinLights.length; i++) {
            cabinLights[i].intensity = targetIntensity;
        }
        for (var j = 0; j < cabinLightMeshes.length; j++) {
            cabinLightMeshes[j].material = dim ? MAT.lightEmitDim : MAT.lightEmit;
        }
    }

    function setCabinLightsPower(on) {
        G.cabinLightsOn = on;
        for (var i = 0; i < cabinLights.length; i++) {
            cabinLights[i].intensity = on ? 0.1 : 0;
        }
        for (var j = 0; j < cabinLightMeshes.length; j++) {
            cabinLightMeshes[j].visible = on;
        }
    }

    function flickerCabinLights() {
        var count = 0;
        var flickInt = setInterval(function() {
            count++;
            var on = count % 2 === 0;
            for (var i = 0; i < cabinLights.length; i++) {
                cabinLights[i].intensity = on ? 0.15 : 0;
            }
            for (var j = 0; j < cabinLightMeshes.length; j++) {
                cabinLightMeshes[j].visible = on;
            }
            if (count > 8) {
                clearInterval(flickInt);
                dimCabinLights(true);
            }
        }, 100);
    }

    // ═══════════════════════════════════════════════════
    //  LIGHTNING EFFECT
    // ═══════════════════════════════════════════════════
    function triggerLightning() {
        doFlash(0.6 + Math.random() * 0.4, 0.3 + Math.random() * 0.4);
        playThunder();

        // Create lightning bolt geometry in scene
        var bolt = createLightningBolt();
        lightningGroup.add(bolt);
        setTimeout(function() { lightningGroup.remove(bolt); }, 200);
    }

    function createLightningBolt() {
        var points = [];
        var x = (Math.random() - 0.5) * 100;
        var z = (Math.random() - 0.5) * 100;
        var y = 50 + Math.random() * 30;
        for (var i = 0; i < 10; i++) {
            points.push(new THREE.Vector3(
                x + (Math.random() - 0.5) * 10,
                y - i * (y / 10),
                z + (Math.random() - 0.5) * 10
            ));
        }
        var geo = new THREE.BufferGeometry().setFromPoints(points);
        var mat = new THREE.LineBasicMaterial({ color: 0xeeeeff, linewidth: 2 });
        return new THREE.Line(geo, mat);
    }

    // ═══════════════════════════════════════════════════
    //  OXYGEN MASKS
    // ═══════════════════════════════════════════════════
    function dropOxygenMasks() {
        var positions = ['25%', '40%', '55%', '70%'];
        for (var i = 0; i < positions.length; i++) {
            (function(idx) {
                pt(function() {
                    var mask = document.createElement('div');
                    mask.className = 'oxygen-mask';
                    mask.style.left = positions[idx];
                    mask.style.top = '-100px';
                    mask.innerHTML = '<div class="mask-tube"></div><div class="mask-cup"></div>';
                    document.body.appendChild(mask);

                    setTimeout(function() {
                        mask.style.opacity = '1';
                        mask.style.transform = 'translateY(200px)';
                    }, 50);
                }, idx * 150);
            })(i);
        }
    }

    // ═══════════════════════════════════════════════════
    //  CAMERA ANIMATION HELPER
    // ═══════════════════════════════════════════════════
    function animateCamera(target, duration, callback) {
        var start = camera.position.clone();
        var startTime = performance.now();
        function step(now) {
            var t = Math.min((now - startTime) / duration, 1);
            t = t * t * (3 - 2 * t); // smoothstep
            camera.position.lerpVectors(start, target, t);
            if (t < 1) {
                requestAnimationFrame(step);
            } else {
                if (callback) callback();
            }
        }
        requestAnimationFrame(step);
    }

    // ═══════════════════════════════════════════════════
    //  INPUT
    // ═══════════════════════════════════════════════════
    var audioStarted = false;

    document.addEventListener('click', function() {
        if (!audioStarted) {
            initAudio();
            audioStarted = true;
        }

        if (G.transitioning) return;
        if (!G.canClick) return;

        switch (G.phase) {
            case 'airport': goPhase('boarding'); break;
            case 'boarding': goPhase('seated'); break;
            case 'seated': goPhase('taxi'); break;
        }
    });

    document.addEventListener('mousemove', function(e) {
        G.mouseX = e.clientX;
        G.mouseY = e.clientY;
        if (['airport', 'boarding', 'seated', 'cruising'].indexOf(G.phase) !== -1) {
            G.targetLookX = (e.clientX / window.innerWidth - 0.5) * 0.6;
            G.targetLookY = (e.clientY / window.innerHeight - 0.5) * 0.3;
        }
    });

    // Continue button → back to parent
    $continueBtn.addEventListener('click', function() {
        if (window.parent !== window) {
            window.parent.postMessage('simulation-complete', '*');
        }
    });

    // ═══════════════════════════════════════════════════
    //  MAIN ANIMATION LOOP
    // ═══════════════════════════════════════════════════
    var clock = new THREE.Clock();

    function animate() {
        requestAnimationFrame(animate);
        G.delta = Math.min(clock.getDelta(), 0.1);
        G.time += G.delta;

        // ── Smooth look ──
        G.lookX += (G.targetLookX - G.lookX) * 0.04;
        G.lookY += (G.targetLookY - G.lookY) * 0.04;

        // ── Camera shake ──
        if (G.shakeAmount > 0.0001) {
            camera.position.x = G.cameraBasePos.x + (Math.random() - 0.5) * G.shakeAmount * 2;
            camera.position.y = G.cameraBasePos.y + (Math.random() - 0.5) * G.shakeAmount * 2;
            camera.position.z = G.cameraBasePos.z + (Math.random() - 0.5) * G.shakeAmount;
            camera.rotation.z = (Math.random() - 0.5) * G.shakeAmount * 0.4;
        }

        // ── Phase-specific camera ──
        if (G.phase === 'airport') {
            camera.rotation.y = -0.6 + G.lookX;
            camera.rotation.x = G.lookY * 0.5;
        }
        if (G.phase === 'boarding') {
            camera.rotation.y = G.lookX * 1.5;
            camera.rotation.x = G.lookY * 0.5;
        }
        if (G.phase === 'seated' || G.phase === 'taxi' || G.phase === 'takeoff' ||
            G.phase === 'climbing') {
            // Looking out window
            camera.rotation.y = Math.PI / 2 + G.lookX * 0.5;
            camera.rotation.x = G.lookY * 0.3;
        }
        if (['cruising', 'turbulence_light', 'storm', 'lightning_intense', 'emergency'].indexOf(G.phase) !== -1) {
            camera.rotation.y = Math.PI / 2 + Math.sin(G.time * 0.15) * 0.015 + G.lookX * 0.4;
            camera.rotation.x = G.lookY * 0.2 + G.pitch * 0.01;
            camera.rotation.z += G.roll * 0.005;
        }
        if (G.phase === 'crash') {
            camera.rotation.x = G.pitch * 0.015;
        }
        if (G.phase === 'survival') {
            camera.rotation.y = Math.PI * 0.05 + Math.sin(G.time * 0.1) * 0.02 + G.lookX * 0.2;
            camera.rotation.x = -0.05 + G.lookY * 0.1;
        }

        // ── Animate clouds ──
        var cSpeed = G.speed * 0.08;
        cloudGroup.children.forEach(function(c) {
            c.position.x -= c.userData.speed * G.delta * cSpeed;
            if (c.position.x < -300) {
                c.position.x = 300;
                c.position.z = (Math.random() - 0.5) * 600;
            }
        });
        stormCloudGroup.children.forEach(function(c) {
            c.position.x -= c.userData.speed * G.delta * cSpeed * 0.5;
            if (c.position.x < -250) {
                c.position.x = 250;
                c.position.z = (Math.random() - 0.5) * 500;
            }
        });

        // ── Emergency light flashing ──
        if (G.emergencyLights) {
            var emOn = Math.sin(G.time * 6) > 0;
            for (var el = 0; el < emergencyLightMeshes.length; el++) {
                emergencyLightMeshes[el].visible = (el + (emOn ? 0 : 1)) % 2 === 0;
            }
        }

        // ── Survival fire flicker ──
        if (G.phase === 'survival') {
            survivalGroup.children.forEach(function(child) {
                if (child.userData.flicker !== undefined) {
                    child.userData.flicker += G.delta * 5;
                    child.position.y = child.userData.baseY + Math.sin(child.userData.flicker) * 0.2;
                    child.scale.x = 0.8 + Math.sin(child.userData.flicker * 1.3) * 0.3;
                }
                if (child.userData.flashPhase !== undefined) {
                    child.visible = Math.sin(G.time * 4 + child.userData.flashPhase) > 0.3;
                }
            });
        }

        // ── Rain ──
        updateRain();

        // ── Render ──
        renderer.render(scene, camera);
    }

    // ═══════════════════════════════════════════════════
    //  WINDOW RESIZE
    // ═══════════════════════════════════════════════════
    window.addEventListener('resize', function() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        rainCanvas.width = window.innerWidth;
        rainCanvas.height = window.innerHeight;
    });

    // ═══════════════════════════════════════════════════
    //  INIT & START
    // ═══════════════════════════════════════════════════
    buildAirport();
    buildCabin();
    populateClouds();
    populateStormClouds();
    buildSurvivalScene();
    initRain();

    // Start
    fadeOut(2);
    pt(function() { goPhase('airport'); }, 500);

    animate();

    })();
    </script>
</body>
</html>
