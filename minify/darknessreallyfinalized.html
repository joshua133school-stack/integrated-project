<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nighttime Routine</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; background: #000; font-family: 'Georgia', serif; }
        #canvas-container { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        
        .prompt-overlay {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-size: 1.8rem; text-align: center;
            pointer-events: none; z-index: 50; opacity: 0; transition: opacity 0.8s ease;
            text-shadow: 0 0 20px rgba(255,255,255,0.5);
        }
        .prompt-overlay.visible { opacity: 1; }
        
        #crosshair {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 20px; height: 20px; z-index: 40; pointer-events: none;
            transition: opacity 1s;
        }
        #crosshair::before, #crosshair::after {
            content: ''; position: absolute; background: rgba(255,255,255,0.5);
        }
        #crosshair::before { width: 2px; height: 20px; left: 9px; }
        #crosshair::after { width: 20px; height: 2px; top: 9px; }
        
        #interaction-hint {
            position: fixed; bottom: 100px; left: 50%; transform: translateX(-50%);
            color: rgba(255,255,255,0.8); font-size: 1rem; z-index: 50;
            opacity: 0; transition: opacity 0.3s ease;
            text-shadow: 0 0 10px rgba(0,0,0,0.8);
        }
        #interaction-hint.visible { opacity: 1; }
        
        #lights-remaining {
            display: none;
        }
        
        #fade-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: black; z-index: 100; opacity: 0; pointer-events: none;
            transition: opacity 1s ease;
        }
        #fade-overlay.visible { opacity: 1; pointer-events: all; }
        
        
        /* Editor Mode Styles */
        #editor-panel {
            position: fixed; top: 10px; left: 10px;
            background: rgba(0,0,0,0.85); color: white;
            padding: 15px; border-radius: 8px; z-index: 150;
            width: 260px; font-size: 12px; font-family: Arial, sans-serif;
            display: none;
        }
        #editor-panel.visible { display: block; }
        #editor-panel h3 { color: #8cf; margin: 8px 0 5px; font-size: 13px; }
        #editor-panel button {
            background: #456; color: white; border: none;
            padding: 5px 10px; margin: 2px; border-radius: 3px; cursor: pointer;
        }
        #editor-panel button:hover { background: #567; }
        #editor-panel .selected-name { color: #8cf; font-weight: bold; }
        #editor-panel .coords { color: #aaa; font-family: monospace; }
        #editor-changes {
            background: #112; padding: 8px; border-radius: 5px;
            max-height: 150px; overflow-y: auto; font-family: monospace;
            font-size: 10px; color: #0f0; margin-top: 8px;
        }
        #editor-mode-hint {
            position: fixed; top: 10px; left: 50%; transform: translateX(-50%);
            background: rgba(100,50,50,0.9); color: white; padding: 8px 20px;
            border-radius: 5px; z-index: 150; display: none; font-family: Arial;
        }
        #editor-mode-hint.visible { display: block; }
        
        .scene-checklist {
            position: fixed;
            top: 30px;
            left: 30px;
            color: #fff;
            font-size: 18px;
            z-index: 100;
            pointer-events: none;
            text-shadow: 0 0 10px rgba(0,0,0,0.8);
            transition: opacity 2s;
            display: none;
            font-family: Georgia, serif;
        }
        .scene-checklist.visible { display: block; }
        
        .checklist-item {
            display: flex;
            align-items: center;
            margin: 12px 0;
            opacity: 0.7;
            transition: opacity 0.3s;
        }
        
        .checklist-item.completed {
            opacity: 1;
        }
        
        .checklist-item.completed .task-text {
            text-decoration: line-through;
            color: #8f8;
        }
        
        .checkbox {
            width: 22px;
            height: 22px;
            border: 2px solid #fff;
            border-radius: 4px;
            margin-right: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
        }
        
        .checklist-item.completed .checkbox {
            background: #4a4;
            border-color: #4a4;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    <div class="prompt-overlay" id="prompt"></div>
    <div id="crosshair"></div>
    <div id="interaction-hint">Click to interact</div>
    <div id="lights-remaining"></div>
    <div id="fade-overlay"></div>
    
    <audio id="audio-countryside" loop preload="auto"><source src="../data/countrysound.mp4" type="audio/mp4"></audio>
    <audio id="audio-sheep" loop preload="auto"><source src="../data/sheepsound.mp4" type="audio/mp4"></audio>
    <audio id="audio-waves" loop preload="auto"><source src="../data/wavessound.mp4" type="audio/mp4"></audio>
    
    <!-- Editor UI -->
    <div id="editor-mode-hint">EDITOR MODE - Press Tab to exit</div>
    <div id="editor-panel">
        <h3>üõ†Ô∏è Editor Mode</h3>
        <p style="color:#888;font-size:10px;">Look at object + E to select | G to grab | Arrow keys to move</p>
        
        <h3>Selected</h3>
        <div id="editor-selected">None - look at object and press E</div>
        
        <h3>Controls</h3>
        <button onclick="editorDuplicate()">Duplicate</button>
        <button onclick="editorDelete()">Delete</button>
        <button onclick="editorDeselect()">Deselect (Esc)</button>
        
        <h3>Changes Log</h3>
        <button onclick="editorCopyChanges()">üìã Copy Changes</button>
        <button onclick="editorClearChanges()">Clear</button>
        <div id="editor-changes">No changes yet</div>
    </div>

    <!-- House Checklist -->
    <div id="house-checklist" class="scene-checklist">
        <div class="checklist-item" id="task-house-lights">
            <div class="checkbox"></div>
            <span class="task-text">Turn off all the lights (<span id="lights-counter">0</span>/4)</span>
        </div>
        <div class="checklist-item" id="task-house-bed">
            <div class="checkbox"></div>
            <span class="task-text">Go to bed</span>
        </div>
    </div>

    <!-- Dream Checklist -->
    <div id="dream-checklist" class="scene-checklist">
        <div class="checklist-item" id="task-dream-lookup">
            <div class="checkbox"></div>
            <span class="task-text">Look up at the stars</span>
        </div>
        <div class="checklist-item" id="task-dream-stars">
            <div class="checkbox"></div>
            <span class="task-text">Draw stars in the sky (<span id="star-counter">0</span>/30)</span>
        </div>
    </div>

    <!-- Sheep Checklist -->
    <div id="sheep-checklist" class="scene-checklist">
        <div class="checklist-item" id="task-sheep-count">
            <div class="checkbox"></div>
            <span class="task-text">Count the sheep</span>
        </div>
        <div class="checklist-item" id="task-sheep-escape">
            <div class="checkbox"></div>
            <span class="task-text">Run from the big sheep</span>
        </div>
    </div>

    <!-- Ocean Checklist -->
    <div id="ocean-checklist" class="scene-checklist">
        <div class="checklist-item" id="task-ocean-storm">
            <div class="checkbox"></div>
            <span class="task-text">Survive the storm</span>
        </div>
        <div class="checklist-item" id="task-ocean-lighthouse">
            <div class="checkbox"></div>
            <span class="task-text">Find the lighthouse</span>
        </div>
        <div class="checklist-item" id="task-ocean-dawn">
            <div class="checkbox"></div>
            <span class="task-text">Watch the dawn</span>
        </div>
    </div>

    <!-- Christmas Checklist -->
    <div id="christmas-checklist" class="scene-checklist">
        <div class="checklist-item" id="task-lights">
            <div class="checkbox"></div>
            <span class="task-text">Turn on the lights</span>
        </div>
        <div class="checklist-item" id="task-fire">
            <div class="checkbox"></div>
            <span class="task-text">Light the campfire</span>
        </div>
        <div class="checklist-item" id="task-cocoa">
            <div class="checkbox"></div>
            <span class="task-text">Pick up hot cocoa</span>
        </div>
        <div class="checklist-item" id="task-drink">
            <div class="checkbox"></div>
            <span class="task-text">Drink the cocoa</span>
        </div>
        <div class="checklist-item" id="task-rest">
            <div class="checkbox"></div>
            <span class="task-text">Rest under the stars</span>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // House dimensions
        const HOUSE = {
            width: 32,   // x: -16 to 16
            depth: 18,   // z: -9 to 9 (reduced front area)
            height: 3.5,
            wallThick: 0.2,
            // Room dividers
            bedroomWallX: -6,
            kitchenWallX: 8,
            doorWidth: 1.2,
            doorHeight: 2.4
        };

        const State = {
            phase: 'intro',
            locked: false,
            canMove: true,
            canLook: true,
            canInteract: true,
            keys: { w: false, a: false, s: false, d: false },
            velocity: null,
            lightsOn: [],
            totalLights: 0,
            electronicsRevealed: false,
            showElectronicsOutline: false,
            ledsActive: false,
            showSwitchOutline: false
        };

        let scene, camera, renderer;
        let cameraYaw = 0, cameraPitch = 0;
        let lights = [];
        let lamps = [];
        let lightSwitches = [];
        let electronics = [];
        let bed = null;
        let raycaster, interactables = [];
        let creepyEyes = null;  // The scary eyes at the door
        let flashlight = null;  // Player's flashlight
        
        // Dream scene variables
        let isDreamScene = false;
        let groundObjects = [];
        let houseObjects = [];
        let fireflies = [];
        let colliders = [];
        let animals = [];
        let streamMesh = null;
        let fallProgress = 0;
        let targetPitch = 0;
        let audioCtx, masterGain;
        let stars2D = [];
        let sheep = [];
        let sheepDebugFrames = 0;
        let chaserSheep = null;
        let isMouseDown = false;  // For free look in sheep phase
        let lastMouseX = 0, lastMouseY = 0;  // For tracking mouse in free cam mode
        
        // Ocean scene variables
        let isOceanScene = false;
        let oceanMesh = null;
        let boatGroup = null;
        let stormClouds = [];
        let lightningFlash = null;
        let lighthouseBeam = null;
        let lighthouseGroup = null;
        let oceanPhase = 'calm';  // calm, storm_building, storm_peak, lighthouse, calming, peaceful
        let oceanTime = 0;
        let stormIntensity = 0;
        let waveAmplitude = 0.5;
        let raindrops = [];
        
        // Christmas scene variables
        let isChristmasScene = false;
        let christmasTree = null;
        let christmasLights = [];
        let lightsOn = false;
        let campfire = null;
        let fireParticles = [];
        let fireLight = null;
        let fireLit = false;
        let cocoaMug = null;
        let lightButton = null;
        let snowflakes = [];
        let christmasPhase = 'dark';
        
        // Cocoa holding state
        let holdingCocoa = false;
        let cocoaInHand = null;
        let drinkingCocoa = false;
        let lyingDown = false;
        let lookingAtStars = false;
        let eyesClosed = false;
        let starField = [];
        
        // Editor mode
        let editorMode = false;
        let editorObjects = [];  // All editable objects
        let editorSelected = null;
        let editorHighlighted = null;
        let editorGrabbing = false;
        let editorChanges = [];

        function init() {
            State.velocity = new THREE.Vector3();
            raycaster = new THREE.Raycaster();
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 100);

            // Create flashlight (attached to camera)
            flashlight = new THREE.SpotLight(0xffffee, 2, 20, Math.PI / 6, 0.3, 1);
            flashlight.visible = false;  // Hidden until player wakes up
            camera.add(flashlight);
            flashlight.position.set(0, 0, 0);
            flashlight.target.position.set(0, 0, -1);
            camera.add(flashlight.target);

            document.addEventListener('pointerlockchange', () => {
                State.locked = document.pointerLockElement !== null;
            });
            
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('keydown', e => {
                // Toggle editor mode with Tab
                if (e.code === 'Tab') {
                    e.preventDefault();
                    toggleEditorMode();
                    return;
                }
                
                // Editor mode controls
                if (editorMode) {
                    // E to select object under crosshair
                    if (e.code === 'KeyE') {
                        editorSelectUnderCrosshair();
                    }
                    // G to grab/move
                    if (e.code === 'KeyG' && editorSelected) {
                        editorGrabbing = !editorGrabbing;
                        updateEditorUI();
                    }
                    // Escape to deselect
                    if (e.code === 'Escape') {
                        editorDeselect();
                    }
                    // Arrow keys to move selected object
                    if (editorSelected && editorGrabbing) {
                        const step = e.shiftKey ? 0.5 : 0.1;
                        let moved = false;
                        if (e.code === 'ArrowLeft') { editorSelected.position.x -= step; moved = true; }
                        if (e.code === 'ArrowRight') { editorSelected.position.x += step; moved = true; }
                        if (e.code === 'ArrowUp') { editorSelected.position.z -= step; moved = true; }
                        if (e.code === 'ArrowDown') { editorSelected.position.z += step; moved = true; }
                        if (e.code === 'PageUp') { editorSelected.position.y += step; moved = true; }
                        if (e.code === 'PageDown') { editorSelected.position.y -= step; moved = true; }
                        if (moved) {
                            editorLogChange(editorSelected);
                            updateEditorUI();
                        }
                        return;
                    }
                }
                
                // Normal movement (when not grabbing)
                if (!editorGrabbing) {
                    if (e.code === 'KeyW') State.keys.w = true;
                    if (e.code === 'KeyA') State.keys.a = true;
                    if (e.code === 'KeyS') State.keys.s = true;
                    if (e.code === 'KeyD') State.keys.d = true;
                    if (e.code === 'KeyF' && flashlight && (State.phase === 'turnOffLights' || State.phase === 'scared' || State.phase === 'turnOnLights' || State.phase === 'turnOffLights2' || State.phase === 'goToBed2' || State.phase === 'goToBed1')) {
                        flashlight.visible = !flashlight.visible;
                    }
                }
                // Arrow keys for movement when not in grab mode
                if (!editorMode || !editorGrabbing) {
                    if (e.code === 'ArrowUp') State.keys.w = true;
                    if (e.code === 'ArrowLeft') State.keys.a = true;
                    if (e.code === 'ArrowDown') State.keys.s = true;
                    if (e.code === 'ArrowRight') State.keys.d = true;
                }
            });
            document.addEventListener('keyup', e => {
                if (e.code === 'KeyW') State.keys.w = false;
                if (e.code === 'KeyA') State.keys.a = false;
                if (e.code === 'KeyS') State.keys.s = false;
                if (e.code === 'KeyD') State.keys.d = false;
                if (e.code === 'ArrowUp') State.keys.w = false;
                if (e.code === 'ArrowLeft') State.keys.a = false;
                if (e.code === 'ArrowDown') State.keys.s = false;
                if (e.code === 'ArrowRight') State.keys.d = false;
            });
            document.addEventListener('click', onClick);
            document.addEventListener('mousedown', () => { isMouseDown = true; });
            document.addEventListener('mouseup', () => { isMouseDown = false; });
            
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            createHouse();
            scene.add(camera);  // Add camera to scene so flashlight works
            startIntro();
            animate();
        }

        function createHouse() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e);

            const W = HOUSE.width;
            const D = HOUSE.depth;
            const H = HOUSE.height;
            const T = HOUSE.wallThick;

            // Materials
            const floorMat = new THREE.MeshLambertMaterial({ color: 0x6a5040 });
            const ceilingMat = new THREE.MeshLambertMaterial({ color: 0xfafafa });
            const wallMat = new THREE.MeshLambertMaterial({ color: 0xe8e0d5 });
            const bedroomWallMat = new THREE.MeshLambertMaterial({ color: 0xd5dde8 });
            const kitchenWallMat = new THREE.MeshLambertMaterial({ color: 0xf0ebe5 });

            // ============ FLOOR ============
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(W, D), floorMat);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = 0;
            scene.add(floor);

            // Floor plank lines
            for (let x = -W/2; x < W/2; x += 0.6) {
                const line = new THREE.Mesh(
                    new THREE.PlaneGeometry(0.02, D),
                    new THREE.MeshLambertMaterial({ color: 0x4a3020 })
                );
                line.rotation.x = -Math.PI / 2;
                line.position.set(x, 0.002, 0);
                scene.add(line);
            }

            // ============ CEILING ============
            const ceiling = new THREE.Mesh(new THREE.PlaneGeometry(W, D), ceilingMat);
            ceiling.rotation.x = Math.PI / 2;
            ceiling.position.y = H;
            scene.add(ceiling);

            // ============ OUTER WALLS ============
            // Position walls so inner face is at room boundary
            // Back wall (north, z = -D/2)
            addWall(0, H/2, -D/2 - T/2, W + T, H, T, wallMat);
            // Front wall (south, z = D/2)
            addWall(0, H/2, D/2 + T/2, W + T, H, T, wallMat);
            // Left wall (west, x = -W/2)
            addWall(-W/2 - T/2, H/2, 0, T, H, D + T, bedroomWallMat);
            // Right wall (east, x = W/2)
            addWall(W/2 + T/2, H/2, 0, T, H, D + T, kitchenWallMat);

            // ============ INTERIOR WALLS ============
            const bedroomX = HOUSE.bedroomWallX;  // -6
            const kitchenX = HOUSE.kitchenWallX;  // 8
            const doorW = HOUSE.doorWidth;  // 1.2
            const doorH = HOUSE.doorHeight; // 2.4
            const doorZ = -3; // Door center position along z
            const wallT = 0.25; // Interior wall thickness

            // --- BEDROOM WALL (x = bedroomX = -6) ---
            // Wall from back (z=-14) to door opening (z = doorZ - doorW/2 = -3.6)
            const bedroomBackLen = (D/2) - Math.abs(doorZ) - doorW/2;  // 14 - 3 - 0.6 = 10.4
            const bedroomBackZ = -D/2 + bedroomBackLen/2;  // -14 + 5.2 = -8.8
            addWall(bedroomX, H/2, bedroomBackZ, wallT, H, bedroomBackLen, wallMat);
            
            // Wall above door
            const aboveDoorH = H - doorH;  // 3.5 - 2.4 = 1.1
            addWall(bedroomX, doorH + aboveDoorH/2, doorZ, wallT, aboveDoorH, doorW + 0.3, wallMat);
            
            // Wall from door (z = doorZ + doorW/2 = -2.4) to front (z=14)
            const bedroomFrontLen = D/2 + doorZ + doorW/2;  // 14 + (-3) + 0.6 = 11.6... wait
            // Actually: from z = -2.4 to z = 14 = 16.4
            const bedroomFrontStart = doorZ + doorW/2;  // -2.4
            const bedroomFrontEnd = D/2;  // 14
            const bedroomFrontLenCalc = bedroomFrontEnd - bedroomFrontStart;  // 16.4
            const bedroomFrontZ = bedroomFrontStart + bedroomFrontLenCalc/2;  // -2.4 + 8.2 = 5.8
            addWall(bedroomX, H/2, bedroomFrontZ, wallT, H, bedroomFrontLenCalc, wallMat);
            
            // Door frame
            addDoorFrame(bedroomX, doorZ, 'bedroom');

            // --- KITCHEN WALL (x = kitchenX = 8) ---
            // Wall from back to doorway only (open plan after that)
            addWall(kitchenX, H/2, bedroomBackZ, wallT, H, bedroomBackLen, wallMat);
            
            // No wall above doorway - fully open to living/dining area
            // No door frame either

            // ============ WINDOWS ============
            addWindow(0, 1.8, D/2 - 0.15, 2, 1.5, 0); // Living room front wall (moved inside slightly)
            addWindow(-W/2 + 0.15, 1.8, -6, 1.8, 1.4, Math.PI/2); // Bedroom left wall (moved inside slightly)
            addWindow(12, 1.8, -D/2 + 0.15, 1.5, 1.2, 0); // Kitchen back wall (moved inside slightly)

            // ============ CAMERA START ============
            camera.position.set(0, 1.6, 3);
            cameraYaw = Math.PI;
            cameraPitch = 0;
            updateCamera();

            // ============ ROOM CONTENTS ============
            createLivingRoom();
            createBedroom();
            createKitchen();
            createHallway();
            createCreepyEyes();

            // Ambient light
            const ambient = new THREE.AmbientLight(0x404060, 0.15);
            scene.add(ambient);

            updateLightsUI();
        }

        function addWall(x, y, z, w, h, d, mat) {
            const wall = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), mat);
            wall.position.set(x, y, z);
            scene.add(wall);
            return wall;
        }

        function addDoorFrame(x, z, name) {
            const frameMat = new THREE.MeshLambertMaterial({ color: 0xffffff });
            const doorW = HOUSE.doorWidth;
            const doorH = HOUSE.doorHeight;
            
            // Left frame
            const left = new THREE.Mesh(new THREE.BoxGeometry(0.08, doorH, 0.12), frameMat);
            left.position.set(x, doorH/2, z - doorW/2);
            scene.add(left);
            
            // Right frame
            const right = new THREE.Mesh(new THREE.BoxGeometry(0.08, doorH, 0.12), frameMat);
            right.position.set(x, doorH/2, z + doorW/2);
            scene.add(right);
            
            // Top frame
            const top = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.08, doorW + 0.16), frameMat);
            top.position.set(x, doorH + 0.04, z);
            scene.add(top);

            // Add actual door for bedroom
            if (name === 'bedroom') {
                const doorMat = new THREE.MeshLambertMaterial({ color: 0xf5f0e8 });
                const door = new THREE.Mesh(new THREE.BoxGeometry(0.05, doorH - 0.1, doorW - 0.1), doorMat);
                door.position.set(x, doorH/2, z);
                scene.add(door);
            }
        }

        function addWindow(x, y, z, w, h, rotY) {
            const group = new THREE.Group();
            const frameMat = new THREE.MeshLambertMaterial({ color: 0xffffff });
            
            // Glass - blue tint, visible from both sides
            const glass = new THREE.Mesh(
                new THREE.PlaneGeometry(w, h),
                new THREE.MeshBasicMaterial({ color: 0x4a6a8a, transparent: true, opacity: 0.7, side: THREE.DoubleSide })
            );
            group.add(glass);
            
            // Frame
            const frameT = 0.06;
            const topF = new THREE.Mesh(new THREE.BoxGeometry(w + 0.1, frameT, 0.08), frameMat);
            topF.position.y = h/2;
            group.add(topF);
            
            const bottomF = new THREE.Mesh(new THREE.BoxGeometry(w + 0.1, frameT, 0.08), frameMat);
            bottomF.position.y = -h/2;
            group.add(bottomF);
            
            const leftF = new THREE.Mesh(new THREE.BoxGeometry(frameT, h, 0.08), frameMat);
            leftF.position.x = -w/2;
            group.add(leftF);
            
            const rightF = new THREE.Mesh(new THREE.BoxGeometry(frameT, h, 0.08), frameMat);
            rightF.position.x = w/2;
            group.add(rightF);
            
            // Cross bars
            const crossH = new THREE.Mesh(new THREE.BoxGeometry(w, 0.04, 0.04), frameMat);
            crossH.position.z = 0.02;
            group.add(crossH);
            
            const crossV = new THREE.Mesh(new THREE.BoxGeometry(0.04, h, 0.04), frameMat);
            crossV.position.z = 0.02;
            group.add(crossV);
            
            // Sill
            const sill = new THREE.Mesh(new THREE.BoxGeometry(w + 0.2, 0.05, 0.15), frameMat);
            sill.position.set(0, -h/2 - 0.03, 0.08);
            group.add(sill);
            
            group.position.set(x, y, z);
            group.rotation.y = rotY;
            scene.add(group);
        }

        function createLivingRoom() {
            const darkWood = new THREE.MeshLambertMaterial({ color: 0x3a2a1a });
            const lightWood = new THREE.MeshLambertMaterial({ color: 0x8b7355 });
            const fabric = new THREE.MeshLambertMaterial({ color: 0x5a6478 });
            const cushion = new THREE.MeshLambertMaterial({ color: 0x7a8a9a });
            const metal = new THREE.MeshLambertMaterial({ color: 0x888888 });

            // === TV SETUP (against back wall, z=-9, need margin) ===
            const tvZ = -8.4;  // depth 0.5, back at -8.65
            addBox(0, 0.3, tvZ, 2.5, 0.6, 0.5, darkWood); // Stand
            addBox(0, 1.25, tvZ, 2.2, 1.3, 0.1, new THREE.MeshLambertMaterial({ color: 0x111111 })); // TV
            const screen = new THREE.Mesh(new THREE.PlaneGeometry(2, 1.1), new THREE.MeshBasicMaterial({ color: 0x0a0a0a }));
            screen.position.set(0, 1.25, tvZ + 0.06);
            scene.add(screen);
            createElectronic(0.95, 0.55, tvZ + 0.26, 'TV standby');

            // Router on TV stand
            addBox(-0.8, 0.65, tvZ + 0.1, 0.3, 0.05, 0.2, new THREE.MeshLambertMaterial({ color: 0x222222 }));
            createElectronic(-0.85, 0.68, tvZ + 0.2, 'Router LED');
            createElectronic(-0.75, 0.68, tvZ + 0.2, 'Router LED 2');

            // === COUCH (facing TV) ===
            const couchX = 0, couchZ = -4;
            addBox(couchX, 0.35, couchZ, 3.2, 0.5, 1.1, fabric);
            addBox(couchX, 0.85, couchZ + 0.55, 3.2, 0.7, 0.2, fabric);
            addBox(couchX - 1.5, 0.55, couchZ, 0.2, 0.5, 1.1, fabric);
            addBox(couchX + 1.5, 0.55, couchZ, 0.2, 0.5, 1.1, fabric);
            for (let i = -1; i <= 1; i++) {
                addBox(couchX + i, 0.65, couchZ - 0.1, 0.9, 0.15, 0.85, cushion);
            }
            // Throw pillows
            addBox(couchX - 1.2, 0.75, couchZ - 0.2, 0.35, 0.35, 0.1, new THREE.MeshLambertMaterial({ color: 0x8a5a4a }));
            addBox(couchX + 1.2, 0.75, couchZ - 0.2, 0.35, 0.35, 0.1, new THREE.MeshLambertMaterial({ color: 0x5a7a6a }));

            // === COFFEE TABLE ===
            const ctZ = -6;
            addBox(0, 0.4, ctZ, 1.4, 0.06, 0.8, lightWood);
            addBox(-0.55, 0.18, ctZ - 0.3, 0.05, 0.35, 0.05, metal);
            addBox(0.55, 0.18, ctZ - 0.3, 0.05, 0.35, 0.05, metal);
            addBox(-0.55, 0.18, ctZ + 0.3, 0.05, 0.35, 0.05, metal);
            addBox(0.55, 0.18, ctZ + 0.3, 0.05, 0.35, 0.05, metal);
            // Books on coffee table
            addBox(0.3, 0.46, ctZ, 0.3, 0.08, 0.22, new THREE.MeshLambertMaterial({ color: 0x2f4f4f }));
            addBox(0.25, 0.52, ctZ, 0.25, 0.06, 0.18, new THREE.MeshLambertMaterial({ color: 0x8b0000 }));

            // === SIDE TABLE + TABLE LAMP (right of couch) ===
            const stX = 2.3, stZ = -4;
            addBox(stX, 0.3, stZ, 0.5, 0.6, 0.5, darkWood);
            createTableLamp(stX, 0.6, stZ, 'living');

            // === FLOOR LAMP (left of couch) ===
            createFloorLamp(-2.5, 0, -4, 'living');

            // === BOOKSHELF (open front, back against wall) ===
            // Back panel (thin, against wall)
            addBox(7, 1.1, -8.6, 0.4, 2.2, 0.1, darkWood);
            // Left side
            addBox(6.8, 1.1, -8.1, 0.05, 2.2, 1.1, darkWood);
            // Right side
            addBox(7.2, 1.1, -8.1, 0.05, 2.2, 1.1, darkWood);
            // Top
            addBox(7, 2.2, -8.1, 0.45, 0.05, 1.1, darkWood);
            // Shelves
            for (let s = 0; s < 4; s++) {
                addBox(7, 0.15 + s * 0.55, -8.1, 0.38, 0.04, 1.0, darkWood);
            }
            // Books (on shelves, spines facing out toward room)
            const bookColors = [0x8b4513, 0x2f4f4f, 0x8b0000, 0x006400, 0x4a4a8a, 0x654321];
            for (let shelf = 0; shelf < 4; shelf++) {
                for (let b = 0; b < 4; b++) {
                    const bookH = 0.22 + Math.random() * 0.12;
                    addBox(7, 0.17 + shelf * 0.55 + bookH/2, -7.8 + b * 0.22,
                        0.18, bookH, 0.05,
                        new THREE.MeshLambertMaterial({ color: bookColors[Math.floor(Math.random() * bookColors.length)] }));
                }
            }

            // === FLOOR LAMP by bookshelf ===
            createFloorLamp(6.9, 0, -7, 'living');

            // === RUG ===
            const rug = new THREE.Mesh(new THREE.PlaneGeometry(5, 3), new THREE.MeshLambertMaterial({ color: 0x6a5a4a }));
            rug.rotation.x = -Math.PI / 2;
            rug.position.set(0, 0.01, -5);
            rug.name = `LR_Rug_${editorObjectCounter++}`;
            rug.userData.editable = true;
            rug.userData.type = 'rug';
            scene.add(rug);
            editorObjects.push(rug);

            // === PLANT REMOVED ===

            // === ARMCHAIR facing TV (left side of room) ===
            // Back faces +z (towards front of house), seat faces TV at -z
            const armchairX = -4, armchairZ = -5;
            addBox(armchairX, 0.35, armchairZ, 1.0, 0.5, 1.0, fabric, 'LR_Armchair_Seat');
            addBox(armchairX, 0.85, armchairZ + 0.45, 1.0, 0.7, 0.15, fabric, 'LR_Armchair_Back'); // back towards +z
            addBox(armchairX - 0.45, 0.55, armchairZ, 0.12, 0.4, 1.0, fabric, 'LR_Armchair_ArmL');
            addBox(armchairX + 0.45, 0.55, armchairZ, 0.12, 0.4, 1.0, fabric, 'LR_Armchair_ArmR');
            addBox(armchairX, 0.62, armchairZ - 0.05, 0.85, 0.12, 0.85, cushion, 'LR_Armchair_Cushion');
            
            // === SIDE TABLE next to armchair ===
            addBox(armchairX + 1, 0.35, armchairZ, 0.45, 0.7, 0.45, darkWood, 'LR_Armchair_SideTable');
            // Small decorative item on table
            const smallVase = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.05, 0.12, 8),
                new THREE.MeshLambertMaterial({ color: 0x4a7a6a }));
            smallVase.position.set(armchairX + 1, 0.76, armchairZ);
            scene.add(smallVase);

            // === OTTOMAN/FOOTSTOOL in front of couch ===
            addBox(0, 0.25, -5, 0.7, 0.35, 0.5, new THREE.MeshLambertMaterial({ color: 0x5a5a68 }), 'LR_Ottoman');
            addBox(0, 0.45, -5, 0.65, 0.08, 0.45, cushion, 'LR_Ottoman_Cushion');

            // === MEDIA CONSOLE under TV ===
            addBox(-1.8, 0.25, tvZ, 0.8, 0.5, 0.4, darkWood, 'LR_MediaConsole_L');
            addBox(1.8, 0.25, tvZ, 0.8, 0.5, 0.4, darkWood, 'LR_MediaConsole_R');
            // Game console with LED
            addBox(-1.8, 0.55, tvZ + 0.1, 0.35, 0.08, 0.25, new THREE.MeshLambertMaterial({ color: 0x1a1a1a }), 'LR_GameConsole');
            createElectronic(-1.65, 0.6, tvZ + 0.2, 'Game console LED');
            // Cable box / streaming device
            addBox(1.8, 0.55, tvZ + 0.1, 0.25, 0.05, 0.2, new THREE.MeshLambertMaterial({ color: 0x1a1a1a }), 'LR_CableBox');
            createElectronic(1.9, 0.58, tvZ + 0.2, 'Cable box LED');
            // Power strip on floor (near media console)
            addBox(-2.2, 0.03, tvZ + 0.2, 0.4, 0.04, 0.1, new THREE.MeshLambertMaterial({ color: 0xf5f5f5 }), 'LR_PowerStrip');
            createElectronic(-2.35, 0.06, tvZ + 0.22, 'Power strip LED');
            createElectronic(-2.25, 0.06, tvZ + 0.22, 'Power strip LED 2');
            createElectronic(-2.05, 0.06, tvZ + 0.22, 'Power strip LED 3');
            // Smart speaker near couch
            addBox(2.5, 0.65, stZ, 0.1, 0.2, 0.1, new THREE.MeshLambertMaterial({ color: 0x2a2a2a }), 'LR_SmartSpeaker');
            createElectronic(2.5, 0.76, stZ + 0.03, 'Smart speaker LED');
            // Smoke detector on ceiling
            createElectronic(0, HOUSE.height - 0.1, -5, 'Smoke detector LED');
            createElectronic(-11, HOUSE.height - 0.1, -3, 'Bedroom smoke detector');
            createElectronic(12, HOUSE.height - 0.1, 0, 'Kitchen smoke detector');

            // === CORNER SHELF REMOVED ===

            // === ACCENT CHAIR (against bedroom wall, back faces -x) ===
            const accentX = -5.5, accentZ = 2;
            const accentFabric = new THREE.MeshLambertMaterial({ color: 0x7a6a5a });
            addBox(accentX, 0.35, accentZ, 0.9, 0.5, 0.9, accentFabric, 'LR_AccentChair_Seat');
            addBox(accentX - 0.4, 0.85, accentZ, 0.15, 0.7, 0.9, accentFabric, 'LR_AccentChair_Back'); // back faces -x (wall)
            addBox(accentX, 0.55, accentZ - 0.4, 0.9, 0.4, 0.1, accentFabric, 'LR_AccentChair_ArmL');
            addBox(accentX, 0.55, accentZ + 0.4, 0.9, 0.4, 0.1, accentFabric, 'LR_AccentChair_ArmR');
            // Small round side table (to the right of chair)
            const roundTable = new THREE.Mesh(new THREE.CylinderGeometry(0.25, 0.25, 0.04, 16), lightWood);
            roundTable.position.set(accentX, 0.5, accentZ + 1);
            scene.add(roundTable);
            const roundTableLeg = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.06, 0.48, 8), darkWood);
            roundTableLeg.position.set(accentX, 0.24, accentZ + 1);
            scene.add(roundTableLeg);

            // === FLOOR LAMP near accent chair (to the left) ===
            createFloorLamp(accentX, 0, accentZ - 1.2, 'living');

            // === ENTRY RUG REMOVED ===

            // === MAGAZINE RACK beside couch ===
            addBox(-2.2, 0.25, -4, 0.15, 0.5, 0.35, metal, 'LR_MagRack_Frame');
            addBox(-2.2, 0.25, -4.12, 0.12, 0.45, 0.04, metal, 'LR_MagRack_Back');
            // Magazines
            addBox(-2.2, 0.35, -4.05, 0.02, 0.3, 0.22, new THREE.MeshLambertMaterial({ color: 0xaa3030 }), 'LR_Magazine1');
            addBox(-2.18, 0.33, -4.05, 0.02, 0.3, 0.22, new THREE.MeshLambertMaterial({ color: 0x3060aa }), 'LR_Magazine2');

            // === THROW BLANKET draped on couch armrest ===
            addBox(1.55, 0.7, -4.3, 0.15, 0.35, 0.6, new THREE.MeshLambertMaterial({ color: 0x9a7a6a }), 'LR_ThrowBlanket');

            // === WALL ART on back wall ===
            addBox(-3, 2.2, -8.8, 1.2, 0.8, 0.04, darkWood, 'LR_WallArt_Frame');
            addBox(-3, 2.2, -8.77, 1.1, 0.7, 0.02, new THREE.MeshLambertMaterial({ color: 0x5a7a9a }), 'LR_WallArt_Canvas');

            // === FIREPLACE AREA (on front wall, moved to x=10.5) ===
            const fpX = 10.5, fpZ = 8.7;
            const brick = new THREE.MeshLambertMaterial({ color: 0x8b4513 });
            const stone = new THREE.MeshLambertMaterial({ color: 0x696969 });
            const mantel = new THREE.MeshLambertMaterial({ color: 0xf5f5f0 });
            
            // Fireplace surround/frame (against front wall)
            addBox(fpX, 0.6, fpZ, 1.6, 1.2, 0.3, brick);
            // Opening (dark)
            addBox(fpX, 0.5, fpZ - 0.05, 1.1, 0.8, 0.15, new THREE.MeshLambertMaterial({ color: 0x1a1a1a }));
            // Hearth (floor extension)
            addBox(fpX, 0.08, fpZ - 0.4, 1.8, 0.16, 0.6, stone);
            // Mantel shelf
            addBox(fpX, 1.25, fpZ - 0.1, 1.8, 0.08, 0.25, mantel);
            // Mantel decorations
            const vase1 = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.07, 0.18, 12),
                new THREE.MeshLambertMaterial({ color: 0x4a6a8a }));
            vase1.position.set(fpX - 0.6, 1.38, fpZ - 0.1);
            scene.add(vase1);
            const vase2 = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.06, 0.15, 12),
                new THREE.MeshLambertMaterial({ color: 0x8a6a4a }));
            vase2.position.set(fpX + 0.5, 1.36, fpZ - 0.1);
            scene.add(vase2);
            // Picture frame on mantel
            addBox(fpX, 1.42, fpZ - 0.08, 0.25, 0.2, 0.03, darkWood);
            // Clock above fireplace
            const fpClock = new THREE.Mesh(new THREE.CylinderGeometry(0.25, 0.25, 0.04, 24),
                new THREE.MeshLambertMaterial({ color: 0x2a2a2a }));
            fpClock.rotation.x = Math.PI / 2;
            fpClock.position.set(fpX, 1.8, fpZ - 0.02);
            scene.add(fpClock);
            const fpClockFace = new THREE.Mesh(new THREE.CircleGeometry(0.2, 24),
                new THREE.MeshLambertMaterial({ color: 0xf5f5f0 }));
            fpClockFace.position.set(fpX, 1.8, fpZ - 0.04);
            scene.add(fpClockFace);
            
            // Fire glow (subtle orange point light)
            const fireGlow = new THREE.PointLight(0xff6622, 0.5, 5);
            fireGlow.position.set(fpX, 0.4, fpZ - 0.3);
            scene.add(fireGlow);
            
            // Fake fire logs
            const logMat = new THREE.MeshLambertMaterial({ color: 0x3a2a1a });
            const log1 = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.06, 0.5, 8), logMat);
            log1.rotation.z = Math.PI / 2;
            log1.rotation.x = 0.2;
            log1.position.set(fpX - 0.15, 0.22, fpZ - 0.1);
            scene.add(log1);
            const log2 = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 0.45, 8), logMat);
            log2.rotation.z = Math.PI / 2;
            log2.rotation.x = -0.3;
            log2.position.set(fpX + 0.1, 0.25, fpZ - 0.1);
            scene.add(log2);
            
            // Fireplace screen
            addBox(fpX, 0.5, fpZ - 0.18, 1.05, 0.75, 0.02, new THREE.MeshLambertMaterial({ 
                color: 0x222222, transparent: true, opacity: 0.3 
            }));
            
            // === FIREPLACE AREA RUG ===
            const fpRug = new THREE.Mesh(new THREE.PlaneGeometry(3.5, 2.5),
                new THREE.MeshLambertMaterial({ color: 0x6a3a3a }));
            fpRug.rotation.x = -Math.PI / 2;
            fpRug.position.set(fpX, 0.015, fpZ - 1.8);
            fpRug.name = `FP_Rug_${editorObjectCounter++}`;
            fpRug.userData.editable = true;
            fpRug.userData.type = 'rug';
            scene.add(fpRug);
            editorObjects.push(fpRug);
            
            // === TWO COZY ARMCHAIRS facing fireplace ===
            const cozyFabric = new THREE.MeshLambertMaterial({ color: 0x5a4a3a });
            const cozyCushion = new THREE.MeshLambertMaterial({ color: 0x6a5a4a });
            
            // Chair 1 (left, angled towards fireplace)
            const chair1X = 9.1, chair1Z = 6;
            addBox(chair1X, 0.35, chair1Z, 0.95, 0.45, 0.95, cozyFabric);
            addBox(chair1X, 0.75, chair1Z - 0.35, 0.95, 0.65, 0.15, cozyFabric); // back
            addBox(chair1X - 0.4, 0.55, chair1Z, 0.12, 0.4, 0.95, cozyFabric); // arm
            addBox(chair1X + 0.4, 0.55, chair1Z, 0.12, 0.4, 0.95, cozyFabric); // arm
            addBox(chair1X, 0.62, chair1Z + 0.05, 0.8, 0.12, 0.8, cozyCushion); // seat cushion
            
            // Chair 2 (right, angled towards fireplace)  
            const chair2X = 11.6, chair2Z = 6;
            addBox(chair2X, 0.35, chair2Z, 0.95, 0.45, 0.95, cozyFabric);
            addBox(chair2X, 0.75, chair2Z - 0.35, 0.95, 0.65, 0.15, cozyFabric);
            addBox(chair2X - 0.4, 0.55, chair2Z, 0.12, 0.4, 0.95, cozyFabric);
            addBox(chair2X + 0.4, 0.55, chair2Z, 0.12, 0.4, 0.95, cozyFabric);
            addBox(chair2X, 0.62, chair2Z + 0.05, 0.8, 0.12, 0.8, cozyCushion);
            
            // Small round coffee table between chairs
            const fpTable = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.4, 0.05, 16), lightWood);
            fpTable.position.set(fpX, 0.42, 6);
            scene.add(fpTable);
            const fpTableLeg = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.08, 0.4, 8), darkWood);
            fpTableLeg.position.set(fpX, 0.2, 6);
            scene.add(fpTableLeg);
            // Books and candle on table
            addBox(fpX + 0.1, 0.48, 6, 0.2, 0.06, 0.15, new THREE.MeshLambertMaterial({ color: 0x2f4f4f }));
            const fpCandle = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.04, 0.12, 8),
                new THREE.MeshLambertMaterial({ color: 0xf5f0e0 }));
            fpCandle.position.set(fpX - 0.12, 0.51, 6);
            scene.add(fpCandle);

            // === FLOOR LAMP near fireplace ===
            createFloorLamp(fpX - 2.5, 0, 6.5, 'living');

            // === WALL CLOCK ===
            const clock = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.3, 0.05, 24), new THREE.MeshLambertMaterial({ color: 0xffffff }));
            clock.rotation.x = Math.PI / 2;
            clock.position.set(4, 2.2, -8.8);
            scene.add(clock);

            // === CEILING LIGHT ===
            createCeilingLight(0, HOUSE.height - 0.1, -2, 'living');

            // === LIGHT SWITCH (on bedroom wall, living room side, near bedroom door) ===
            createLightSwitch(-5.8, 1.2, -1.5, 'living', Math.PI/2);
        }

        function createTableLamp(x, y, z, room) {
            const lampGroup = new THREE.Group();
            const baseMat = new THREE.MeshLambertMaterial({ color: 0x4a4a4a });
            const shadeMat = new THREE.MeshLambertMaterial({ color: 0xf5e6d3, side: THREE.DoubleSide });
            
            // Base
            const base = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.1, 0.04, 16), baseMat);
            base.position.y = 0.02;
            lampGroup.add(base);
            
            // Pole
            const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.02, 0.35, 8), baseMat);
            pole.position.y = 0.22;
            lampGroup.add(pole);
            
            // Shade
            const shade = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.18, 0.2, 16), shadeMat);
            shade.position.y = 0.48;
            lampGroup.add(shade);
            
            // Bulb glow
            const bulb = new THREE.Mesh(new THREE.SphereGeometry(0.05, 8, 8), 
                new THREE.MeshBasicMaterial({ color: 0xffffee, transparent: true, opacity: 0.8 }));
            bulb.position.y = 0.42;
            bulb.userData.shade = true;
            lampGroup.add(bulb);
            
            lampGroup.position.set(x, y, z);
            scene.add(lampGroup);
            
            // Light
            const light = new THREE.PointLight(0xfff5e6, 0.6, 8);
            light.position.set(x, y + 0.5, z);
            scene.add(light);
            
            lamps.push({ light, bulb, room, group: lampGroup });
        }

        function createFloorLamp(x, y, z, room) {
            const lampGroup = new THREE.Group();
            const baseMat = new THREE.MeshLambertMaterial({ color: 0x3a3a3a });
            const shadeMat = new THREE.MeshLambertMaterial({ color: 0xf0e0c8, side: THREE.DoubleSide });
            
            // Base
            const base = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.18, 0.04, 16), baseMat);
            base.position.y = 0.02;
            lampGroup.add(base);
            
            // Pole
            const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.025, 0.025, 1.5, 8), baseMat);
            pole.position.y = 0.77;
            lampGroup.add(pole);
            
            // Shade
            const shade = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.25, 0.3, 16), shadeMat);
            shade.position.y = 1.6;
            lampGroup.add(shade);
            
            // Bulb
            const bulb = new THREE.Mesh(new THREE.SphereGeometry(0.08, 8, 8),
                new THREE.MeshBasicMaterial({ color: 0xffffee, transparent: true, opacity: 0.8 }));
            bulb.position.y = 1.5;
            bulb.userData.shade = true;
            lampGroup.add(bulb);
            
            lampGroup.position.set(x, y, z);
            lampGroup.name = `FloorLamp_${room}_${editorObjectCounter++}`;
            lampGroup.userData.editable = true;
            lampGroup.userData.type = 'floorLamp';
            lampGroup.userData.originalPos = { x, y, z };
            scene.add(lampGroup);
            editorObjects.push(lampGroup);
            
            // Light
            const light = new THREE.PointLight(0xfff5e6, 0.8, 10);
            light.position.set(x, y + 1.6, z);
            scene.add(light);
            
            lamps.push({ light, bulb, room, group: lampGroup });
        }

        function createPlant(x, y, z) {
            const plantGroup = new THREE.Group();
            
            const pot = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.12, 0.25, 12),
                new THREE.MeshLambertMaterial({ color: 0x8a6a4a }));
            pot.position.y = 0.125;
            plantGroup.add(pot);
            
            const plant = new THREE.Mesh(new THREE.SphereGeometry(0.25, 8, 8),
                new THREE.MeshLambertMaterial({ color: 0x3a8a3a }));
            plant.position.y = 0.45;
            plantGroup.add(plant);
            
            plantGroup.position.set(x, y, z);
            plantGroup.name = `Plant_${editorObjectCounter++}`;
            plantGroup.userData.editable = true;
            plantGroup.userData.type = 'plant';
            scene.add(plantGroup);
            editorObjects.push(plantGroup);
        }

        function createBedroom() {
            const darkWood = new THREE.MeshLambertMaterial({ color: 0x4a3a2a });
            const lightWood = new THREE.MeshLambertMaterial({ color: 0x8b7355 });
            const bedding = new THREE.MeshLambertMaterial({ color: 0xf0e8e0 });
            const blanket = new THREE.MeshLambertMaterial({ color: 0x5a6a7a });
            const pillow = new THREE.MeshLambertMaterial({ color: 0xffffff });
            const fabric = new THREE.MeshLambertMaterial({ color: 0x6a5a7a });

            // Bed positioned against left wall (wall at x = -16)
            const wallX = -HOUSE.width/2;  // -16
            const bedZ = -2.4;  // Moved to new position
            const bedFrameWidth = 2.2;
            const bedX = -14.9;  // New position

            // === BED ===
            addBox(bedX, 0.2, bedZ, bedFrameWidth, 0.4, 2.6, darkWood); // Frame
            addBox(wallX + 0.1, 0.9, bedZ, 0.15, 1.2, 2.6, darkWood); // Headboard against wall
            addBox(bedX + bedFrameWidth/2 - 0.05, 0.45, bedZ, 0.1, 0.6, 2.6, darkWood); // Footboard
            addBox(bedX, 0.5, bedZ, 2, 0.25, 2.4, bedding); // Mattress
            addBox(bedX + 0.3, 0.68, bedZ, 1.4, 0.1, 2, blanket); // Blanket
            addBox(wallX + 0.5, 0.68, bedZ - 0.6, 0.5, 0.15, 0.7, pillow); // Pillows near headboard
            addBox(wallX + 0.5, 0.68, bedZ + 0.6, 0.5, 0.15, 0.7, pillow);

            // Store bed for interaction
            bed = new THREE.Group();
            bed.position.set(bedX, 0.5, bedZ);
            bed.userData.type = 'bed';
            interactables.push(bed);

            // === NIGHTSTANDS (beside bed, against wall) ===
            const nsX = wallX + 0.35;  // Against wall
            const ns1Z = bedZ + 1.55;  // Left side of bed
            addBox(nsX, 0.3, ns1Z, 0.5, 0.6, 0.45, darkWood);
            addBox(nsX + 0.26, 0.25, ns1Z, 0.15, 0.03, 0.02, new THREE.MeshLambertMaterial({ color: 0x888888 }));
            createTableLamp(nsX, 0.6, ns1Z, 'bedroom');
            addBox(nsX + 0.1, 0.65, ns1Z - 0.1, 0.15, 0.1, 0.08, new THREE.MeshLambertMaterial({ color: 0x1a1a1a }));
            createElectronic(nsX + 0.1, 0.67, ns1Z - 0.05, 'Alarm clock');

            const ns2Z = bedZ - 1.55;  // Right side of bed
            addBox(nsX, 0.3, ns2Z, 0.5, 0.6, 0.45, darkWood);
            addBox(nsX + 0.26, 0.25, ns2Z, 0.15, 0.03, 0.02, new THREE.MeshLambertMaterial({ color: 0x888888 }));
            createElectronic(nsX + 0.1, 0.62, ns2Z, 'Charger LED');
            addBox(nsX - 0.05, 0.65, ns2Z, 0.12, 0.15, 0.02, new THREE.MeshLambertMaterial({ color: 0x4a6a8a }));

            // === DRESSER ===
            const dresserX = -10.6, dresserZ = -8.8;
            addBox(dresserX, 0.5, dresserZ, 1.4, 1, 0.5, darkWood);
            for (let i = 0; i < 3; i++) {
                addBox(dresserX, 0.25 + i * 0.32, dresserZ + 0.26, 0.25, 0.03, 0.02, new THREE.MeshLambertMaterial({ color: 0x888888 }));
            }
            // Mirror above dresser
            addBox(dresserX, 1.8, dresserZ - 0.05, 1, 1.2, 0.05, darkWood);
            const mirror = new THREE.Mesh(new THREE.PlaneGeometry(0.85, 1),
                new THREE.MeshBasicMaterial({ color: 0x8090a0 }));
            mirror.position.set(dresserX, 1.8, dresserZ - 0.01);
            scene.add(mirror);

            // === WARDROBE ===
            addBox(-14.8, 1.2, -8.7, 1.4, 2.4, 0.7, darkWood);
            addBox(-14.8, 1.2, -8.34, 0.02, 2.2, 0.02, new THREE.MeshLambertMaterial({ color: 0x3a2a1a })); // Door line
            // Handles
            addBox(-15.2, 1.2, -8.34, 0.04, 0.15, 0.03, new THREE.MeshLambertMaterial({ color: 0x888888 }));
            addBox(-14.4, 1.2, -8.34, 0.04, 0.15, 0.03, new THREE.MeshLambertMaterial({ color: 0x888888 }));

            // === READING CHAIR + FLOOR LAMP ===
            const chairX = -8.4, chairZ = -8.6;
            addBox(chairX, 0.35, chairZ, 0.9, 0.5, 0.9, fabric);
            addBox(chairX, 0.8, chairZ - 0.4, 0.9, 0.6, 0.15, fabric);
            addBox(chairX - 0.4, 0.5, chairZ, 0.12, 0.35, 0.9, fabric);
            addBox(chairX + 0.4, 0.5, chairZ, 0.12, 0.35, 0.9, fabric);
            // Small side table
            addBox(chairX + 0.8, 0.3, chairZ, 0.4, 0.6, 0.4, lightWood);
            // Floor lamp next to chair
            createFloorLamp(chairX - 1, 0, chairZ, 'bedroom');

            // === DESK AREA (inside bedroom, front section against left wall) ===
            const deskWallX = -HOUSE.width/2;  // -16 (left wall)
            const deskZ = 4;
            // Desk against the left wall
            addBox(deskWallX + 0.35, 0.75, deskZ, 0.6, 0.05, 1.2, lightWood); // Desk top
            addBox(deskWallX + 0.35, 0.375, deskZ - 0.5, 0.55, 0.7, 0.05, lightWood); // Back leg
            addBox(deskWallX + 0.35, 0.375, deskZ + 0.5, 0.55, 0.7, 0.05, lightWood); // Front leg
            // Desk chair (facing desk)
            addBox(deskWallX + 1, 0.4, deskZ, 0.5, 0.08, 0.5, new THREE.MeshLambertMaterial({ color: 0x2a2a2a }));
            addBox(deskWallX + 1.2, 0.75, deskZ, 0.08, 0.6, 0.5, new THREE.MeshLambertMaterial({ color: 0x2a2a2a }));
            // Desk lamp
            createTableLamp(deskWallX + 0.4, 0.78, deskZ - 0.35, 'bedroom');
            // Laptop (closed) with charging LED
            addBox(deskWallX + 0.35, 0.8, deskZ + 0.15, 0.25, 0.02, 0.35, new THREE.MeshLambertMaterial({ color: 0x4a4a4a }));
            createElectronic(deskWallX + 0.2, 0.81, deskZ + 0.3, 'Laptop charging LED');
            // Air purifier near desk
            addBox(deskWallX + 0.3, 0.25, deskZ + 1, 0.25, 0.5, 0.2, new THREE.MeshLambertMaterial({ color: 0xf0f0f0 }), 'BR_AirPurifier');
            createElectronic(deskWallX + 0.35, 0.52, deskZ + 1.08, 'Air purifier LED');
            // Power bank on nightstand
            createElectronic(-15.55, 0.65, -0.7, 'Power bank LED');
            
            // === WALL LAMPS above desk ===
            createWallSconce(deskWallX + 0.15, 2, deskZ - 0.4, 'bedroom', Math.PI/2);
            createWallSconce(deskWallX + 0.15, 2, deskZ + 0.4, 'bedroom', Math.PI/2);

            // === RUG ===
            const rug = new THREE.Mesh(new THREE.PlaneGeometry(3, 2), new THREE.MeshLambertMaterial({ color: 0x7a6a5a }));
            rug.rotation.x = -Math.PI / 2;
            rug.position.set(bedX + 1.8, 0.01, bedZ);
            rug.name = `BR_Rug_${editorObjectCounter++}`;
            rug.userData.editable = true;
            rug.userData.type = 'rug';
            scene.add(rug);
            editorObjects.push(rug);

            // === BENCH AT FOOT OF BED (facing bed, back towards +x) ===
            const benchX = bedX + bedFrameWidth/2 + 0.8;  // In front of footboard
            addBox(benchX, 0.3, bedZ, 0.5, 0.45, 1.8, fabric, 'BR_Bench_Seat');
            addBox(benchX, 0.35, bedZ, 0.45, 0.08, 1.7, new THREE.MeshLambertMaterial({ color: 0x7a6a8a }), 'BR_Bench_Cushion');
            // Bench has no back - it's a simple ottoman-style bench

            // === LAUNDRY BASKET in corner ===
            const basket = new THREE.Mesh(new THREE.CylinderGeometry(0.25, 0.2, 0.5, 12),
                new THREE.MeshLambertMaterial({ color: 0x8a7a6a }));
            basket.position.set(-7.5, 0.25, -7.5);
            basket.name = `BR_LaundryBasket_${editorObjectCounter++}`;
            basket.userData.editable = true;
            basket.userData.type = 'basket';
            scene.add(basket);
            editorObjects.push(basket);

            // === SMALL BOOKCASE against bedroom wall (near door) ===
            // Against bedroom wall (x = -6), facing into bedroom (-x direction)
            const bookcaseX = -6.4, bookcaseZ = -1;
            // Back panel (against wall)
            addBox(bookcaseX + 0.15, 0.7, bookcaseZ, 0.05, 1.4, 0.8, darkWood, 'BR_Bookcase_Back');
            // Left side
            addBox(bookcaseX, 0.7, bookcaseZ - 0.38, 0.35, 1.4, 0.05, darkWood, 'BR_Bookcase_SideL');
            // Right side
            addBox(bookcaseX, 0.7, bookcaseZ + 0.38, 0.35, 1.4, 0.05, darkWood, 'BR_Bookcase_SideR');
            // Shelves
            addBox(bookcaseX, 0.35, bookcaseZ, 0.32, 0.03, 0.75, darkWood, 'BR_Bookcase_Shelf1');
            addBox(bookcaseX, 0.7, bookcaseZ, 0.32, 0.03, 0.75, darkWood, 'BR_Bookcase_Shelf2');
            addBox(bookcaseX, 1.05, bookcaseZ, 0.32, 0.03, 0.75, darkWood, 'BR_Bookcase_Shelf3');
            addBox(bookcaseX, 1.4, bookcaseZ, 0.32, 0.03, 0.75, darkWood, 'BR_Bookcase_Top');
            // Some books (spines facing -x into room)
            addBox(bookcaseX - 0.1, 0.52, bookcaseZ - 0.2, 0.15, 0.3, 0.05, new THREE.MeshLambertMaterial({ color: 0x8b4513 }), 'BR_Book1');
            addBox(bookcaseX - 0.1, 0.52, bookcaseZ - 0.1, 0.15, 0.28, 0.05, new THREE.MeshLambertMaterial({ color: 0x2f4f4f }), 'BR_Book2');
            addBox(bookcaseX - 0.1, 0.52, bookcaseZ + 0.1, 0.15, 0.32, 0.05, new THREE.MeshLambertMaterial({ color: 0x8b0000 }), 'BR_Book3');
            // Small plant on top
            createPlant(bookcaseX - 0.05, 1.4, bookcaseZ);

            // === FULL-LENGTH MIRROR on wall (between wardrobe and corner) ===
            // Against back wall (z = -9), facing +z into room
            addBox(-12.5, 1.2, -8.5, 0.6, 1.8, 0.05, darkWood, 'BR_MirrorFrame');
            const fullMirror = new THREE.Mesh(new THREE.PlaneGeometry(0.5, 1.6),
                new THREE.MeshBasicMaterial({ color: 0x8090a0 }));
            fullMirror.position.set(-12.5, 1.2, -8.47);
            scene.add(fullMirror);

            // === BEDROOM RUG (second one, near reading area) ===
            const rug2 = new THREE.Mesh(new THREE.PlaneGeometry(2, 1.5), new THREE.MeshLambertMaterial({ color: 0x6a5a6a }));
            rug2.rotation.x = -Math.PI / 2;
            rug2.position.set(-8.4, 0.01, -8.6);
            rug2.name = `BR_Rug2_${editorObjectCounter++}`;
            rug2.userData.editable = true;
            rug2.userData.type = 'rug';
            scene.add(rug2);
            editorObjects.push(rug2);

            // === CEILING LIGHT ===
            createCeilingLight(-11, HOUSE.height - 0.1, -2, 'bedroom');

            // === LIGHT SWITCH (on bedroom wall, bedroom side, near door) ===
            createLightSwitch(-6.2, 1.2, -2.2, 'bedroom', -Math.PI/2);
        }

        function createKitchen() {
            const counter = new THREE.MeshLambertMaterial({ color: 0x9099a0 });
            const cabinet = new THREE.MeshLambertMaterial({ color: 0xf5f5f5 });
            const appliance = new THREE.MeshLambertMaterial({ color: 0xdcdcdc });
            const darkWood = new THREE.MeshLambertMaterial({ color: 0x3a2a1a });
            const metal = new THREE.MeshLambertMaterial({ color: 0x888888 });

            // === L-SHAPED COUNTER ===
            addBox(12, 0.45, -8.2, 6, 0.9, 0.7, cabinet);
            addBox(12, 0.93, -8.2, 6.1, 0.06, 0.75, counter);
            addBox(HOUSE.width/2 - 0.4, 0.45, -5, 0.7, 0.9, 4, cabinet);
            addBox(HOUSE.width/2 - 0.4, 0.93, -5, 0.75, 0.06, 4.1, counter);

            // === UPPER CABINETS (depth 0.4, back wall at z=-9) ===
            addBox(11, 2.4, -8.4, 4.5, 0.8, 0.4, cabinet);
            // Cabinet handles
            for (let i = 0; i < 3; i++) {
                addBox(9.5 + i * 1.5, 2.3, -8.19, 0.2, 0.03, 0.03, metal);
            }

            // === STOVE ===
            addBox(10, 0.5, -8.2, 0.9, 1, 0.7, appliance);
            addBox(10, 0.98, -8.2, 0.85, 0.03, 0.65, new THREE.MeshLambertMaterial({ color: 0x222222 }));
            for (let bx = 0; bx < 2; bx++) {
                for (let bz = 0; bz < 2; bz++) {
                    const burner = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.12, 0.02, 16),
                        new THREE.MeshLambertMaterial({ color: 0x333333 }));
                    burner.position.set(9.8 + bx * 0.35, 1.01, -8.35 + bz * 0.3);
                    scene.add(burner);
                }
            }
            // Oven door handle
            addBox(10, 0.5, -7.84, 0.5, 0.03, 0.03, metal);

            // === RANGE HOOD ===
            addBox(10, 2.6, -8.3, 0.9, 0.4, 0.5, appliance);

            // === SINK ===
            addBox(12.5, 0.88, -8.2, 0.7, 0.15, 0.5, new THREE.MeshLambertMaterial({ color: 0x666666 }));
            const faucet = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.025, 0.3, 8), metal);
            faucet.position.set(12.5, 1.1, -8.5);
            scene.add(faucet);
            const faucetSpout = new THREE.Mesh(new THREE.CylinderGeometry(0.015, 0.015, 0.15, 8), metal);
            faucetSpout.rotation.x = Math.PI / 2;
            faucetSpout.position.set(12.5, 1.2, -8.35);
            scene.add(faucetSpout);

            // === REFRIGERATOR ===
            addBox(HOUSE.width/2 - 0.5, 1.1, -7.8, 1, 2.2, 0.9, appliance);
            addBox(HOUSE.width/2 - 1, 1.6, -7.34, 0.03, 0.4, 0.04, metal);
            addBox(HOUSE.width/2 - 1, 0.5, -7.34, 0.03, 0.3, 0.04, metal);
            // Fridge light indicator
            createElectronic(HOUSE.width/2 - 0.9, 1.9, -7.34, 'Fridge LED');

            // === MICROWAVE ===
            addBox(13.5, 1.15, -8.05, 0.55, 0.35, 0.4, appliance);
            addBox(13.5, 1.15, -7.84, 0.4, 0.28, 0.02, new THREE.MeshBasicMaterial({ color: 0x111111 }));
            createElectronic(13.72, 1.2, -7.84, 'Microwave clock');

            // === COFFEE MAKER ===
            addBox(HOUSE.width/2 - 0.45, 1.15, -3, 0.25, 0.4, 0.3, new THREE.MeshLambertMaterial({ color: 0x222222 }));
            createElectronic(HOUSE.width/2 - 0.55, 1.0, -2.85, 'Coffee maker');

            // === TOASTER ===
            addBox(14.5, 1.0, -8.05, 0.25, 0.2, 0.15, new THREE.MeshLambertMaterial({ color: 0xcccccc }));
            
            // Oven/stove clock display
            createElectronic(10.3, 1.5, -7.85, 'Oven clock');
            // Dishwasher indicator (under counter)
            createElectronic(11, 0.6, -7.85, 'Dishwasher LED');
            // Range hood light
            createElectronic(10, 2.35, -8.05, 'Range hood LED');

            // === BAR STOOLS at side counter (facing counter, backs towards -x) ===
            // Counter is at x = 15.6, stools positioned at x = 14.8
            const stoolX = 14.8;
            const stoolMat = new THREE.MeshLambertMaterial({ color: 0x4a4a4a });
            const stoolSeatMat = new THREE.MeshLambertMaterial({ color: 0x6a5a4a });
            
            // Stool 1
            addBox(stoolX, 0.35, -3, 0.35, 0.7, 0.35, stoolMat, 'KT_Stool1_Legs');
            addBox(stoolX, 0.73, -3, 0.4, 0.06, 0.4, stoolSeatMat, 'KT_Stool1_Seat');
            // Small backrest (facing +x towards counter)
            addBox(stoolX - 0.17, 0.9, -3, 0.04, 0.3, 0.35, stoolMat, 'KT_Stool1_Back');
            
            // Stool 2
            addBox(stoolX, 0.35, -4.2, 0.35, 0.7, 0.35, stoolMat, 'KT_Stool2_Legs');
            addBox(stoolX, 0.73, -4.2, 0.4, 0.06, 0.4, stoolSeatMat, 'KT_Stool2_Seat');
            addBox(stoolX - 0.17, 0.9, -4.2, 0.04, 0.3, 0.35, stoolMat, 'KT_Stool2_Back');

            // === KITCHEN ISLAND/PREP TABLE ===
            const islandX = 11.5, islandZ = -5;
            addBox(islandX, 0.45, islandZ, 1.2, 0.9, 0.7, cabinet, 'KT_Island_Base');
            addBox(islandX, 0.93, islandZ, 1.3, 0.06, 0.8, counter, 'KT_Island_Top');
            // Cutting board on island
            addBox(islandX - 0.2, 0.98, islandZ, 0.35, 0.02, 0.25, new THREE.MeshLambertMaterial({ color: 0x8b7355 }), 'KT_CuttingBoard');
            // Knife block
            addBox(islandX + 0.4, 1.1, islandZ + 0.2, 0.15, 0.3, 0.1, new THREE.MeshLambertMaterial({ color: 0x3a2a1a }), 'KT_KnifeBlock');

            // === TRASH BIN ===
            const trashBin = new THREE.Mesh(new THREE.CylinderGeometry(0.18, 0.15, 0.5, 12),
                new THREE.MeshLambertMaterial({ color: 0x4a4a4a }));
            trashBin.position.set(9, 0.25, -7.5);
            trashBin.name = `KT_TrashBin_${editorObjectCounter++}`;
            trashBin.userData.editable = true;
            trashBin.userData.type = 'furniture';
            scene.add(trashBin);
            editorObjects.push(trashBin);

            // === PAPER TOWEL HOLDER on counter ===
            const towelHolder = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.08, 0.35, 12),
                new THREE.MeshLambertMaterial({ color: 0xf5f5f5 }));
            towelHolder.position.set(14, 1.15, -8);
            scene.add(towelHolder);
            const towelRoll = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.06, 0.25, 12),
                new THREE.MeshLambertMaterial({ color: 0xeeeeee }));
            towelRoll.position.set(14, 1.25, -8);
            scene.add(towelRoll);

            // === SPICE RACK on counter near stove ===
            addBox(10.7, 1.05, -8.1, 0.3, 0.2, 0.12, new THREE.MeshLambertMaterial({ color: 0x5a4a3a }), 'KT_SpiceRack');

            // === LARGE DINING TABLE (in open area connecting to living room) ===
            const tableX = 11.1, tableZ = 1.2;
            const tableW = 2.4, tableD = 1.2;
            // Table top
            addBox(tableX, 0.76, tableZ, tableW, 0.06, tableD, darkWood);
            // Table legs
            addBox(tableX - tableW/2 + 0.1, 0.38, tableZ - tableD/2 + 0.1, 0.08, 0.7, 0.08, darkWood);
            addBox(tableX + tableW/2 - 0.1, 0.38, tableZ - tableD/2 + 0.1, 0.08, 0.7, 0.08, darkWood);
            addBox(tableX - tableW/2 + 0.1, 0.38, tableZ + tableD/2 - 0.1, 0.08, 0.7, 0.08, darkWood);
            addBox(tableX + tableW/2 - 0.1, 0.38, tableZ + tableD/2 - 0.1, 0.08, 0.7, 0.08, darkWood);
            
            // 6 Chairs - 2 on each long side, 1 on each short side
            const chairMat = new THREE.MeshLambertMaterial({ color: 0x5a4a3a });
            const chairFabric = new THREE.MeshLambertMaterial({ color: 0x8a7a6a });
            
            // Left side chairs (2)
            for (let i = -1; i <= 1; i += 2) {
                const cz = tableZ + i * 0.4;
                addBox(tableX - tableW/2 - 0.5, 0.45, cz, 0.45, 0.05, 0.45, chairMat);
                addBox(tableX - tableW/2 - 0.5, 0.5, cz, 0.4, 0.06, 0.4, chairFabric); // cushion
                addBox(tableX - tableW/2 - 0.7, 0.8, cz, 0.05, 0.65, 0.45, chairMat);
                // legs
                addBox(tableX - tableW/2 - 0.7, 0.21, cz - 0.18, 0.04, 0.42, 0.04, chairMat);
                addBox(tableX - tableW/2 - 0.3, 0.21, cz - 0.18, 0.04, 0.42, 0.04, chairMat);
                addBox(tableX - tableW/2 - 0.7, 0.21, cz + 0.18, 0.04, 0.42, 0.04, chairMat);
                addBox(tableX - tableW/2 - 0.3, 0.21, cz + 0.18, 0.04, 0.42, 0.04, chairMat);
            }
            
            // Right side chairs (2)
            for (let i = -1; i <= 1; i += 2) {
                const cz = tableZ + i * 0.4;
                addBox(tableX + tableW/2 + 0.5, 0.45, cz, 0.45, 0.05, 0.45, chairMat);
                addBox(tableX + tableW/2 + 0.5, 0.5, cz, 0.4, 0.06, 0.4, chairFabric);
                addBox(tableX + tableW/2 + 0.7, 0.8, cz, 0.05, 0.65, 0.45, chairMat);
                // legs
                addBox(tableX + tableW/2 + 0.3, 0.21, cz - 0.18, 0.04, 0.42, 0.04, chairMat);
                addBox(tableX + tableW/2 + 0.7, 0.21, cz - 0.18, 0.04, 0.42, 0.04, chairMat);
                addBox(tableX + tableW/2 + 0.3, 0.21, cz + 0.18, 0.04, 0.42, 0.04, chairMat);
                addBox(tableX + tableW/2 + 0.7, 0.21, cz + 0.18, 0.04, 0.42, 0.04, chairMat);
            }
            
            // End chairs (head and foot of table)
            // Back end
            addBox(tableX, 0.45, tableZ - tableD/2 - 0.5, 0.45, 0.05, 0.45, chairMat);
            addBox(tableX, 0.5, tableZ - tableD/2 - 0.5, 0.4, 0.06, 0.4, chairFabric);
            addBox(tableX, 0.8, tableZ - tableD/2 - 0.7, 0.45, 0.65, 0.05, chairMat);
            // Front end
            addBox(tableX, 0.45, tableZ + tableD/2 + 0.5, 0.45, 0.05, 0.45, chairMat);
            addBox(tableX, 0.5, tableZ + tableD/2 + 0.5, 0.4, 0.06, 0.4, chairFabric);
            addBox(tableX, 0.8, tableZ + tableD/2 + 0.7, 0.45, 0.65, 0.05, chairMat);
            
            // Centerpiece - candles and flowers
            const vase = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.1, 0.2, 12),
                new THREE.MeshLambertMaterial({ color: 0xf5f5f0 }));
            vase.position.set(tableX, 0.89, tableZ);
            scene.add(vase);
            // Flowers
            const flowers = new THREE.Mesh(new THREE.SphereGeometry(0.12, 8, 8),
                new THREE.MeshLambertMaterial({ color: 0xaa5577 }));
            flowers.position.set(tableX, 1.08, tableZ);
            scene.add(flowers);
            // Candle holders
            for (let cx of [-0.4, 0.4]) {
                const candle = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.03, 0.15, 8),
                    new THREE.MeshLambertMaterial({ color: 0xf5f0e0 }));
                candle.position.set(tableX + cx, 0.86, tableZ);
                scene.add(candle);
            }
            
            // Table runner
            addBox(tableX, 0.77, tableZ, 0.4, 0.01, tableD - 0.1, new THREE.MeshLambertMaterial({ color: 0x6a5a4a }));
            
            // Place settings (plates)
            const plateMat = new THREE.MeshLambertMaterial({ color: 0xffffff });
            for (let px of [-0.7, 0.7]) {
                for (let pz of [-0.35, 0.35]) {
                    const plate = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.12, 0.015, 16), plateMat);
                    plate.position.set(tableX + px, 0.785, tableZ + pz);
                    scene.add(plate);
                }
            }

            // === PENDANT LIGHT over dining table ===
            createPendantLight(tableX, HOUSE.height - 0.3, tableZ, 'kitchen');

            // === FRUIT BOWL ===
            const bowl = new THREE.Mesh(new THREE.SphereGeometry(0.12, 16, 8, 0, Math.PI * 2, 0, Math.PI / 2),
                new THREE.MeshLambertMaterial({ color: 0xf5f5dc, side: THREE.DoubleSide }));
            bowl.position.set(HOUSE.width/2 - 0.45, 0.98, -5);
            scene.add(bowl);

            // === TALL FLOOR LAMPS in kitchen corners ===
            createFloorLamp(8.8, 0, -4, 'kitchen');  // Near kitchen wall entrance
            createFloorLamp(15, 0, -5.5, 'kitchen'); // Near right wall
            createFloorLamp(14.9, 0, 7.2, 'kitchen');   // Front corner near dining area
            
            // === PLANT REMOVED ===

            // === CEILING LIGHT ===
            createCeilingLight(12, HOUSE.height - 0.1, -5, 'kitchen');

            // === LIGHT SWITCH (on kitchen wall, kitchen side) ===
            createLightSwitch(8.2, 1.2, -5, 'kitchen', Math.PI/2);
        }

        function createPendantLight(x, y, z, room) {
            const fixture = new THREE.Group();
            
            // Cord
            const cord = new THREE.Mesh(new THREE.CylinderGeometry(0.01, 0.01, 0.5, 8),
                new THREE.MeshLambertMaterial({ color: 0x222222 }));
            cord.position.y = 0.25;
            fixture.add(cord);
            
            // Shade
            const shade = new THREE.Mesh(new THREE.ConeGeometry(0.25, 0.2, 16, 1, true),
                new THREE.MeshLambertMaterial({ color: 0x2a2a2a, side: THREE.DoubleSide }));
            shade.position.y = -0.05;
            fixture.add(shade);
            
            // Bulb
            const bulb = new THREE.Mesh(new THREE.SphereGeometry(0.08, 8, 8),
                new THREE.MeshBasicMaterial({ color: 0xffffee, transparent: true, opacity: 0.9 }));
            bulb.position.y = -0.05;
            bulb.userData.shade = true;
            fixture.add(bulb);
            
            fixture.position.set(x, y, z);
            scene.add(fixture);
            
            const light = new THREE.PointLight(0xfff5e6, 0.8, 8);
            light.position.set(x, y - 0.2, z);
            scene.add(light);
            
            lamps.push({ light, bulb, room, group: fixture });
        }

        function createHallway() {
            const darkWood = new THREE.MeshLambertMaterial({ color: 0x4a3a2a });
            const lightWood = new THREE.MeshLambertMaterial({ color: 0x8b7355 });
            const fabric = new THREE.MeshLambertMaterial({ color: 0x6a6a7a });

            // === CONSOLE TABLE (moved to front wall) ===
            addBox(-13.8, 0.4, 8.8, 1.2, 0.8, 0.35, darkWood);
            addBox(-13.8, 0.35, 8.8, 0.05, 0.7, 0.3, darkWood); // Left leg
            addBox(-13.8, 0.35, 8.8, 0.05, 0.7, 0.3, darkWood); // Right leg
            
            // Keys bowl
            const bowl = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.1, 0.06, 16),
                new THREE.MeshLambertMaterial({ color: 0x6a5a4a }));
            bowl.position.set(-14.1, 0.84, 8.8);
            scene.add(bowl);
            
            // Mail/letters
            addBox(-13.5, 0.84, 8.8, 0.2, 0.02, 0.12, new THREE.MeshLambertMaterial({ color: 0xf5f5f0 }));

            // === COAT RACK ===
            const rackX = -15.7, rackZ = 3;
            addBox(rackX, 1, rackZ, 0.08, 2, 0.08, darkWood);
            addBox(rackX, 0.1, rackZ, 0.25, 0.08, 0.25, darkWood); // Base
            // Hooks
            for (let i = 0; i < 4; i++) {
                const hookAngle = (i / 4) * Math.PI * 2;
                const hook = new THREE.Mesh(new THREE.CylinderGeometry(0.015, 0.015, 0.12, 8),
                    new THREE.MeshLambertMaterial({ color: 0x888888 }));
                hook.rotation.z = Math.PI / 2;
                hook.position.set(rackX + Math.cos(hookAngle) * 0.15, 1.8, rackZ + Math.sin(hookAngle) * 0.15);
                scene.add(hook);
            }

            // === SHOE RACK (moved to bedroom entrance) ===
            addBox(-6.8, 0.2, 0.7, 1, 0.4, 0.35, lightWood);
            // Shoes (simplified)
            addBox(-7.1, 0.08, 0.7, 0.2, 0.1, 0.08, new THREE.MeshLambertMaterial({ color: 0x2a2a2a }));
            addBox(-6.9, 0.08, 0.7, 0.2, 0.1, 0.08, new THREE.MeshLambertMaterial({ color: 0x2a2a2a }));
            addBox(-6.6, 0.08, 0.7, 0.2, 0.12, 0.1, new THREE.MeshLambertMaterial({ color: 0x5a4a3a }));

            // === BENCH REMOVED ===

            // === UMBRELLA STAND ===
            const umbrellaGroup = new THREE.Group();
            const umbrellaStand = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.1, 0.4, 12),
                new THREE.MeshLambertMaterial({ color: 0x4a4a4a }));
            umbrellaStand.position.y = 0.2;
            umbrellaGroup.add(umbrellaStand);
            // Umbrella
            const umbrella = new THREE.Mesh(new THREE.CylinderGeometry(0.015, 0.015, 0.8, 8),
                new THREE.MeshLambertMaterial({ color: 0x1a1a3a }));
            umbrella.position.y = 0.5;
            umbrellaGroup.add(umbrella);
            umbrellaGroup.position.set(-15, 0, 6);
            umbrellaGroup.name = `HW_UmbrellaStand_${editorObjectCounter++}`;
            umbrellaGroup.userData.editable = true;
            umbrellaGroup.userData.type = 'furniture';
            scene.add(umbrellaGroup);
            editorObjects.push(umbrellaGroup);

            // === PLANT ===
            createPlant(-15.4, 0, 5.5);

            // === MIRROR on wall (front wall at z=9) ===
            addBox(-8, 1.6, 8.8, 0.8, 1.2, 0.04, darkWood);
            const mirror = new THREE.Mesh(new THREE.PlaneGeometry(0.7, 1),
                new THREE.MeshBasicMaterial({ color: 0x8090a0 }));
            mirror.position.set(-8, 1.6, 8.77);
            scene.add(mirror);

            // === WALL HOOKS (on left wall, x=-16) ===
            // Hooks facing +x (into room)
            for (let i = 0; i < 4; i++) {
                const hookPlate = new THREE.Mesh(new THREE.BoxGeometry(0.03, 0.08, 0.08),
                    new THREE.MeshLambertMaterial({ color: 0x888888 }));
                hookPlate.position.set(-15.85, 1.5, 4.5 + i * 0.4);
                scene.add(hookPlate);
                const hook = new THREE.Mesh(new THREE.CylinderGeometry(0.012, 0.012, 0.08, 8),
                    new THREE.MeshLambertMaterial({ color: 0x888888 }));
                hook.rotation.z = Math.PI / 2;
                hook.position.set(-15.8, 1.45, 4.5 + i * 0.4);
                scene.add(hook);
            }
            // Coat removed

            // === STORAGE BENCH REMOVED ===

            // === SMALL TABLE near door for keys ===
            addBox(-5.3, 0.4, 5.2, 0.5, 0.8, 0.35, lightWood, 'HW_KeyTable');
            // Small tray for keys
            addBox(-5.3, 0.82, 5.2, 0.25, 0.03, 0.18, new THREE.MeshLambertMaterial({ color: 0x6a5a4a }), 'HW_KeyTray');

            // === ENTRANCE PLANT REMOVED ===

            // === WALL SCONCE (hallway light) ===
            createWallSconce(-4, 2.2, 8.7, 'hallway', Math.PI);
            createWallSconce(4, 2.2, 8.7, 'hallway', Math.PI);

            // === CEILING LIGHT ===
            createCeilingLight(0, HOUSE.height - 0.1, 4, 'hallway');
            
            // Hallway smoke detector
            createElectronic(0, HOUSE.height - 0.1, 6, 'Hallway smoke detector');

            // === LIGHT SWITCH (on front wall, near entrance) ===
            createLightSwitch(3, 1.2, 8.95, 'hallway', Math.PI);

            // === DOORMAT ===
            const mat = new THREE.Mesh(new THREE.PlaneGeometry(1, 0.6),
                new THREE.MeshLambertMaterial({ color: 0x4a3a2a }));
            mat.rotation.x = -Math.PI / 2;
            mat.position.set(0, 0.02, 8.5);
            mat.name = `HW_Doormat_${editorObjectCounter++}`;
            mat.userData.editable = true;
            mat.userData.type = 'rug';
            scene.add(mat);
            editorObjects.push(mat);
        }

        function createWallSconce(x, y, z, room, rotY = 0) {
            const sconce = new THREE.Group();
            
            // Backplate
            const plate = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.15, 0.03),
                new THREE.MeshLambertMaterial({ color: 0x888888 }));
            sconce.add(plate);
            
            // Arm
            const arm = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.04, 0.12),
                new THREE.MeshLambertMaterial({ color: 0x888888 }));
            arm.position.set(0, -0.05, 0.08);
            sconce.add(arm);
            
            // Shade
            const shade = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.08, 0.12, 12),
                new THREE.MeshLambertMaterial({ color: 0xf5e6d3, side: THREE.DoubleSide }));
            shade.position.set(0, 0, 0.15);
            sconce.add(shade);
            
            // Bulb
            const bulb = new THREE.Mesh(new THREE.SphereGeometry(0.03, 8, 8),
                new THREE.MeshBasicMaterial({ color: 0xffffee, transparent: true, opacity: 0.8 }));
            bulb.position.set(0, 0, 0.15);
            bulb.userData.shade = true;
            sconce.add(bulb);
            
            sconce.position.set(x, y, z);
            sconce.rotation.y = rotY;
            scene.add(sconce);
            
            // Light position adjusted for rotation
            const lightOffsetZ = Math.cos(rotY) * -0.1;
            const lightOffsetX = Math.sin(rotY) * -0.1;
            const light = new THREE.PointLight(0xfff5e6, 0.5, 6);
            light.position.set(x + lightOffsetX, y, z + lightOffsetZ);
            scene.add(light);
            
            lamps.push({ light, bulb, room, group: sconce });
        }

        let editorObjectCounter = 0;
        
        function addBox(x, y, z, w, h, d, mat, name) {
            const box = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), mat);
            box.position.set(x, y, z);
            box.name = name || `Box_${editorObjectCounter++}`;
            box.userData.editable = true;
            box.userData.originalPos = { x, y, z };
            box.userData.dimensions = { w, h, d };
            scene.add(box);
            editorObjects.push(box);
            return box;
        }

        function createCeilingLight(x, y, z, room) {
            const fixture = new THREE.Group();
            
            const base = new THREE.Mesh(
                new THREE.CylinderGeometry(0.18, 0.18, 0.06, 16),
                new THREE.MeshLambertMaterial({ color: 0x888888 })
            );
            fixture.add(base);
            
            const shade = new THREE.Mesh(
                new THREE.SphereGeometry(0.3, 16, 16),
                new THREE.MeshBasicMaterial({ color: 0xffffee, transparent: true, opacity: 0.9 })
            );
            shade.position.y = -0.25;
            shade.userData.shade = true;
            fixture.add(shade);
            
            fixture.position.set(x, y, z);
            scene.add(fixture);
            
            const light = new THREE.PointLight(0xfff5e6, 1, 18);
            light.position.set(x, y - 0.35, z);
            scene.add(light);
            
            lights.push({ light, shade, room, fixture });
            State.lightsOn.push(room);
            State.totalLights++;
        }

        function createLightSwitch(x, y, z, room, rotY) {
            const switchGroup = new THREE.Group();
            
            const plate = new THREE.Mesh(
                new THREE.BoxGeometry(0.08, 0.12, 0.02),
                new THREE.MeshLambertMaterial({ color: 0xf5f5f0 })
            );
            switchGroup.add(plate);
            
            const toggle = new THREE.Mesh(
                new THREE.BoxGeometry(0.04, 0.05, 0.025),
                new THREE.MeshLambertMaterial({ color: 0xffffff })
            );
            toggle.position.y = 0.02;
            toggle.position.z = 0.01;
            toggle.userData.isToggle = true;
            switchGroup.add(toggle);
            
            // Glow indicator (small phosphorescent dot)
            const glowDot = new THREE.Mesh(
                new THREE.SphereGeometry(0.008, 8, 8),
                new THREE.MeshBasicMaterial({ color: 0x88ffaa, transparent: true, opacity: 0.9 })
            );
            glowDot.position.set(0, -0.04, 0.015);
            switchGroup.add(glowDot);
            
            // Subtle glow light
            const glowLight = new THREE.PointLight(0x88ffaa, 0.15, 1.5);
            glowLight.position.set(0, 0, 0.05);
            switchGroup.add(glowLight);
            
            // Store reference for animation
            switchGroup.userData.glowDot = glowDot;
            switchGroup.userData.glowLight = glowLight;
            
            switchGroup.position.set(x, y, z);
            switchGroup.rotation.y = rotY;
            switchGroup.userData.room = room;
            switchGroup.userData.type = 'switch';
            scene.add(switchGroup);
            
            lightSwitches.push(switchGroup);
            interactables.push(switchGroup);
        }

        function createElectronic(x, y, z, name) {
            const led = new THREE.Mesh(
                new THREE.SphereGeometry(0.025, 8, 8),
                new THREE.MeshBasicMaterial({ color: 0xff0000 })
            );
            led.position.set(x, y, z);
            led.visible = false;
            
            const glow = new THREE.PointLight(0xff0000, 0, 2);
            glow.position.copy(led.position);
            scene.add(glow);
            
            const outline = new THREE.Mesh(
                new THREE.SphereGeometry(0.06, 8, 8),
                new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0, wireframe: true })
            );
            outline.position.copy(led.position);
            scene.add(outline);
            
            led.userData = { glow, outline, name };
            scene.add(led);
            electronics.push(led);
        }
        
        function createCreepyEyes() {
            creepyEyes = new THREE.Group();
            
            // Door is at x = -6, z = -3 (doorZ)
            const eyeY = 1.5;  // Eye level
            const eyeX = -6.3;  // Just inside doorway
            const eyeZ = -3;   // At door position
            const eyeSpacing = 0.15;  // Distance between eyes
            
            // Left eye
            const leftEye = new THREE.Mesh(
                new THREE.SphereGeometry(0.05, 16, 16),
                new THREE.MeshBasicMaterial({ color: 0xff0000 })
            );
            leftEye.position.set(0, 0, -eyeSpacing/2);
            creepyEyes.add(leftEye);
            
            // Right eye
            const rightEye = new THREE.Mesh(
                new THREE.SphereGeometry(0.05, 16, 16),
                new THREE.MeshBasicMaterial({ color: 0xff0000 })
            );
            rightEye.position.set(0, 0, eyeSpacing/2);
            creepyEyes.add(rightEye);
            
            // Glowing effect for left eye
            const leftGlow = new THREE.PointLight(0xff0000, 0.5, 3);
            leftGlow.position.set(0, 0, -eyeSpacing/2);
            creepyEyes.add(leftGlow);
            
            // Glowing effect for right eye
            const rightGlow = new THREE.PointLight(0xff0000, 0.5, 3);
            rightGlow.position.set(0, 0, eyeSpacing/2);
            creepyEyes.add(rightGlow);
            
            creepyEyes.position.set(eyeX, eyeY, eyeZ);
            creepyEyes.visible = false;  // Hidden initially
            creepyEyes.userData = { leftEye, rightEye, leftGlow, rightGlow };
            scene.add(creepyEyes);
        }

        function toggleLight(room) {
            const idx = State.lightsOn.indexOf(room);
            const lightData = lights.find(l => l.room === room);
            const switchData = lightSwitches.find(s => s.userData.room === room);
            const roomLamps = lamps.filter(l => l.room === room);
            
            if (idx >= 0) {
                // Turn OFF
                State.lightsOn.splice(idx, 1);
                if (lightData) {
                    lightData.light.intensity = 0;
                    lightData.shade.material.opacity = 0.3;
                }
                // Turn off room lamps
                roomLamps.forEach(lamp => {
                    lamp.light.intensity = 0;
                    if (lamp.bulb) lamp.bulb.material.opacity = 0.2;
                });
                if (switchData) {
                    const toggle = switchData.children.find(c => c.userData.isToggle);
                    if (toggle) toggle.position.y = -0.02;
                }
            } else {
                // Turn ON
                State.lightsOn.push(room);
                if (lightData) {
                    lightData.light.intensity = 1;
                    lightData.shade.material.opacity = 0.9;
                }
                // Turn on room lamps
                roomLamps.forEach(lamp => {
                    lamp.light.intensity = lamp.light.userData?.originalIntensity || 0.6;
                    if (lamp.bulb) lamp.bulb.material.opacity = 0.8;
                });
                if (switchData) {
                    const toggle = switchData.children.find(c => c.userData.isToggle);
                    if (toggle) toggle.position.y = 0.02;
                }
            }
            
            updateLightsUI();
            checkPhaseProgress();
            
            // Update lights counter in checklist (count lights OFF, not on)
            const lightsCounter = document.getElementById('lights-counter');
            if (lightsCounter) {
                lightsCounter.textContent = 4 - State.lightsOn.length;
            }
            
            // Give flashlight after turning off 3 lights
            if ((State.phase === 'turnOffLights' || State.phase === 'turnOffLights2') && State.lightsOn.length === 1) {
                if (flashlight && !flashlight.visible) {
                    flashlight.visible = true;
                }
            }
        }

        function updateLightsUI() {
            const el = document.getElementById('lights-remaining');
            if (State.phase === 'turnOffLights' || State.phase === 'turnOffLights2') {
                el.textContent = `Lights on: ${State.lightsOn.length}`;
                el.style.display = 'block';
            } else if (State.phase === 'turnOnLights') {
                el.textContent = `Turn on lights!`;
                el.style.display = 'block';
            } else {
                el.style.display = 'none';
            }
        }

        function updateElectronicsVisibility() {
            const allLightsOff = State.lightsOn.length === 0;
            
            electronics.forEach(led => {
                // Only show LEDs if they've been activated (after waking up)
                if (!State.ledsActive) {
                    led.visible = false;
                    led.userData.glow.intensity = 0;
                    led.userData.outline.material.opacity = 0;
                } else if (allLightsOff) {
                    led.visible = true;
                    led.userData.glow.intensity = 0.3;
                    if (State.showElectronicsOutline) {
                        led.userData.outline.material.opacity = 0.4;
                    }
                } else {
                    led.visible = State.electronicsRevealed;
                    led.userData.glow.intensity = State.electronicsRevealed ? 0.1 : 0;
                    if (State.showElectronicsOutline) {
                        led.userData.outline.material.opacity = 0.2;
                    }
                }
            });
            
            // Show switch outlines when in scared/turnOnLights phase
            updateSwitchOutlines();
        }
        
        function updateSwitchOutlines() {
            lightSwitches.forEach(sw => {
                if (State.showSwitchOutline) {
                    // Create outline if it doesn't exist
                    if (!sw.userData.outline) {
                        const outline = new THREE.Mesh(
                            new THREE.BoxGeometry(0.18, 0.28, 0.1),
                            new THREE.MeshBasicMaterial({ 
                                color: 0x00ffff, 
                                transparent: true, 
                                opacity: 0.6,
                                wireframe: true
                            })
                        );
                        outline.position.copy(sw.position);
                        outline.rotation.copy(sw.rotation);
                        scene.add(outline);
                        sw.userData.outline = outline;
                    }
                    sw.userData.outline.visible = true;
                } else if (sw.userData.outline) {
                    sw.userData.outline.visible = false;
                }
            });
        }

        function checkPhaseProgress() {
            if (State.phase === 'turnOffLights' && State.lightsOn.length === 0) {
                // Check off lights task
                const task = document.getElementById('task-house-lights');
                task.classList.add('completed');
                task.querySelector('.checkbox').textContent = '‚úì';
                
                setTimeout(() => {
                    showPrompt('Time for bed...');
                    State.phase = 'goToBed1';
                    updateElectronicsVisibility();
                }, 500);
            } else if (State.phase === 'turnOnLights' && State.lightsOn.includes('living')) {
                setTimeout(() => {
                    State.phase = 'revealed';
                    State.electronicsRevealed = true;
                    
                    // Hide creepy eyes - they were just electronics!
                    if (creepyEyes) {
                        creepyEyes.visible = false;
                    }
                    
                    // Turn off flashlight - room is lit now
                    if (flashlight) {
                        flashlight.visible = false;
                    }
                    
                    hidePrompt();
                    showPrompt('Just electronics...');
                    updateElectronicsVisibility();
                    
                    setTimeout(() => {
                        hidePrompt();
                        showPrompt('Turn the lights back off...');
                        // Give flashlight back for turnOffLights2
                        if (flashlight) {
                            flashlight.visible = true;
                        }
                        State.phase = 'turnOffLights2';
                        updateLightsUI();
                    }, 2500);
                }, 500);
            } else if (State.phase === 'turnOffLights2' && State.lightsOn.length === 0) {
                setTimeout(() => {
                    // Give flashlight back for the walk to bed
                    if (flashlight) {
                        flashlight.visible = true;
                    }
                    showPrompt('Back to bed...');
                    State.phase = 'goToBed2';
                    updateElectronicsVisibility();
                }, 500);
            }
            
            updateElectronicsVisibility();
        }

        function startIntro() {
            showPrompt('Time to sleep...');
            // Show house checklist
            document.getElementById('house-checklist').classList.add('visible');

            // Start static ambient sound for household
            initAudio();
            playNoise('highpass', 3000, 0.015);
            const staticAudio = document.getElementById('audio-static');
            if (staticAudio) {
                staticAudio.volume = 0.3;
                staticAudio.play().catch(e => console.log('Static audio play failed:', e));
            }
            setTimeout(() => {
                hidePrompt();
                setTimeout(() => {
                    State.phase = 'turnOffLights';
                    updateLightsUI();
                    updateSwitchESP();
                }, 500);
            }, 2500);
        }
        
        // Switch ESP lines
        let switchESPLines = [];
        
        function updateSwitchESP() {
            // Remove old lines
            switchESPLines.forEach(obj => scene.remove(obj));
            switchESPLines = [];
            
            const switchPositions = {
                'living': new THREE.Vector3(-5.8, 1.2, -1.5),
                'bedroom': new THREE.Vector3(-6.2, 1.2, -2.2),
                'kitchen': new THREE.Vector3(8.2, 1.2, -5),
                'hallway': new THREE.Vector3(3, 1.2, 8.95)
            };
            
            const bedPosition = new THREE.Vector3(-14.5, 0.9, -2.4);
            
            let targets = [];
            
            // Determine what to show based on phase
            if (State.phase === 'turnOffLights' || State.phase === 'turnOffLights2') {
                // Show lines to all lights that are still on
                for (const room of State.lightsOn) {
                    if (switchPositions[room]) {
                        targets.push(switchPositions[room]);
                    }
                }
            } else if (State.phase === 'goToBed1' || State.phase === 'goToBed2') {
                // Show line to bed
                targets.push(bedPosition);
            } else if (State.phase === 'turnOnLights') {
                // Show line to living room switch only
                targets.push(switchPositions['living']);
            }
            
            if (targets.length === 0) return;
            
            for (const targetPos of targets) {
                const startPos = camera.position.clone();
                startPos.y -= 0.3;
                
                const direction = new THREE.Vector3().subVectors(targetPos, startPos);
                const distance = direction.length();
                direction.normalize();
                
                // Thin white line
                const tubeGeo = new THREE.CylinderGeometry(0.008, 0.008, distance, 4);
                const tubeMat = new THREE.MeshBasicMaterial({ 
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.7
                });
                const tube = new THREE.Mesh(tubeGeo, tubeMat);
                
                const midpoint = new THREE.Vector3().addVectors(startPos, targetPos).multiplyScalar(0.5);
                tube.position.copy(midpoint);
                
                tube.quaternion.setFromUnitVectors(
                    new THREE.Vector3(0, 1, 0),
                    direction
                );
                
                scene.add(tube);
                switchESPLines.push(tube);
                
                // Small marker at target
                const markerGeo = new THREE.SphereGeometry(0.1, 8, 8);
                const markerMat = new THREE.MeshBasicMaterial({ 
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.8
                });
                const marker = new THREE.Mesh(markerGeo, markerMat);
                marker.position.copy(targetPos);
                scene.add(marker);
                switchESPLines.push(marker);
            }
        }

        function goToBed(firstTime) {
            State.canMove = false;
            State.canLook = false;
            
            // Disable flashlight when sleeping
            if (flashlight) {
                flashlight.visible = false;
            }
            
            // Clear ESP lines
            switchESPLines.forEach(line => scene.remove(line));
            switchESPLines = [];
            
            // Check off bed task
            const task = document.getElementById('task-house-bed');
            task.classList.add('completed');
            task.querySelector('.checkbox').textContent = '‚úì';
            
            document.getElementById('fade-overlay').classList.add('visible');
            
            setTimeout(() => {
                if (firstTime) {
                    // Move to bed position (bed at x = -14.9, z = -2.4)
                    camera.position.set(-14.5, 0.9, -2.4);
                    cameraPitch = 0;
                    cameraYaw = -Math.PI / 2;  // Look toward door (+x direction)
                    updateCamera();
                    
                    setTimeout(() => {
                        document.getElementById('fade-overlay').classList.remove('visible');
                        State.phase = 'sleeping1';
                        // Sleep transition - no text
                        
                        // First blink after 2 seconds
                        setTimeout(() => {
                            hidePrompt();
                            doBlink(() => {
                                // Second blink after another 2 seconds
                                setTimeout(() => {
                                    doBlink(() => {
                                        // Third blink
                                        setTimeout(() => {
                                            doBlink(() => {
                                                // Wake up - show eyes FIRST
                                                setTimeout(() => {
                                                    document.getElementById('fade-overlay').classList.add('visible');
                                                    setTimeout(() => {
                                                        document.getElementById('fade-overlay').classList.remove('visible');
                                                        
                                                        // Show ONLY the creepy eyes first
                                                        if (creepyEyes) {
                                                            creepyEyes.visible = true;
                                                            creepyEyes.position.x = -5.0;
                                                            
                                                            // Eyes peek in, then retreat, then removed
                                                            animateEyesSinglePeek(() => {
                                                                // Eyes are now gone
                                                                // Now activate the other red LEDs
                                                                State.ledsActive = true;
                                                                updateElectronicsVisibility();
                                                                
                                                                // Give player the flashlight
                                                                if (flashlight) {
                                                                    flashlight.visible = true;
                                                                }
                                                                
                                                                // Now player can move
                                                                showPrompt('What are those red lights...?');
                                                                State.phase = 'scared';
                                                                State.canMove = true;
                                                                State.canLook = true;
                                                                
                                                                setTimeout(() => {
                                                                    hidePrompt();
                                                                    showPrompt('Find the living room light switch!');
                                                                    State.phase = 'turnOnLights';
                                                                    updateLightsUI();
                                                                }, 2500);
                                                            });
                                                        }
                                                    }, 1000);
                                                }, 1500);
                                            });
                                        }, 2000);
                                    });
                                }, 2500);
                            });
                        }, 2500);
                    }, 1000);
                } else {
                    // Second time - peaceful sleep leading to dream
                    // Turn off flashlight
                    if (flashlight) {
                        flashlight.visible = false;
                    }
                    
                    // Hide house checklist
                    setTimeout(() => {
                        document.getElementById('house-checklist').classList.remove('visible');
                    }, 1000);
                    
                    // Move camera to bed position
                    camera.position.set(-14.5, 0.9, -2.4);
                    cameraPitch = 0;
                    cameraYaw = -Math.PI / 2;
                    updateCamera();
                    
                    setTimeout(() => {
                        document.getElementById('fade-overlay').classList.remove('visible');
                        State.phase = 'dreaming';
                        State.canMove = false;
                        State.canLook = false;
                        
                        // Blink sequence before dream
                        setTimeout(() => {
                            doBlink(() => {
                                setTimeout(() => {
                                    doBlink(() => {
                                        setTimeout(() => {
                                            doBlink(() => {
                                                setTimeout(() => {
                                                    doBlink(() => {
                                                        // Final fade to dream
                                                        document.getElementById('fade-overlay').classList.add('visible');
                                                        setTimeout(() => {
                                                            // Load countryside dream scene
                                                            loadCountrysideDream();
                                                        }, 1500);
                                                    });
                                                }, 1500);
                                            });
                                        }, 2000);
                                    });
                                }, 2000);
                            });
                        }, 2000);
                    }, 1000);
                }
            }, 1000);
        }
        
        function doBlink(callback) {
            const overlay = document.getElementById('fade-overlay');
            overlay.style.transition = 'opacity 0.15s';
            overlay.classList.add('visible');

            
            setTimeout(() => {
                overlay.classList.remove('visible');
                setTimeout(() => {
                    overlay.style.transition = 'opacity 1s';
                    if (callback) callback();
                }, 200);
            }, 150);
        }
        
        function animateEyesSinglePeek(onComplete) {
            if (!creepyEyes) {
                if (onComplete) onComplete();
                return;
            }
            
            const startX = -5.0;   // Outside door (in hallway)
            const peekX = -7.2;    // Peeking deep into room
            const duration = 4500; // 4.5 seconds for full peek cycle
            const startTime = Date.now();
            
            creepyEyes.position.x = startX;
            creepyEyes.visible = true;
            
            function animate() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // Movement phases:
                // 0-35%: Slowly peek into room
                // 35-55%: Hold and watch (creepy stare)
                // 55-95%: Slowly retreat back out
                // 95-100%: Gone
                
                let x;
                
                if (progress < 0.35) {
                    // Slowly peek in
                    const phaseProgress = progress / 0.35;
                    const eased = phaseProgress * phaseProgress;
                    x = startX + (peekX - startX) * eased;
                } else if (progress < 0.55) {
                    // Hold position, slight creepy movement
                    x = peekX + Math.sin((progress - 0.35) * 40) * 0.03;
                } else if (progress < 0.95) {
                    // Slowly retreat
                    const phaseProgress = (progress - 0.55) / 0.4;
                    const eased = 1 - Math.pow(1 - phaseProgress, 2);
                    x = peekX + (startX - peekX) * eased;
                } else {
                    // Gone
                    x = startX;
                }
                
                creepyEyes.position.x = x;
                
                // Bobbing motion (like breathing)
                creepyEyes.position.y = 1.5 + Math.sin(elapsed * 0.004) * 0.025;
                
                // Slight z sway
                creepyEyes.position.z = -3 + Math.sin(elapsed * 0.003) * 0.04;
                
                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    // Animation complete - hide eyes and callback
                    creepyEyes.visible = false;
                    if (onComplete) onComplete();
                }
            }
            
            animate();
        }

        function onMouseMove(e) {
            if (!State.locked || !State.canLook) return;
            
            cameraYaw -= e.movementX * 0.002;
            
            // Allow full vertical look range in dream/ocean/christmas scenes
            if (isDreamScene || isOceanScene || isChristmasScene) {
                if (State.phase !== 'falling' && State.phase !== 'floating') {
                    cameraPitch -= e.movementY * 0.002;
                    // Limit vertical look in ocean scene to avoid clipping
                    if (isOceanScene) {
                        cameraPitch = Math.max(-Math.PI / 4, Math.min(Math.PI / 3, cameraPitch));
                    } else {
                        cameraPitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, cameraPitch));
                    }
                }
                
                // Detect looking up at stars
                if (State.phase === 'dream_lookUp') {
                    if (cameraPitch > 1.0 && cameraPitch < 1.5) {
                        showPrompt('Keep looking up...');
                    }
                    if (cameraPitch > 1.5) {
                        startFalling();
                    }
                }
            } else {
                cameraPitch -= e.movementY * 0.002;
                cameraPitch = Math.max(-Math.PI / 2.5, Math.min(Math.PI / 2.5, cameraPitch));
            }
            
            updateCamera();
        }

        function updateCamera() {
            camera.rotation.order = 'YXZ';
            camera.rotation.y = cameraYaw;
            camera.rotation.x = cameraPitch;
        }

        function onClick(e) {
            // Handle star drawing in dream scene
            if (State.phase === 'drawing') {
                addStar3D(e.clientX, e.clientY);
                return;
            }
            
            // Allow pointer lock request in dream/ocean/christmas scenes
            if (!State.locked) {
                document.body.requestPointerLock();
                // Re-show prompt if in lookUp phase
                if (State.phase === 'dream_lookUp') {
                    setTimeout(() => showPrompt('Look up at the stars...'), 100);
                }
                // Hide prompt when locking in sheep phase
                if (State.phase === 'sheep') {
                    hidePrompt();
                }
                // Hide prompt when locking in ocean scene
                if (isOceanScene) {
                    hidePrompt();
                }
                return;
            }
            
            // Christmas scene interactions
            if (isChristmasScene && christmasPhase !== 'end') {
                raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
                
                // Check light button
                if (lightButton && !lightsOn) {
                    const buttonDist = camera.position.distanceTo(lightButton.position);
                    if (buttonDist < 4) {
                        const intersects = raycaster.intersectObjects(lightButton.children, true);
                        if (intersects.length > 0) {
                            turnOnChristmasLights();
                            return;
                        }
                    }
                }
                
                // Check campfire (must have lights on first)
                if (campfire && lightsOn && !fireLit) {
                    const fireDist = camera.position.distanceTo(campfire.position);
                    if (fireDist < 4) {
                        const intersects = raycaster.intersectObjects(campfire.children, true);
                        if (intersects.length > 0) {
                            lightCampfire();
                            return;
                        }
                    }
                }
                
                // Check cocoa - pickup first, then drink
                if (cocoaMug && fireLit && !holdingCocoa) {
                    const cocoaPos = new THREE.Vector3(-8, 0.8, 8);
                    const cocoaDist = camera.position.distanceTo(cocoaPos);
                    if (cocoaDist < 3) {
                        pickupCocoa();
                        return;
                    }
                }
                
                // If holding cocoa, click to drink
                if (holdingCocoa && !drinkingCocoa) {
                    drinkCocoaChristmas();
                    return;
                }
                
                return;
            }
            
            // Skip interaction checks for dream/ocean scene phases
            if (isDreamScene || isOceanScene) return;
            
            if (!State.canInteract) return;
            
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            
            // Check light switches
            for (const sw of lightSwitches) {
                const dist = camera.position.distanceTo(sw.position);
                if (dist < 3) {
                    const intersects = raycaster.intersectObjects(sw.children, true);
                    if (intersects.length > 0) {
                        toggleLight(sw.userData.room);
                        return;
                    }
                }
            }
            
            // Check bed interaction
            if (State.phase === 'goToBed1' || State.phase === 'goToBed2') {
                const bedPos = new THREE.Vector3(-14.9, 1.6, -2.4);
                const bedDist = camera.position.distanceTo(bedPos);
                if (bedDist < 4) {
                    goToBed(State.phase === 'goToBed1');
                }
            }
        }

        function checkInteractionHint() {
            const hint = document.getElementById('interaction-hint');
            let showHint = false;
            let hintText = '';
            
            // Christmas scene hints
            if (isChristmasScene && christmasPhase !== 'end' && !lyingDown && !eyesClosed) {
                raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
                
                // Light button hint
                if (lightButton && !lightsOn) {
                    const buttonDist = camera.position.distanceTo(lightButton.position);
                    if (buttonDist < 4) {
                        const intersects = raycaster.intersectObjects(lightButton.children, true);
                        if (intersects.length > 0) {
                            showHint = true;
                            hintText = 'Click to turn on lights';
                        }
                    }
                }
                
                // Campfire hint
                if (!showHint && campfire && lightsOn && !fireLit) {
                    const fireDist = camera.position.distanceTo(campfire.position);
                    if (fireDist < 4) {
                        const intersects = raycaster.intersectObjects(campfire.children, true);
                        if (intersects.length > 0) {
                            showHint = true;
                            hintText = 'Click to light fire';
                        }
                    }
                }
                
                // Cocoa hint - pickup
                if (!showHint && cocoaMug && fireLit && !holdingCocoa) {
                    const cocoaPos = new THREE.Vector3(-8, 0.8, 8);
                    const cocoaDist = camera.position.distanceTo(cocoaPos);
                    if (cocoaDist < 3) {
                        showHint = true;
                        hintText = 'Click to pick up cocoa';
                    }
                }
                
                // Cocoa hint - drink
                if (!showHint && holdingCocoa && !drinkingCocoa) {
                    showHint = true;
                    hintText = 'Click to drink';
                }
                
                if (showHint) {
                    hint.textContent = hintText;
                    hint.classList.add('visible');
                } else {
                    hint.classList.remove('visible');
                }
                return;
            }
            
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            
            for (const sw of lightSwitches) {
                const dist = camera.position.distanceTo(sw.position);
                if (dist < 3) {
                    const intersects = raycaster.intersectObjects(sw.children, true);
                    if (intersects.length > 0) {
                        showHint = true;
                        hintText = 'Click to toggle light';
                        break;
                    }
                }
            }
            
            if (!showHint && (State.phase === 'goToBed1' || State.phase === 'goToBed2')) {
                const bedPos = new THREE.Vector3(-14.9, 1.6, -2.4);
                const bedDist = camera.position.distanceTo(bedPos);
                if (bedDist < 4) {
                    showHint = true;
                    hintText = 'Click to go to bed';
                }
            }
            
            if (showHint) {
                hint.textContent = hintText;
                hint.classList.add('visible');
            } else {
                hint.classList.remove('visible');
            }
        }

        // ============ EDITOR FUNCTIONS ============
        
        function toggleEditorMode() {
            editorMode = !editorMode;
            document.getElementById('editor-panel').classList.toggle('visible', editorMode);
            document.getElementById('editor-mode-hint').classList.toggle('visible', editorMode);
            
            if (!editorMode) {
                editorDeselect();
                editorGrabbing = false;
            }
        }
        
        function editorSelectUnderCrosshair() {
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            const intersects = raycaster.intersectObjects(editorObjects, true);
            
            if (intersects.length > 0) {
                let obj = intersects[0].object;
                // Find parent if it's a group
                while (obj.parent && !obj.userData.editable) {
                    obj = obj.parent;
                }
                if (obj.userData.editable) {
                    editorSelect(obj);
                }
            }
        }
        
        function editorSelect(obj) {
            editorDeselect();
            editorSelected = obj;
            editorSetHighlight(obj, 0x444400);
            updateEditorUI();
        }
        
        function editorDeselect() {
            if (editorSelected) {
                editorSetHighlight(editorSelected, 0x000000);
            }
            editorSelected = null;
            editorGrabbing = false;
            updateEditorUI();
        }
        
        function editorSetHighlight(obj, color) {
            obj.traverse(child => {
                if (child.material && child.material.emissive) {
                    child.material.emissive.setHex(color);
                }
            });
        }
        
        function editorCheckHighlight() {
            if (!editorMode || editorGrabbing) return;
            
            // Clear previous highlight
            if (editorHighlighted && editorHighlighted !== editorSelected) {
                editorSetHighlight(editorHighlighted, 0x000000);
            }
            
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            const intersects = raycaster.intersectObjects(editorObjects, true);
            
            if (intersects.length > 0) {
                let obj = intersects[0].object;
                while (obj.parent && !obj.userData.editable) {
                    obj = obj.parent;
                }
                if (obj.userData.editable && obj !== editorSelected) {
                    editorHighlighted = obj;
                    editorSetHighlight(obj, 0x222222);
                }
            } else {
                editorHighlighted = null;
            }
        }
        
        function updateEditorUI() {
            const el = document.getElementById('editor-selected');
            if (editorSelected) {
                const p = editorSelected.position;
                el.innerHTML = `
                    <div class="selected-name">${editorSelected.name}</div>
                    <div class="coords">X: ${p.x.toFixed(2)} Y: ${p.y.toFixed(2)} Z: ${p.z.toFixed(2)}</div>
                    <div style="color:${editorGrabbing ? '#f80' : '#888'}">${editorGrabbing ? '‚ö° GRABBING - Arrow keys to move' : 'Press G to grab'}</div>
                `;
            } else {
                el.textContent = 'None - look at object and press E';
            }
        }
        
        function editorLogChange(obj) {
            const p = obj.position;
            const existing = editorChanges.findIndex(c => c.name === obj.name);
            
            const entry = {
                name: obj.name,
                type: obj.userData.type || 'box',
                action: 'MOVED',
                x: p.x.toFixed(2),
                y: p.y.toFixed(2),
                z: p.z.toFixed(2)
            };
            
            if (existing >= 0) {
                editorChanges[existing] = entry;
            } else {
                editorChanges.push(entry);
            }
            
            updateEditorChangesLog();
        }
        
        function updateEditorChangesLog() {
            const log = document.getElementById('editor-changes');
            if (editorChanges.length === 0) {
                log.textContent = 'No changes yet';
                return;
            }
            
            log.textContent = editorChanges.map(c => 
                `${c.name}: (${c.x}, ${c.y}, ${c.z})`
            ).join('\n');
        }
        
        function editorDuplicate() {
            if (!editorSelected) return;
            const clone = editorSelected.clone();
            clone.position.x += 1;
            clone.name = editorSelected.name + '_copy';
            clone.userData = { ...editorSelected.userData, originalPos: null };
            scene.add(clone);
            editorObjects.push(clone);
            editorLogChange(clone);
            editorSelect(clone);
        }
        
        function editorDelete() {
            if (!editorSelected) return;
            const entry = {
                name: editorSelected.name,
                action: 'DELETED',
                x: '-', y: '-', z: '-'
            };
            editorChanges.push(entry);
            updateEditorChangesLog();
            
            scene.remove(editorSelected);
            editorObjects = editorObjects.filter(o => o !== editorSelected);
            editorDeselect();
        }
        
        function editorCopyChanges() {
            if (editorChanges.length === 0) {
                alert('No changes to copy!');
                return;
            }
            
            let output = '// ========== EDITOR CHANGES ==========\n';
            output += '// Copy this to Claude to apply changes\n\n';
            
            editorChanges.forEach(c => {
                if (c.action === 'DELETED') {
                    output += `// DELETE: ${c.name}\n`;
                } else {
                    output += `// ${c.name}\n`;
                    output += `// New position: (${c.x}, ${c.y}, ${c.z})\n`;
                }
                output += '\n';
            });
            
            navigator.clipboard.writeText(output).then(() => {
                alert('Changes copied to clipboard!');
            }).catch(() => {
                // Fallback
                console.log(output);
                alert('Check console for changes (Ctrl+Shift+J)');
            });
        }
        
        function editorClearChanges() {
            editorChanges = [];
            updateEditorChangesLog();
        }

        function animate(now) {
            requestAnimationFrame(animate);
            
            const time = now * 0.001;
            const dt = 0.016; // Approximate delta time
            
            // If in Christmas scene, use Christmas update logic
            if (isChristmasScene) {
                if (State.canLook) {
                    updateCamera();
                }
                updateChristmasScene(time, dt);
                renderer.render(scene, camera);
                return;
            }
            
            // If in ocean scene, use ocean update logic
            if (isOceanScene) {
                if (State.canLook) {
                    updateCamera();
                }
                updateOceanScene(time, dt);
                renderer.render(scene, camera);
                return;
            }
            
            // If in dream scene, use dream update logic
            if (isDreamScene) {
                if (State.canLook) {
                    updateCamera();
                }
                updateDreamScene(time, dt);
                renderer.render(scene, camera);
                return;
            }
            
            // Movement
            if (State.canMove && State.locked) {
                const dir = new THREE.Vector3();
                if (State.keys.w) dir.z -= 1;
                if (State.keys.s) dir.z += 1;
                if (State.keys.a) dir.x -= 1;
                if (State.keys.d) dir.x += 1;
                dir.normalize();
                
                if (dir.length() > 0) {
                    const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
                    forward.y = 0;
                    forward.normalize();
                    const right = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
                    right.y = 0;
                    right.normalize();
                    
                    State.velocity.addScaledVector(forward, -dir.z * 0.012);
                    State.velocity.addScaledVector(right, dir.x * 0.012);
                }
                
                State.velocity.multiplyScalar(0.9);
                State.velocity.clampLength(0, 0.07);
                
                let newX = camera.position.x + State.velocity.x;
                let newZ = camera.position.z + State.velocity.z;
                
                // Boundaries
                const margin = 0.5;
                const W = HOUSE.width, D = HOUSE.depth;
                newX = Math.max(-W/2 + margin, Math.min(W/2 - margin, newX));
                newZ = Math.max(-D/2 + margin, Math.min(D/2 - margin, newZ));
                
                // Wall collisions
                const doorZ = -3;
                const doorHalfW = HOUSE.doorWidth / 2;
                
                // Bedroom wall (full wall with door opening)
                if (Math.abs(newX - HOUSE.bedroomWallX) < 0.4) {
                    // Block unless in door opening
                    if (newZ < doorZ - doorHalfW || newZ > doorZ + doorHalfW) {
                        newX = camera.position.x;
                    }
                }
                
                // Kitchen wall (only back section exists, front is open)
                if (Math.abs(newX - HOUSE.kitchenWallX) < 0.4) {
                    // Only block in back section (z < door opening)
                    if (newZ < doorZ - doorHalfW) {
                        newX = camera.position.x;
                    }
                }
                
                camera.position.x = newX;
                camera.position.z = newZ;
                camera.position.y = 1.6;
            }

            if (State.canLook) {
                updateCamera();
            }
            
            checkInteractionHint();
            
            // Editor mode highlighting
            if (editorMode) {
                editorCheckHighlight();
            }
            
            // Animate electronics
            electronics.forEach((led, i) => {
                if (led.visible) {
                    const pulse = 0.8 + Math.sin(time * 2 + i) * 0.2;
                    led.material.color.setRGB(pulse, 0, 0);
                    led.userData.glow.intensity = 0.2 + Math.sin(time * 3 + i) * 0.1;
                }
            });
            
            // Animate light switch glow (brighter when lights are off)
            const allLightsOff = State.lightsOn.length === 0;
            lightSwitches.forEach((sw, i) => {
                if (sw.userData.glowDot && sw.userData.glowLight) {
                    const baseBrightness = allLightsOff ? 0.9 : 0.4;
                    const pulse = baseBrightness + Math.sin(time * 1.5 + i * 2) * 0.1;
                    sw.userData.glowDot.material.opacity = pulse;
                    sw.userData.glowLight.intensity = allLightsOff ? 0.25 + Math.sin(time * 2 + i) * 0.1 : 0.08;
                }
                // Animate switch outline to pulse
                if (sw.userData.outline && sw.userData.outline.visible) {
                    const outlinePulse = 0.4 + Math.sin(time * 3 + i) * 0.3;
                    sw.userData.outline.material.opacity = outlinePulse;
                }
            });
            
            // Animate creepy eyes
            if (creepyEyes && creepyEyes.visible) {
                const eyePulse = 0.7 + Math.sin(time * 4) * 0.3;
                creepyEyes.userData.leftEye.material.color.setRGB(eyePulse, 0, 0);
                creepyEyes.userData.rightEye.material.color.setRGB(eyePulse, 0, 0);
                creepyEyes.userData.leftGlow.intensity = 0.4 + Math.sin(time * 3) * 0.2;
                creepyEyes.userData.rightGlow.intensity = 0.4 + Math.sin(time * 3 + 0.5) * 0.2;
                
                // Slight random jitter for creepiness
                if (Math.random() < 0.02) {
                    creepyEyes.position.z = -3 + (Math.random() - 0.5) * 0.1;
                }
            }

            // Update switch ESP lines
            if (State.phase === 'turnOffLights' || State.phase === 'turnOffLights2' || 
                State.phase === 'goToBed1' || State.phase === 'goToBed2' || State.phase === 'turnOnLights') {
                updateSwitchESP();
            }

            renderer.render(scene, camera);
        }

        // ============ COUNTRYSIDE DREAM SCENE ============
        
        function getTerrainHeight(x, z) {
            const localY = -z;
            let elevation = 0;
            elevation += Math.sin(x * 0.05) * Math.cos(localY * 0.05) * 3;
            elevation += Math.sin(x * 0.02 + 1) * Math.cos(localY * 0.03) * 5;
            elevation += Math.sin(x * 0.08) * Math.sin(localY * 0.06) * 1.5;
            elevation += Math.sin(x * 0.15) * Math.cos(localY * 0.12) * 0.8;
            return elevation;
        }

        function loadCountrysideDream() {
            // Stop static household audio
            const staticAudio = document.getElementById('audio-static');
            if (staticAudio) {
                staticAudio.pause();
                staticAudio.currentTime = 0;
            }

            // Stop static noise
            if (masterGain) masterGain.gain.value = 0;

            // Set dream mode
            isDreamScene = true;
            State.phase = 'dream_exploring';
            State.canMove = true;
            State.canLook = true;
            State.starCount = 0;

            // Clear existing scene
            while(scene.children.length > 0) { 
                scene.remove(scene.children[0]); 
            }
            
            scene.background = new THREE.Color(0x0a0a18);
            scene.fog = new THREE.FogExp2(0x0a0a18, 0.004);  // Reduced fog density

            // Extend camera far plane for stars
            camera.far = 500;
            camera.updateProjectionMatrix();
            
            camera.position.set(0, getTerrainHeight(0, 15) + 1.7, 15);
            cameraYaw = 0;
            cameraPitch = 0;
            updateCamera();
            
            // Re-add camera to scene
            scene.add(camera);

            colliders = [];
            groundObjects = [];
            houseObjects = [];
            fireflies = [];
            stars2D = [];
            animals = [];
            fallProgress = 0;
            targetPitch = 0;

            // Enhanced lighting
            scene.add(new THREE.AmbientLight(0x2a2a4a, 0.6));
            const moonLight = new THREE.DirectionalLight(0x6a7aaa, 0.4);
            moonLight.position.set(60, 80, -100);
            moonLight.castShadow = true;
            scene.add(moonLight);
            scene.add(new THREE.HemisphereLight(0x4a4a6a, 0x2a3a2a, 0.5));

            // Ground with better material
            const groundGeo = new THREE.PlaneGeometry(200, 200, 100, 100);
            const groundMat = new THREE.MeshLambertMaterial({ color: 0x2a3a2a });
            
            const vertices = groundGeo.attributes.position.array;
            for (let i = 0; i < vertices.length; i += 3) {
                const x = vertices[i];
                const y = vertices[i + 1];
                let elevation = 0;
                elevation += Math.sin(x * 0.05) * Math.cos(y * 0.05) * 3;
                elevation += Math.sin(x * 0.02 + 1) * Math.cos(y * 0.03) * 5;
                elevation += Math.sin(x * 0.08) * Math.sin(y * 0.06) * 1.5;
                elevation += Math.sin(x * 0.15) * Math.cos(y * 0.12) * 0.8;
                vertices[i + 2] = elevation;
            }
            groundGeo.attributes.position.needsUpdate = true;
            groundGeo.computeVertexNormals();
            
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            ground.userData.startY = 0;
            scene.add(ground);
            groundObjects.push(ground);

            createInstancedGrass();
            createWildflowers();
            createMushrooms();
            createRocks();
            createBushes();
            createStream();
            createStreamDetails();
            createBridge();

            // Enhanced houses with more variety
            const housePositions = [
                { x: -25, z: -15, type: 'cottage' },
                { x: 15, z: -20, type: 'farmhouse' },
                { x: -10, z: -40, type: 'cottage' },
                { x: 30, z: -35, type: 'barn' },
                { x: -40, z: -30, type: 'farmhouse' }
            ];
            housePositions.forEach((pos) => {
                const house = createDreamHouse(pos.type);
                const hy = getTerrainHeight(pos.x, pos.z);
                house.position.set(pos.x, hy, pos.z);
                house.rotation.y = Math.random() * 0.5;
                house.userData.startY = hy;
                scene.add(house);
                houseObjects.push(house);
                colliders.push({ x: pos.x, z: pos.z, r: 6 });
                
                // Add fence around house
                createFence(pos.x, pos.z, hy);
            });

            // Village details
            createWell(-5, -25);
            createStonePaths();
            createHayBales();

            // Trees with more variety
            for (let i = 0; i < 60; i++) {
                let x = (Math.random() - 0.5) * 160;
                let z = (Math.random() - 0.5) * 160;
                if (Math.abs(z) < 20 && Math.abs(x) < 30) continue;
                if (Math.abs(z - 35) < 8) continue;

                const treeType = Math.random() > 0.3 ? 'pine' : 'oak';
                const tree = createTree(treeType);
                const ty = getTerrainHeight(x, z);
                tree.position.set(x, ty, z);
                tree.scale.setScalar(0.6 + Math.random() * 0.6);
                tree.userData.startY = ty;
                scene.add(tree);
                groundObjects.push(tree);
                colliders.push({ x, z, r: 0.5 });
            }

            // Enhanced fireflies
            for (let i = 0; i < 250; i++) {
                const hasLight = i < 20;
                const ff = createFirefly(hasLight);
                
                const fx = (Math.random() - 0.5) * 120;
                const fz = (Math.random() - 0.5) * 120;
                
                let fy;
                if (i < 120) {
                    fy = getTerrainHeight(fx, fz) + 0.5 + Math.random() * 4;
                } else {
                    fy = 5 + Math.random() * 15;
                }
                
                ff.position.set(fx, fy, fz);
                ff.userData.basePos = ff.position.clone();
                ff.userData.phase = Math.random() * Math.PI * 2;
                ff.userData.speed = 0.3 + Math.random() * 0.7;
                ff.userData.hasLight = hasLight;
                scene.add(ff);
                fireflies.push(ff);
            }

            createLanterns();
            createAnimals();
            createSky();

                        // Start countryside audio
            const countrysideAudio = document.getElementById('audio-countryside');
            if (countrysideAudio) {
                countrysideAudio.volume = 0.5;
                countrysideAudio.play().catch(e => console.log('Audio play failed:', e));
            }

            // Fade in from dream transition
            setTimeout(() => {
                document.getElementById('fade-overlay').classList.remove('visible');
                // Show dream checklist
                document.getElementById('dream-checklist').classList.add('visible');
                
                setTimeout(() => {
                    State.phase = 'dream_lookUp';
                    showPrompt('Look up at the stars...');
                }, 2000);
            }, 500);
        }

        function createDreamHouse(type = 'cottage') {
            const g = new THREE.Group();
            const woodDark = new THREE.MeshLambertMaterial({ color: 0x3a3530 });
            const woodLight = new THREE.MeshLambertMaterial({ color: 0x5a5040 });
            const stone = new THREE.MeshLambertMaterial({ color: 0x4a4a4a });
            const thatch = new THREE.MeshLambertMaterial({ color: 0x5a4a30 });
            
            if (type === 'cottage') {
                // Main body - stone base
                const base = new THREE.Mesh(
                    new THREE.BoxGeometry(6, 0.5, 5),
                    stone
                );
                base.position.y = 0.25;
                g.add(base);
                
                // Walls
                const body = new THREE.Mesh(
                    new THREE.BoxGeometry(5.5, 3.5, 4.5),
                    woodLight
                );
                body.position.y = 2.25;
                body.castShadow = true;
                g.add(body);

                // Thatched roof
                const roof = new THREE.Mesh(
                    new THREE.ConeGeometry(4.5, 2.5, 4),
                    thatch
                );
                roof.position.y = 5.25;
                roof.rotation.y = Math.PI / 4;
                g.add(roof);
                
                // Chimney
                const chimney = new THREE.Mesh(
                    new THREE.BoxGeometry(0.6, 2, 0.6),
                    stone
                );
                chimney.position.set(1.5, 5.5, 0);
                g.add(chimney);
                
                // Smoke particles placeholder (will animate)
                for (let i = 0; i < 3; i++) {
                    const smoke = new THREE.Mesh(
                        new THREE.SphereGeometry(0.15, 6, 6),
                        new THREE.MeshBasicMaterial({ color: 0x666666, transparent: true, opacity: 0.3 })
                    );
                    smoke.position.set(1.5, 6.5 + i * 0.5, 0);
                    smoke.userData.smokeOffset = i;
                    g.add(smoke);
                }
                
                // Door
                const door = new THREE.Mesh(
                    new THREE.BoxGeometry(0.8, 1.8, 0.1),
                    woodDark
                );
                door.position.set(0, 1.4, 2.3);
                g.add(door);
                
                // Door frame
                const doorFrame = new THREE.Mesh(
                    new THREE.BoxGeometry(1.1, 2.1, 0.05),
                    woodDark
                );
                doorFrame.position.set(0, 1.5, 2.28);
                g.add(doorFrame);
                
                // Windows with shutters
                [{ x: -1.5, z: 2.26 }, { x: 1.5, z: 2.26 }].forEach(wpos => {
                    // Window glow
                    const win = new THREE.Mesh(
                        new THREE.PlaneGeometry(0.7, 1.0),
                        new THREE.MeshBasicMaterial({ color: 0xffcc66, transparent: true, opacity: 0.9 })
                    );
                    win.position.set(wpos.x, 2.5, wpos.z);
                    g.add(win);
                    
                    // Window frame
                    const frame = new THREE.Mesh(
                        new THREE.BoxGeometry(0.9, 1.2, 0.05),
                        woodDark
                    );
                    frame.position.set(wpos.x, 2.5, wpos.z + 0.03);
                    g.add(frame);
                    
                    // Cross bars
                    const hBar = new THREE.Mesh(new THREE.BoxGeometry(0.7, 0.05, 0.02), woodDark);
                    hBar.position.set(wpos.x, 2.5, wpos.z + 0.05);
                    g.add(hBar);
                    const vBar = new THREE.Mesh(new THREE.BoxGeometry(0.05, 1.0, 0.02), woodDark);
                    vBar.position.set(wpos.x, 2.5, wpos.z + 0.05);
                    g.add(vBar);
                    
                    // Shutters
                    const shutterL = new THREE.Mesh(new THREE.BoxGeometry(0.3, 1.0, 0.05), woodDark);
                    shutterL.position.set(wpos.x - 0.5, 2.5, wpos.z + 0.02);
                    g.add(shutterL);
                    const shutterR = new THREE.Mesh(new THREE.BoxGeometry(0.3, 1.0, 0.05), woodDark);
                    shutterR.position.set(wpos.x + 0.5, 2.5, wpos.z + 0.02);
                    g.add(shutterR);
                });
                
                // Window light
                const light = new THREE.PointLight(0xffaa44, 1.5, 25);
                light.position.set(0, 2.5, 3);
                g.add(light);
                
            } else if (type === 'farmhouse') {
                // Larger farmhouse
                const base = new THREE.Mesh(new THREE.BoxGeometry(8, 0.4, 6), stone);
                base.position.y = 0.2;
                g.add(base);
                
                const body = new THREE.Mesh(new THREE.BoxGeometry(7.5, 4, 5.5), woodLight);
                body.position.y = 2.4;
                body.castShadow = true;
                g.add(body);
                
                // Peaked roof using box geometry for solid appearance
                const roofMat = new THREE.MeshLambertMaterial({ color: 0x5a4a30, side: THREE.DoubleSide });
                
                // Left roof slope
                const roofL = new THREE.Mesh(
                    new THREE.BoxGeometry(4.5, 0.15, 6.2),
                    roofMat
                );
                roofL.position.set(-1.6, 5.6, 0);
                roofL.rotation.z = 0.65;
                g.add(roofL);
                
                // Right roof slope
                const roofR = new THREE.Mesh(
                    new THREE.BoxGeometry(4.5, 0.15, 6.2),
                    roofMat
                );
                roofR.position.set(1.6, 5.6, 0);
                roofR.rotation.z = -0.65;
                g.add(roofR);
                
                // Front gable (triangle)
                const gableFrontGeo = new THREE.BufferGeometry();
                const gfVerts = new Float32Array([
                    -3.8, 0, 0,  3.8, 0, 0,  0, 2.3, 0
                ]);
                gableFrontGeo.setAttribute('position', new THREE.BufferAttribute(gfVerts, 3));
                gableFrontGeo.computeVertexNormals();
                const gableFront = new THREE.Mesh(gableFrontGeo, woodLight);
                gableFront.position.set(0, 4.4, 2.76);
                g.add(gableFront);
                
                // Back gable
                const gableBackGeo = new THREE.BufferGeometry();
                const gbVerts = new Float32Array([
                    3.8, 0, 0,  -3.8, 0, 0,  0, 2.3, 0
                ]);
                gableBackGeo.setAttribute('position', new THREE.BufferAttribute(gbVerts, 3));
                gableBackGeo.computeVertexNormals();
                const gableBack = new THREE.Mesh(gableBackGeo, woodLight);
                gableBack.position.set(0, 4.4, -2.76);
                g.add(gableBack);
                
                // Chimney
                const chimney = new THREE.Mesh(new THREE.BoxGeometry(0.8, 2.5, 0.8), stone);
                chimney.position.set(2, 6, 0);
                g.add(chimney);
                
                // Door
                const door = new THREE.Mesh(new THREE.BoxGeometry(1, 2.2, 0.1), woodDark);
                door.position.set(0, 1.5, 2.8);
                g.add(door);
                
                // Multiple windows
                [-2, 2].forEach(wx => {
                    const win = new THREE.Mesh(
                        new THREE.PlaneGeometry(0.8, 1.2),
                        new THREE.MeshBasicMaterial({ color: 0xffcc66 })
                    );
                    win.position.set(wx, 2.8, 2.76);
                    g.add(win);
                });
                
                const light = new THREE.PointLight(0xffaa44, 2, 30);
                light.position.set(0, 2.5, 4);
                g.add(light);
                
            } else if (type === 'barn') {
                // Large barn
                const body = new THREE.Mesh(new THREE.BoxGeometry(10, 5, 7), 
                    new THREE.MeshLambertMaterial({ color: 0x6a3020 }));
                body.position.y = 2.5;
                body.castShadow = true;
                g.add(body);
                
                // Barn roof using box geometry
                const barnRoofMat = new THREE.MeshLambertMaterial({ color: 0x4a3020, side: THREE.DoubleSide });
                
                // Left roof slope
                const barnRoofL = new THREE.Mesh(
                    new THREE.BoxGeometry(6.5, 0.2, 8),
                    barnRoofMat
                );
                barnRoofL.position.set(-2.3, 6.5, 0);
                barnRoofL.rotation.z = 0.55;
                g.add(barnRoofL);
                
                // Right roof slope
                const barnRoofR = new THREE.Mesh(
                    new THREE.BoxGeometry(6.5, 0.2, 8),
                    barnRoofMat
                );
                barnRoofR.position.set(2.3, 6.5, 0);
                barnRoofR.rotation.z = -0.55;
                g.add(barnRoofR);
                
                // Front gable
                const barnGableFrontGeo = new THREE.BufferGeometry();
                const bgfVerts = new Float32Array([
                    -5.2, 0, 0,  5.2, 0, 0,  0, 2.8, 0
                ]);
                barnGableFrontGeo.setAttribute('position', new THREE.BufferAttribute(bgfVerts, 3));
                barnGableFrontGeo.computeVertexNormals();
                const barnGableFront = new THREE.Mesh(barnGableFrontGeo, new THREE.MeshLambertMaterial({ color: 0x6a3020 }));
                barnGableFront.position.set(0, 5, 3.51);
                g.add(barnGableFront);
                
                // Back gable  
                const barnGableBackGeo = new THREE.BufferGeometry();
                const bgbVerts = new Float32Array([
                    5.2, 0, 0,  -5.2, 0, 0,  0, 2.8, 0
                ]);
                barnGableBackGeo.setAttribute('position', new THREE.BufferAttribute(bgbVerts, 3));
                barnGableBackGeo.computeVertexNormals();
                const barnGableBack = new THREE.Mesh(barnGableBackGeo, new THREE.MeshLambertMaterial({ color: 0x6a3020 }));
                barnGableBack.position.set(0, 5, -3.51);
                g.add(barnGableBack);
                
                // Barn doors
                const doorL = new THREE.Mesh(new THREE.BoxGeometry(1.8, 3.5, 0.15), woodDark);
                doorL.position.set(-1, 1.75, 3.55);
                g.add(doorL);
                const doorR = new THREE.Mesh(new THREE.BoxGeometry(1.8, 3.5, 0.15), woodDark);
                doorR.position.set(1, 1.75, 3.55);
                g.add(doorR);
                
                // Hay loft window
                const loftWin = new THREE.Mesh(
                    new THREE.CircleGeometry(0.6, 8),
                    new THREE.MeshBasicMaterial({ color: 0x332211 })
                );
                loftWin.position.set(0, 6, 3.52);
                g.add(loftWin);
                
                // Dim interior light
                const light = new THREE.PointLight(0xffaa44, 0.5, 15);
                light.position.set(0, 2, 0);
                g.add(light);
            }

            return g;
        }

        function createFence(cx, cz, cy) {
            const fenceMat = new THREE.MeshLambertMaterial({ color: 0x5a4a3a });
            const radius = 10;
            const posts = 12;
            
            for (let i = 0; i < posts; i++) {
                const angle = (i / posts) * Math.PI * 2;
                const x = cx + Math.cos(angle) * radius;
                const z = cz + Math.sin(angle) * radius;
                const y = getTerrainHeight(x, z);
                
                // Post
                const post = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.08, 0.1, 1.2),
                    fenceMat
                );
                post.position.set(x, y + 0.6, z);
                post.userData.startY = y + 0.6;
                scene.add(post);
                groundObjects.push(post);
                
                // Horizontal rails connecting to next post
                const nextAngle = ((i + 1) / posts) * Math.PI * 2;
                const nx = cx + Math.cos(nextAngle) * radius;
                const nz = cz + Math.sin(nextAngle) * radius;
                const ny = getTerrainHeight(nx, nz);
                
                const dx = nx - x;
                const dz = nz - z;
                const dy = ny - y;
                const dist = Math.sqrt(dx * dx + dz * dz);
                const fullDist = Math.sqrt(dx * dx + dy * dy + dz * dz);
                
                for (let h = 0; h < 2; h++) {
                    const railHeight = 0.4 + h * 0.4;
                    const rail = new THREE.Mesh(
                        new THREE.BoxGeometry(fullDist, 0.06, 0.06),
                        fenceMat
                    );
                    
                    // Position at midpoint between posts
                    rail.position.set(
                        (x + nx) / 2,
                        (y + ny) / 2 + railHeight,
                        (z + nz) / 2
                    );
                    
                    // Use lookAt to orient the rail correctly
                    const direction = new THREE.Vector3(dx, dy, dz).normalize();
                    const quaternion = new THREE.Quaternion();
                    quaternion.setFromUnitVectors(new THREE.Vector3(1, 0, 0), direction);
                    rail.quaternion.copy(quaternion);
                    
                    rail.userData.startY = (y + ny) / 2 + railHeight;
                    scene.add(rail);
                    groundObjects.push(rail);
                }
            }
        }

        function createWell(wx, wz) {
            const g = new THREE.Group();
            const stone = new THREE.MeshLambertMaterial({ color: 0x5a5a5a });
            const wood = new THREE.MeshLambertMaterial({ color: 0x4a3a2a });
            
            // Stone base (cylinder)
            const base = new THREE.Mesh(
                new THREE.CylinderGeometry(1, 1.2, 1.5, 12),
                stone
            );
            base.position.y = 0.75;
            g.add(base);
            
            // Inner dark
            const inner = new THREE.Mesh(
                new THREE.CylinderGeometry(0.7, 0.7, 1.6, 12),
                new THREE.MeshBasicMaterial({ color: 0x111111 })
            );
            inner.position.y = 0.8;
            g.add(inner);
            
            // Roof supports
            const support1 = new THREE.Mesh(new THREE.BoxGeometry(0.15, 2, 0.15), wood);
            support1.position.set(0.9, 2, 0);
            g.add(support1);
            const support2 = new THREE.Mesh(new THREE.BoxGeometry(0.15, 2, 0.15), wood);
            support2.position.set(-0.9, 2, 0);
            g.add(support2);
            
            // Crossbeam
            const beam = new THREE.Mesh(new THREE.BoxGeometry(2.2, 0.12, 0.12), wood);
            beam.position.y = 3;
            g.add(beam);
            
            // Little roof
            const roof = new THREE.Mesh(
                new THREE.ConeGeometry(1.3, 0.8, 4),
                new THREE.MeshLambertMaterial({ color: 0x5a4030 })
            );
            roof.position.y = 3.5;
            roof.rotation.y = Math.PI / 4;
            g.add(roof);
            
            // Bucket
            const bucket = new THREE.Mesh(
                new THREE.CylinderGeometry(0.15, 0.12, 0.25, 8),
                wood
            );
            bucket.position.set(0, 2, 0);
            g.add(bucket);
            
            const wy = getTerrainHeight(wx, wz);
            g.position.set(wx, wy, wz);
            g.userData.startY = wy;
            scene.add(g);
            groundObjects.push(g);
            colliders.push({ x: wx, z: wz, r: 1.5 });
        }

        function createStonePaths() {
            const stoneMat = new THREE.MeshLambertMaterial({ color: 0x6a6a6a });
            
            // Path from center towards houses
            const pathPoints = [
                { x: 0, z: 10 }, { x: -5, z: 0 }, { x: -10, z: -10 },
                { x: -15, z: -12 }, { x: -20, z: -14 },
                { x: 5, z: 5 }, { x: 10, z: -5 }, { x: 12, z: -15 },
                { x: -3, z: -20 }, { x: -5, z: -30 }
            ];
            
            pathPoints.forEach(p => {
                // Create cluster of stones
                for (let i = 0; i < 5; i++) {
                    const ox = p.x + (Math.random() - 0.5) * 2;
                    const oz = p.z + (Math.random() - 0.5) * 2;
                    const stone = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.3 + Math.random() * 0.2, 0.35 + Math.random() * 0.2, 0.1, 6),
                        stoneMat
                    );
                    const sy = getTerrainHeight(ox, oz) + 0.05;
                    stone.position.set(ox, sy, oz);
                    stone.rotation.y = Math.random() * Math.PI;
                    stone.userData.startY = sy;
                    scene.add(stone);
                    groundObjects.push(stone);
                }
            });
        }

        function createHayBales() {
            const hayMat = new THREE.MeshLambertMaterial({ color: 0x9a8a50 });
            const positions = [
                { x: 25, z: -30 }, { x: 26, z: -32 }, { x: 27, z: -30 },
                { x: -35, z: -25 }, { x: -36, z: -27 }
            ];
            
            positions.forEach(p => {
                const bale = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.8, 0.8, 1.5, 12),
                    hayMat
                );
                const by = getTerrainHeight(p.x, p.z);
                bale.position.set(p.x, by + 0.4, p.z);
                bale.rotation.z = Math.PI / 2;
                bale.rotation.y = Math.random() * 0.5;
                bale.userData.startY = by + 0.4;
                scene.add(bale);
                groundObjects.push(bale);
            });
        }

        function createTree(type = 'pine') {
            const g = new THREE.Group();
            const trunkMat = new THREE.MeshLambertMaterial({ color: 0x4a3a2a });
            
            if (type === 'pine') {
                // Trunk
                const trunk = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.15, 0.25, 2.5),
                    trunkMat
                );
                trunk.position.y = 1.25;
                trunk.castShadow = true;
                g.add(trunk);

                // Layered foliage
                const foliageColors = [0x1a3a1a, 0x2a4a2a, 0x1a4a1a];
                for (let i = 0; i < 4; i++) {
                    const foliage = new THREE.Mesh(
                        new THREE.ConeGeometry(1.8 - i * 0.35, 1.8, 8),
                        new THREE.MeshLambertMaterial({ color: foliageColors[i % 3] })
                    );
                    foliage.position.y = 2.5 + i * 1.1;
                    foliage.castShadow = true;
                    g.add(foliage);
                }
            } else {
                // Oak tree - rounder
                const trunk = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.2, 0.35, 3),
                    trunkMat
                );
                trunk.position.y = 1.5;
                g.add(trunk);
                
                // Branches
                for (let i = 0; i < 3; i++) {
                    const branch = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.05, 0.08, 1.5),
                        trunkMat
                    );
                    branch.position.set(0.3, 2.5 + i * 0.5, 0);
                    branch.rotation.z = Math.PI / 4 + Math.random() * 0.3;
                    branch.rotation.y = i * Math.PI * 0.7;
                    g.add(branch);
                }
                
                // Round foliage clusters
                const foliageMat = new THREE.MeshLambertMaterial({ color: 0x2a5a2a });
                for (let i = 0; i < 6; i++) {
                    const foliage = new THREE.Mesh(
                        new THREE.SphereGeometry(1.2 + Math.random() * 0.5, 8, 8),
                        foliageMat
                    );
                    foliage.position.set(
                        (Math.random() - 0.5) * 1.5,
                        4 + Math.random() * 1.5,
                        (Math.random() - 0.5) * 1.5
                    );
                    g.add(foliage);
                }
            }
            return g;
        }

        function createFirefly(hasLight) {
            const g = new THREE.Group();
            if (hasLight) {
                const light = new THREE.PointLight(0xaaff66, 0.8, 10);
                g.add(light);
            }
            // Body
            const body = new THREE.Mesh(
                new THREE.SphereGeometry(0.04, 4, 4),
                new THREE.MeshBasicMaterial({ color: 0x333333 })
            );
            g.add(body);
            // Glow abdomen
            const glow = new THREE.Mesh(
                new THREE.SphereGeometry(0.08, 6, 6),
                new THREE.MeshBasicMaterial({ color: 0xccff66, transparent: true, opacity: 0.8 })
            );
            glow.position.z = -0.05;
            g.add(glow);
            return g;
        }

        function createStream() {
            const streamZ = 35;
            const streamWidth = 5;
            const segmentsX = 80;
            const segmentsZ = 4;
            
            // Create custom geometry that follows terrain
            const positions = [];
            const indices = [];
            const uvs = [];
            
            for (let iz = 0; iz <= segmentsZ; iz++) {
                for (let ix = 0; ix <= segmentsX; ix++) {
                    const x = (ix / segmentsX - 0.5) * 200;
                    const zOffset = (iz / segmentsZ - 0.5) * streamWidth;
                    const z = streamZ + zOffset;
                    const y = getTerrainHeight(x, z) + 0.08; // Slightly above terrain
                    
                    positions.push(x, y, z);
                    uvs.push(ix / segmentsX, iz / segmentsZ);
                }
            }
            
            // Create triangles
            for (let iz = 0; iz < segmentsZ; iz++) {
                for (let ix = 0; ix < segmentsX; ix++) {
                    const a = iz * (segmentsX + 1) + ix;
                    const b = a + 1;
                    const c = a + (segmentsX + 1);
                    const d = c + 1;
                    
                    indices.push(a, b, c);
                    indices.push(b, d, c);
                }
            }
            
            const streamGeo = new THREE.BufferGeometry();
            streamGeo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            streamGeo.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
            streamGeo.setIndex(indices);
            streamGeo.computeVertexNormals();
            
            const waterMat = new THREE.MeshBasicMaterial({
                color: 0x4a8ab0,
                transparent: true,
                opacity: 0.75,
                side: THREE.DoubleSide
            });
            
            streamMesh = new THREE.Mesh(streamGeo, waterMat);
            streamMesh.userData.startY = 0;
            streamMesh.userData.isStream = true;
            scene.add(streamMesh);
            groundObjects.push(streamMesh);
            window.streamZ = streamZ;
            
            // Add subtle surface shimmer layer
            const shimmerGeo = streamGeo.clone();
            const shimmerMat = new THREE.MeshBasicMaterial({
                color: 0x8ac0e0,
                transparent: true,
                opacity: 0.3,
                side: THREE.DoubleSide
            });
            const shimmer = new THREE.Mesh(shimmerGeo, shimmerMat);
            shimmer.position.y = 0.02;
            shimmer.userData.startY = 0.02;
            shimmer.userData.isShimmer = true;
            scene.add(shimmer);
            groundObjects.push(shimmer);
        }

        function createStreamDetails() {
            const streamZ = 35;
            const streamWidth = 5;
            
            // Stream banks with dirt/mud - follow terrain more closely
            const bankMat = new THREE.MeshLambertMaterial({ color: 0x5a4a3a });
            const darkBankMat = new THREE.MeshLambertMaterial({ color: 0x3a2a1a });
            
            for (let x = -100; x < 100; x += 2) {
                // North bank (closer to z=0)
                for (let i = 0; i < 3; i++) {
                    const bz = streamZ - streamWidth/2 - 0.3 - Math.random() * 0.8;
                    const bx = x + Math.random() * 1.5;
                    const by = getTerrainHeight(bx, bz);
                    
                    const bank = new THREE.Mesh(
                        new THREE.SphereGeometry(0.25 + Math.random() * 0.35, 6, 4),
                        i === 0 ? darkBankMat : bankMat
                    );
                    bank.position.set(bx, by + 0.05, bz);
                    bank.scale.set(1 + Math.random() * 0.5, 0.3, 1 + Math.random() * 0.3);
                    bank.userData.startY = by + 0.05;
                    scene.add(bank);
                    groundObjects.push(bank);
                }
                
                // South bank (farther from z=0)
                for (let i = 0; i < 3; i++) {
                    const bz = streamZ + streamWidth/2 + 0.3 + Math.random() * 0.8;
                    const bx = x + Math.random() * 1.5;
                    const by = getTerrainHeight(bx, bz);
                    
                    const bank = new THREE.Mesh(
                        new THREE.SphereGeometry(0.25 + Math.random() * 0.35, 6, 4),
                        i === 0 ? darkBankMat : bankMat
                    );
                    bank.position.set(bx, by + 0.05, bz);
                    bank.scale.set(1 + Math.random() * 0.5, 0.3, 1 + Math.random() * 0.3);
                    bank.userData.startY = by + 0.05;
                    scene.add(bank);
                    groundObjects.push(bank);
                }
            }
            
            // River rocks - in the stream
            const rockMat = new THREE.MeshLambertMaterial({ color: 0x6a6a7a });
            const wetRockMat = new THREE.MeshLambertMaterial({ color: 0x4a4a5a });
            for (let i = 0; i < 80; i++) {
                const rx = (Math.random() - 0.5) * 180;
                const rz = streamZ + (Math.random() - 0.5) * (streamWidth - 1);
                const ry = getTerrainHeight(rx, rz);
                
                const rock = new THREE.Mesh(
                    new THREE.DodecahedronGeometry(0.1 + Math.random() * 0.2, 0),
                    Math.random() > 0.5 ? rockMat : wetRockMat
                );
                rock.position.set(rx, ry + 0.05, rz);
                rock.rotation.set(Math.random(), Math.random(), Math.random());
                rock.scale.set(1, 0.6, 1);
                rock.userData.startY = ry + 0.05;
                scene.add(rock);
                groundObjects.push(rock);
            }
            
            // Larger stepping stones
            for (let i = 0; i < 15; i++) {
                const rx = (Math.random() - 0.5) * 160;
                if (Math.abs(rx) < 8) continue; // Skip near bridge
                const rz = streamZ + (Math.random() - 0.5) * 3;
                const ry = getTerrainHeight(rx, rz);
                
                const rock = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.3 + Math.random() * 0.2, 0.35 + Math.random() * 0.2, 0.15, 8),
                    rockMat
                );
                rock.position.set(rx, ry + 0.12, rz);
                rock.rotation.y = Math.random() * Math.PI;
                rock.userData.startY = ry + 0.12;
                scene.add(rock);
                groundObjects.push(rock);
            }
            
            // Cattails along stream banks
            const cattailPositions = [];
            for (let x = -90; x < 90; x += 6) {
                if (Math.abs(x) < 6) continue; // Skip near bridge
                // Add some randomness to positions
                cattailPositions.push({ x: x + Math.random() * 3, z: streamZ - streamWidth/2 - 0.5 });
                cattailPositions.push({ x: x + Math.random() * 3, z: streamZ + streamWidth/2 + 0.5 });
                // Sometimes add a cluster
                if (Math.random() > 0.6) {
                    cattailPositions.push({ x: x + 1 + Math.random() * 2, z: streamZ - streamWidth/2 - 0.8 });
                }
            }
            
            cattailPositions.forEach(p => {
                const cattail = createCattail();
                const cy = getTerrainHeight(p.x, p.z);
                cattail.position.set(p.x, cy, p.z);
                cattail.rotation.y = Math.random() * Math.PI * 2;
                cattail.userData.startY = cy;
                scene.add(cattail);
                groundObjects.push(cattail);
            });
            
            // Add some reeds/tall grass near water
            const reedMat = new THREE.MeshLambertMaterial({ color: 0x5a7a4a });
            for (let x = -95; x < 95; x += 4) {
                if (Math.abs(x) < 5) continue;
                for (let side = -1; side <= 1; side += 2) {
                    if (Math.random() > 0.7) continue;
                    const rz = streamZ + side * (streamWidth/2 + 0.2 + Math.random() * 0.5);
                    const rx = x + Math.random() * 2;
                    const ry = getTerrainHeight(rx, rz);
                    
                    const reedGroup = new THREE.Group();
                    for (let r = 0; r < 4; r++) {
                        const reed = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.01, 0.02, 0.8 + Math.random() * 0.4, 4),
                            reedMat
                        );
                        reed.position.set((Math.random() - 0.5) * 0.15, 0.4, (Math.random() - 0.5) * 0.15);
                        reed.rotation.x = (Math.random() - 0.5) * 0.3;
                        reed.rotation.z = (Math.random() - 0.5) * 0.3;
                        reedGroup.add(reed);
                    }
                    reedGroup.position.set(rx, ry, rz);
                    reedGroup.userData.startY = ry;
                    scene.add(reedGroup);
                    groundObjects.push(reedGroup);
                }
            }
        }

        function createCattail() {
            const g = new THREE.Group();
            const stemMat = new THREE.MeshLambertMaterial({ color: 0x4a6a3a });
            const headMat = new THREE.MeshLambertMaterial({ color: 0x5a4030 });
            
            // Multiple stems
            for (let i = 0; i < 3; i++) {
                const stem = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.02, 0.03, 1.5 + Math.random() * 0.5),
                    stemMat
                );
                stem.position.set((Math.random() - 0.5) * 0.2, 0.8, (Math.random() - 0.5) * 0.2);
                stem.rotation.x = (Math.random() - 0.5) * 0.2;
                stem.rotation.z = (Math.random() - 0.5) * 0.2;
                g.add(stem);
                
                // Cattail head
                const head = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.06, 0.06, 0.25, 8),
                    headMat
                );
                head.position.copy(stem.position);
                head.position.y += 0.9;
                g.add(head);
            }
            
            // Leaves
            for (let i = 0; i < 4; i++) {
                const leaf = new THREE.Mesh(
                    new THREE.BoxGeometry(0.08, 1.2, 0.01),
                    stemMat
                );
                leaf.position.set(0, 0.6, 0);
                leaf.rotation.y = i * Math.PI / 2;
                leaf.rotation.x = -0.3;
                g.add(leaf);
            }
            
            return g;
        }

        function createBridge() {
            const bridgeX = 0, bridgeZ = 35;
            const g = new THREE.Group();
            const woodMat = new THREE.MeshLambertMaterial({ color: 0x5a4030 });
            const ropeMat = new THREE.MeshLambertMaterial({ color: 0x8a7a5a });
            const darkWoodMat = new THREE.MeshLambertMaterial({ color: 0x3a2a1a });
            
            // Planks (now running across the stream)
            for (let i = 0; i < 14; i++) {
                const plank = new THREE.Mesh(new THREE.BoxGeometry(0.35, 0.1, 8), woodMat);
                plank.position.set(-2.5 + i * 0.38, 0, 0);
                plank.castShadow = true;
                g.add(plank);
            }
            
            // Support beams underneath
            const beam1 = new THREE.Mesh(new THREE.BoxGeometry(6, 0.15, 0.2), woodMat);
            beam1.position.set(0, -0.12, -3);
            g.add(beam1);
            const beam2 = new THREE.Mesh(new THREE.BoxGeometry(6, 0.15, 0.2), woodMat);
            beam2.position.set(0, -0.12, 3);
            g.add(beam2);
            
            // Support posts going down to the ground
            const supportPositions = [
                { x: -2.5, z: -3 }, { x: -2.5, z: 3 },
                { x: 2.5, z: -3 }, { x: 2.5, z: 3 }
            ];
            supportPositions.forEach(sp => {
                const supportPost = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.12, 0.15, 1.2),
                    darkWoodMat
                );
                supportPost.position.set(sp.x, -0.7, sp.z);
                g.add(supportPost);
            });
            
            // Cross braces
            const brace1 = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.08, 6.2), darkWoodMat);
            brace1.position.set(-2.5, -0.4, 0);
            brace1.rotation.x = 0.1;
            g.add(brace1);
            const brace2 = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.08, 6.2), darkWoodMat);
            brace2.position.set(2.5, -0.4, 0);
            brace2.rotation.x = -0.1;
            g.add(brace2);
            
            // Rope railings
            for (let side = -1; side <= 1; side += 2) {
                // Posts
                for (let i = -2; i <= 2; i++) {
                    const post = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.06, 0.08, 1),
                        woodMat
                    );
                    post.position.set(i * 1.2, 0.5, side * 3.8);
                    g.add(post);
                }
                // Rope
                const rope = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.03, 0.03, 5.5, 6),
                    ropeMat
                );
                rope.rotation.z = Math.PI / 2;
                rope.position.set(0, 0.9, side * 3.8);
                g.add(rope);
            }
            
            const bridgeY = getTerrainHeight(bridgeX, bridgeZ) + 0.8;
            g.position.set(bridgeX, bridgeY, bridgeZ);
            g.rotation.y = Math.PI / 2; // Rotate 90 degrees to span across stream
            g.userData.startY = bridgeY;
            scene.add(g);
            groundObjects.push(g);
            window.bridgeX = bridgeX;
            window.bridgeZ = bridgeZ;
            // After rotation: bridge is ~8 units long (Z direction becomes X), ~6 units wide (X becomes Z)
            window.bridgeHalfLength = 4; // half of 8
            window.bridgeHalfWidth = 3;  // half of 6
        }

        function createInstancedGrass() {
            const grassCount = 25000;
            
            // Tall grass
            const grassGeo = new THREE.ConeGeometry(0.02, 0.5, 4);
            const grassMat = new THREE.MeshLambertMaterial({ color: 0x3a5a3a, side: THREE.DoubleSide });
            const grassMesh = new THREE.InstancedMesh(grassGeo, grassMat, grassCount);
            const dummy = new THREE.Object3D();
            
            for (let i = 0; i < grassCount; i++) {
                const x = (Math.random() - 0.5) * 180;
                const z = (Math.random() - 0.5) * 180;
                // Skip stream area
                if (Math.abs(z - 35) < 4) continue;
                const y = getTerrainHeight(x, z);
                dummy.position.set(x, y + 0.25, z);
                dummy.rotation.set((Math.random() - 0.5) * 0.4, Math.random() * Math.PI * 2, (Math.random() - 0.5) * 0.3);
                dummy.scale.setScalar(0.8 + Math.random() * 0.6);
                dummy.updateMatrix();
                grassMesh.setMatrixAt(i, dummy.matrix);
            }
            grassMesh.userData.startY = 0;
            scene.add(grassMesh);
            groundObjects.push(grassMesh);
            
            // Short grass carpet
            const shortGrassCount = 20000;
            const shortGrassGeo = new THREE.ConeGeometry(0.015, 0.2, 3);
            const shortGrassMat = new THREE.MeshLambertMaterial({ color: 0x4a6a4a, side: THREE.DoubleSide });
            const shortGrassMesh = new THREE.InstancedMesh(shortGrassGeo, shortGrassMat, shortGrassCount);
            
            for (let i = 0; i < shortGrassCount; i++) {
                const x = (Math.random() - 0.5) * 180;
                const z = (Math.random() - 0.5) * 180;
                if (Math.abs(z - 35) < 4) continue;
                const y = getTerrainHeight(x, z);
                dummy.position.set(x, y + 0.1, z);
                dummy.rotation.set((Math.random() - 0.5) * 0.3, Math.random() * Math.PI * 2, 0);
                dummy.scale.setScalar(0.7 + Math.random() * 0.5);
                dummy.updateMatrix();
                shortGrassMesh.setMatrixAt(i, dummy.matrix);
            }
            shortGrassMesh.userData.startY = 0;
            scene.add(shortGrassMesh);
            groundObjects.push(shortGrassMesh);
        }

        function createWildflowers() {
            // Natural meadow flowers - mostly white daisies, small yellow buttercups, and grass tufts
            const flowerCount = 1500;
            
            for (let i = 0; i < flowerCount; i++) {
                const x = (Math.random() - 0.5) * 160;
                const z = (Math.random() - 0.5) * 160;
                if (Math.abs(z - 35) < 5) continue;
                
                const g = new THREE.Group();
                const stemMat = new THREE.MeshLambertMaterial({ color: 0x3a4a2a });
                
                const flowerType = Math.random();
                
                if (flowerType < 0.4) {
                    // White daisy
                    const stem = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.008, 0.012, 0.25 + Math.random() * 0.15),
                        stemMat
                    );
                    stem.position.y = 0.12;
                    g.add(stem);
                    
                    // Yellow center
                    const center = new THREE.Mesh(
                        new THREE.SphereGeometry(0.025, 6, 6),
                        new THREE.MeshLambertMaterial({ color: 0xccaa44 })
                    );
                    center.position.y = 0.28;
                    center.scale.y = 0.6;
                    g.add(center);
                    
                    // White petals
                    const petalMat = new THREE.MeshLambertMaterial({ color: 0xeeeeee });
                    for (let p = 0; p < 8; p++) {
                        const petal = new THREE.Mesh(
                            new THREE.SphereGeometry(0.018, 4, 4),
                            petalMat
                        );
                        const angle = (p / 8) * Math.PI * 2;
                        petal.position.set(Math.cos(angle) * 0.04, 0.28, Math.sin(angle) * 0.04);
                        petal.scale.set(1.5, 0.4, 1);
                        g.add(petal);
                    }
                } else if (flowerType < 0.6) {
                    // Small yellow buttercup
                    const stem = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.006, 0.01, 0.15 + Math.random() * 0.1),
                        stemMat
                    );
                    stem.position.y = 0.08;
                    g.add(stem);
                    
                    const head = new THREE.Mesh(
                        new THREE.SphereGeometry(0.02, 6, 6),
                        new THREE.MeshLambertMaterial({ color: 0xaaaa44 })
                    );
                    head.position.y = 0.18;
                    g.add(head);
                } else {
                    // Grass tuft / clover
                    for (let t = 0; t < 4; t++) {
                        const blade = new THREE.Mesh(
                            new THREE.ConeGeometry(0.012, 0.2 + Math.random() * 0.1, 3),
                            new THREE.MeshLambertMaterial({ color: 0x4a5a3a })
                        );
                        blade.position.set(
                            (Math.random() - 0.5) * 0.06,
                            0.1,
                            (Math.random() - 0.5) * 0.06
                        );
                        blade.rotation.x = (Math.random() - 0.5) * 0.4;
                        blade.rotation.z = (Math.random() - 0.5) * 0.4;
                        g.add(blade);
                    }
                }
                
                const fy = getTerrainHeight(x, z);
                g.position.set(x, fy, z);
                g.userData.startY = fy;
                g.scale.setScalar(0.8 + Math.random() * 0.4);
                scene.add(g);
                groundObjects.push(g);
            }
        }

        function createMushrooms() {
            const mushroomCount = 120;
            // Natural mushroom colors - browns, tans, grays
            const capColors = [0x8a7a6a, 0x6a5a4a, 0x7a6a5a, 0x9a8a7a, 0x5a4a3a, 0x8a8070];
            const stemColors = [0xddd8cc, 0xccc8bb, 0xbbb8aa];
            
            for (let i = 0; i < mushroomCount; i++) {
                const x = (Math.random() - 0.5) * 150;
                const z = (Math.random() - 0.5) * 150;
                
                const g = new THREE.Group();
                const stemMat = new THREE.MeshLambertMaterial({ 
                    color: stemColors[Math.floor(Math.random() * stemColors.length)]
                });
                const capMat = new THREE.MeshLambertMaterial({ 
                    color: capColors[Math.floor(Math.random() * capColors.length)]
                });
                
                const stemHeight = 0.08 + Math.random() * 0.12;
                const stem = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.025, 0.035, stemHeight, 6),
                    stemMat
                );
                stem.position.y = stemHeight / 2;
                g.add(stem);
                
                const capSize = 0.06 + Math.random() * 0.05;
                const cap = new THREE.Mesh(
                    new THREE.SphereGeometry(capSize, 8, 6, 0, Math.PI * 2, 0, Math.PI / 2),
                    capMat
                );
                cap.position.y = stemHeight;
                g.add(cap);
                
                const my = getTerrainHeight(x, z);
                g.position.set(x, my, z);
                g.userData.startY = my;
                scene.add(g);
                groundObjects.push(g);
            }
        }

        function createRocks() {
            const rockCount = 150;
            const rockMat = new THREE.MeshLambertMaterial({ color: 0x6a6a6a });
            
            for (let i = 0; i < rockCount; i++) {
                const x = (Math.random() - 0.5) * 160;
                const z = (Math.random() - 0.5) * 160;
                if (Math.abs(z - 35) < 5) continue;
                
                const rock = new THREE.Mesh(
                    new THREE.DodecahedronGeometry(0.2 + Math.random() * 0.5, 0),
                    rockMat
                );
                const ry = getTerrainHeight(x, z);
                rock.position.set(x, ry + 0.1, z);
                rock.rotation.set(Math.random(), Math.random(), Math.random());
                rock.scale.y = 0.5 + Math.random() * 0.5;
                rock.userData.startY = ry + 0.1;
                scene.add(rock);
                groundObjects.push(rock);
            }
        }

        function createBushes() {
            const bushCount = 100;
            
            for (let i = 0; i < bushCount; i++) {
                const x = (Math.random() - 0.5) * 150;
                const z = (Math.random() - 0.5) * 150;
                if (Math.abs(z - 35) < 6) continue;
                
                const g = new THREE.Group();
                const leafMat = new THREE.MeshLambertMaterial({ color: 0x2a4a2a });
                
                // Cluster of spheres
                for (let j = 0; j < 5; j++) {
                    const leaf = new THREE.Mesh(
                        new THREE.SphereGeometry(0.3 + Math.random() * 0.3, 6, 6),
                        leafMat
                    );
                    leaf.position.set(
                        (Math.random() - 0.5) * 0.5,
                        0.3 + Math.random() * 0.3,
                        (Math.random() - 0.5) * 0.5
                    );
                    g.add(leaf);
                }
                
                const by = getTerrainHeight(x, z);
                g.position.set(x, by, z);
                g.userData.startY = by;
                scene.add(g);
                groundObjects.push(g);
                colliders.push({ x, z, r: 0.8 });
            }
        }

        function createSky() {
            // More stars with varying sizes
            const starGeo = new THREE.BufferGeometry();
            const starPos = [];
            const starSizes = [];
            for (let i = 0; i < 3000; i++) {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI * 0.5;
                const r = 150;
                starPos.push(
                    r * Math.sin(phi) * Math.cos(theta),
                    r * Math.cos(phi) + 30,
                    r * Math.sin(phi) * Math.sin(theta)
                );
                starSizes.push(0.3 + Math.random() * 0.7);
            }
            starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPos, 3));
            starGeo.setAttribute('size', new THREE.Float32BufferAttribute(starSizes, 1));
            
            const starMat = new THREE.PointsMaterial({ 
                color: 0xffffff, 
                size: 0.5,
                transparent: true,
                opacity: 0.9,
                fog: false  // Stars ignore fog
            });
            const stars = new THREE.Points(starGeo, starMat);
            stars.name = 'stars';
            scene.add(stars);

            // Moon with craters
            const moonGroup = new THREE.Group();
            const moonMesh = new THREE.Mesh(
                new THREE.SphereGeometry(8, 32, 32),
                new THREE.MeshBasicMaterial({ color: 0xffffee, fog: false })
            );
            moonGroup.add(moonMesh);
            
            // Craters (dark spots)
            const craterMat = new THREE.MeshBasicMaterial({ color: 0xddddcc, fog: false });
            for (let i = 0; i < 5; i++) {
                const crater = new THREE.Mesh(
                    new THREE.CircleGeometry(1 + Math.random() * 1.5, 16),
                    craterMat
                );
                const angle1 = Math.random() * Math.PI * 0.6 - 0.3;
                const angle2 = Math.random() * Math.PI * 0.6 - 0.3;
                crater.position.set(
                    8.05 * Math.sin(angle1) * Math.cos(angle2),
                    8.05 * Math.sin(angle2),
                    8.05 * Math.cos(angle1) * Math.cos(angle2)
                );
                crater.lookAt(0, 0, 0);
                moonGroup.add(crater);
            }
            
            moonGroup.position.set(60, 80, -100);
            scene.add(moonGroup);
            
            // Moon glow
            const glowMesh = new THREE.Mesh(
                new THREE.SphereGeometry(12, 32, 32),
                new THREE.MeshBasicMaterial({ 
                    color: 0xffffee, 
                    transparent: true, 
                    opacity: 0.15,
                    fog: false
                })
            );
            glowMesh.position.copy(moonGroup.position);
            scene.add(glowMesh);
        }

        function createLanterns() {
            const positions = [
                { x: -8, z: 5 }, { x: 8, z: 5 }, { x: -5, z: -5 }, { x: 5, z: -5 },
                { x: -15, z: 0 }, { x: 15, z: 0 }, { x: 0, z: -10 },
                { x: -12, z: -8 }, { x: 12, z: -8 }
            ];
            positions.forEach(pos => {
                const g = new THREE.Group();
                const pole = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.04, 0.06, 2.2),
                    new THREE.MeshLambertMaterial({ color: 0x3a2a1a })
                );
                pole.position.y = 1.1;
                g.add(pole);
                
                // Lantern body with glass panels
                const frame = new THREE.Mesh(
                    new THREE.BoxGeometry(0.35, 0.45, 0.35),
                    new THREE.MeshLambertMaterial({ color: 0x2a2a2a })
                );
                frame.position.y = 2.4;
                g.add(frame);
                
                const glow = new THREE.Mesh(
                    new THREE.BoxGeometry(0.28, 0.38, 0.28),
                    new THREE.MeshBasicMaterial({ color: 0xffaa44, transparent: true, opacity: 0.9 })
                );
                glow.position.y = 2.4;
                g.add(glow);
                
                // Top cap
                const cap = new THREE.Mesh(
                    new THREE.ConeGeometry(0.25, 0.15, 4),
                    new THREE.MeshLambertMaterial({ color: 0x2a2a2a })
                );
                cap.position.y = 2.7;
                cap.rotation.y = Math.PI / 4;
                g.add(cap);
                
                const light = new THREE.PointLight(0xffaa44, 1.5, 18);
                light.position.y = 2.4;
                g.add(light);
                
                const ly = getTerrainHeight(pos.x, pos.z);
                g.position.set(pos.x, ly, pos.z);
                g.userData.startY = ly;
                scene.add(g);
                groundObjects.push(g);
            });
        }

        function createAnimals() {
            // Rabbits
            [{ x: -30, z: 10 }, { x: -25, z: 12 }, { x: 20, z: 8 }, { x: 35, z: -10 }].forEach(pos => {
                const rabbit = createRabbit();
                const ry = getTerrainHeight(pos.x, pos.z);
                rabbit.position.set(pos.x, ry, pos.z);
                rabbit.rotation.y = Math.random() * Math.PI * 2;
                rabbit.userData.startY = ry;
                rabbit.userData.animalType = 'rabbit';
                rabbit.userData.hopTimer = Math.random() * 100;
                rabbit.userData.baseY = ry;
                scene.add(rabbit);
                groundObjects.push(rabbit);
                animals.push(rabbit);
            });
            
            // Deer
            [{ x: -50, z: -20 }, { x: 45, z: 15 }].forEach(pos => {
                const deer = createDeer();
                const dy = getTerrainHeight(pos.x, pos.z);
                deer.position.set(pos.x, dy, pos.z);
                deer.rotation.y = Math.random() * Math.PI * 2;
                deer.userData.startY = dy;
                deer.userData.animalType = 'deer';
                scene.add(deer);
                groundObjects.push(deer);
                animals.push(deer);
            });
            
            // Owls in trees
            [{ x: -40, z: 5 }, { x: 30, z: -5 }, { x: -20, z: -50 }].forEach(pos => {
                const owl = createOwl();
                const oy = getTerrainHeight(pos.x, pos.z) + 4;
                owl.position.set(pos.x, oy, pos.z);
                owl.userData.startY = oy;
                owl.userData.animalType = 'owl';
                owl.userData.blinkTimer = Math.random() * 200;
                scene.add(owl);
                groundObjects.push(owl);
                animals.push(owl);
            });
            
            // Frogs near stream
            for (let i = 0; i < 8; i++) {
                const fx = (Math.random() - 0.5) * 150;
                if (Math.abs(fx) < 5) continue;
                const fz = 35 + (Math.random() - 0.5) * 8;
                const frog = createFrog();
                const fy = getTerrainHeight(fx, fz);
                frog.position.set(fx, fy, fz);
                frog.rotation.y = Math.random() * Math.PI * 2;
                frog.userData.startY = fy;
                frog.userData.animalType = 'frog';
                frog.userData.croakTimer = Math.random() * 300;
                scene.add(frog);
                groundObjects.push(frog);
                animals.push(frog);
            }
        }

        function createRabbit() {
            const g = new THREE.Group();
            const furMat = new THREE.MeshLambertMaterial({ color: 0x9a8a7a });
            const whiteMat = new THREE.MeshLambertMaterial({ color: 0xeeeeee });
            const pinkMat = new THREE.MeshLambertMaterial({ color: 0xffaaaa });
            
            // Body
            const body = new THREE.Mesh(
                new THREE.SphereGeometry(0.25, 8, 8),
                furMat
            );
            body.position.y = 0.2;
            body.scale.set(1, 0.8, 1.2);
            g.add(body);
            
            // Head
            const head = new THREE.Mesh(
                new THREE.SphereGeometry(0.15, 8, 8),
                furMat
            );
            head.position.set(0, 0.35, 0.25);
            g.add(head);
            
            // Ears
            for (let side = -1; side <= 1; side += 2) {
                const ear = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.02, 0.04, 0.25, 8),
                    furMat
                );
                ear.position.set(side * 0.08, 0.55, 0.2);
                ear.rotation.x = -0.2;
                ear.rotation.z = side * 0.2;
                g.add(ear);
                
                // Ear tip
                const earTip = new THREE.Mesh(
                    new THREE.SphereGeometry(0.025, 6, 6),
                    furMat
                );
                earTip.position.set(side * 0.08, 0.68, 0.18);
                g.add(earTip);
                
                // Inner ear
                const innerEar = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.01, 0.025, 0.18, 8),
                    pinkMat
                );
                innerEar.position.set(side * 0.08, 0.55, 0.22);
                innerEar.rotation.x = -0.2;
                innerEar.rotation.z = side * 0.2;
                g.add(innerEar);
            }
            
            // Eyes
            const eyeMat = new THREE.MeshBasicMaterial({ color: 0x111111 });
            for (let side = -1; side <= 1; side += 2) {
                const eye = new THREE.Mesh(new THREE.SphereGeometry(0.03), eyeMat);
                eye.position.set(side * 0.08, 0.38, 0.38);
                g.add(eye);
            }
            
            // Nose
            const nose = new THREE.Mesh(
                new THREE.SphereGeometry(0.025),
                pinkMat
            );
            nose.position.set(0, 0.32, 0.4);
            g.add(nose);
            
            // Tail
            const tail = new THREE.Mesh(
                new THREE.SphereGeometry(0.08, 6, 6),
                whiteMat
            );
            tail.position.set(0, 0.2, -0.3);
            g.add(tail);
            
            // Legs
            for (let i = 0; i < 4; i++) {
                const isBack = i >= 2;
                const side = i % 2 === 0 ? -1 : 1;
                const leg = new THREE.Mesh(
                    new THREE.SphereGeometry(isBack ? 0.08 : 0.05, 6, 6),
                    furMat
                );
                leg.position.set(side * 0.12, 0.05, isBack ? -0.15 : 0.15);
                leg.scale.y = isBack ? 1.3 : 1;
                g.add(leg);
            }
            
            g.scale.setScalar(0.8);
            return g;
        }

        function createDeer() {
            const g = new THREE.Group();
            const bodyMat = new THREE.MeshLambertMaterial({ color: 0x8a6a4a });
            const bellyMat = new THREE.MeshLambertMaterial({ color: 0xccaa88 });
            const antlerMat = new THREE.MeshLambertMaterial({ color: 0x5a4a3a });
            
            // Body
            const body = new THREE.Mesh(
                new THREE.SphereGeometry(0.5, 12, 12),
                bodyMat
            );
            body.position.y = 1;
            body.scale.set(1.8, 0.9, 0.9);
            g.add(body);
            
            // Belly
            const belly = new THREE.Mesh(
                new THREE.SphereGeometry(0.45, 12, 12),
                bellyMat
            );
            belly.position.set(0, 0.9, 0);
            belly.scale.set(1.5, 0.8, 0.8);
            g.add(belly);
            
            // Neck
            const neck = new THREE.Mesh(
                new THREE.CylinderGeometry(0.15, 0.2, 0.6),
                bodyMat
            );
            neck.position.set(0.6, 1.3, 0);
            neck.rotation.z = -0.5;
            g.add(neck);
            
            // Head
            const head = new THREE.Mesh(
                new THREE.SphereGeometry(0.2, 8, 8),
                bodyMat
            );
            head.position.set(0.85, 1.55, 0);
            head.scale.set(1, 0.9, 0.8);
            g.add(head);
            
            // Snout
            const snout = new THREE.Mesh(
                new THREE.CylinderGeometry(0.06, 0.08, 0.2, 8),
                bodyMat
            );
            snout.position.set(1.05, 1.48, 0);
            snout.rotation.z = Math.PI / 2;
            g.add(snout);
            
            // Nose
            const nose = new THREE.Mesh(
                new THREE.SphereGeometry(0.05),
                new THREE.MeshLambertMaterial({ color: 0x2a2a2a })
            );
            nose.position.set(1.15, 1.48, 0);
            g.add(nose);
            
            // Eyes
            const eyeMat = new THREE.MeshBasicMaterial({ color: 0x111111 });
            for (let side = -1; side <= 1; side += 2) {
                const eye = new THREE.Mesh(new THREE.SphereGeometry(0.04), eyeMat);
                eye.position.set(0.92, 1.6, side * 0.12);
                g.add(eye);
            }
            
            // Ears
            for (let side = -1; side <= 1; side += 2) {
                const ear = new THREE.Mesh(
                    new THREE.ConeGeometry(0.08, 0.15, 6),
                    bodyMat
                );
                ear.position.set(0.75, 1.7, side * 0.18);
                ear.rotation.x = side * 0.3;
                ear.rotation.z = -0.5;
                g.add(ear);
            }
            
            // Antlers
            for (let side = -1; side <= 1; side += 2) {
                const antlerBase = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.02, 0.03, 0.4),
                    antlerMat
                );
                antlerBase.position.set(0.8, 1.85, side * 0.1);
                antlerBase.rotation.z = side * 0.3;
                g.add(antlerBase);
                
                // Antler branches
                for (let b = 0; b < 2; b++) {
                    const branch = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.015, 0.02, 0.2),
                        antlerMat
                    );
                    branch.position.set(0.8 + b * 0.05, 2 + b * 0.1, side * (0.15 + b * 0.08));
                    branch.rotation.z = side * (0.5 + b * 0.3);
                    g.add(branch);
                }
            }
            
            // Legs
            const legPositions = [
                { x: 0.4, z: 0.15 }, { x: 0.4, z: -0.15 },
                { x: -0.4, z: 0.15 }, { x: -0.4, z: -0.15 }
            ];
            legPositions.forEach(lp => {
                const upperLeg = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.06, 0.08, 0.5),
                    bodyMat
                );
                upperLeg.position.set(lp.x, 0.6, lp.z);
                g.add(upperLeg);
                
                const lowerLeg = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.04, 0.05, 0.4),
                    bodyMat
                );
                lowerLeg.position.set(lp.x, 0.2, lp.z);
                g.add(lowerLeg);
                
                const hoof = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.05, 0.04, 0.08),
                    new THREE.MeshLambertMaterial({ color: 0x2a2a2a })
                );
                hoof.position.set(lp.x, 0.04, lp.z);
                g.add(hoof);
            });
            
            // Tail
            const tail = new THREE.Mesh(
                new THREE.ConeGeometry(0.06, 0.2, 6),
                bellyMat
            );
            tail.position.set(-0.7, 1.1, 0);
            tail.rotation.z = 0.5;
            g.add(tail);
            
            return g;
        }

        function createOwl() {
            const g = new THREE.Group();
            const featherMat = new THREE.MeshLambertMaterial({ color: 0x6a5a4a });
            const faceMat = new THREE.MeshLambertMaterial({ color: 0xaa9a8a });
            const beakMat = new THREE.MeshLambertMaterial({ color: 0xffaa44 });
            
            // Body
            const body = new THREE.Mesh(
                new THREE.SphereGeometry(0.3, 8, 8),
                featherMat
            );
            body.position.y = 0.3;
            body.scale.set(1, 1.3, 0.9);
            g.add(body);
            
            // Face disc
            const face = new THREE.Mesh(
                new THREE.CircleGeometry(0.22, 16),
                faceMat
            );
            face.position.set(0, 0.45, 0.25);
            g.add(face);
            
            // Eyes
            for (let side = -1; side <= 1; side += 2) {
                // Eye socket
                const socket = new THREE.Mesh(
                    new THREE.CircleGeometry(0.08, 12),
                    new THREE.MeshBasicMaterial({ color: 0x111111 })
                );
                socket.position.set(side * 0.1, 0.5, 0.26);
                g.add(socket);
                
                // Eye
                const eye = new THREE.Mesh(
                    new THREE.CircleGeometry(0.06, 12),
                    new THREE.MeshBasicMaterial({ color: 0xffcc00 })
                );
                eye.position.set(side * 0.1, 0.5, 0.27);
                eye.name = 'owlEye';
                g.add(eye);
                
                // Pupil
                const pupil = new THREE.Mesh(
                    new THREE.CircleGeometry(0.03, 8),
                    new THREE.MeshBasicMaterial({ color: 0x000000 })
                );
                pupil.position.set(side * 0.1, 0.5, 0.28);
                g.add(pupil);
            }
            
            // Beak
            const beak = new THREE.Mesh(
                new THREE.ConeGeometry(0.04, 0.08, 4),
                beakMat
            );
            beak.position.set(0, 0.4, 0.28);
            beak.rotation.x = Math.PI;
            g.add(beak);
            
            // Ear tufts
            for (let side = -1; side <= 1; side += 2) {
                const tuft = new THREE.Mesh(
                    new THREE.ConeGeometry(0.05, 0.15, 4),
                    featherMat
                );
                tuft.position.set(side * 0.15, 0.7, 0.1);
                tuft.rotation.z = side * -0.3;
                g.add(tuft);
            }
            
            // Wings
            for (let side = -1; side <= 1; side += 2) {
                const wing = new THREE.Mesh(
                    new THREE.SphereGeometry(0.2, 6, 6),
                    featherMat
                );
                wing.position.set(side * 0.25, 0.3, 0);
                wing.scale.set(0.5, 1.2, 0.8);
                g.add(wing);
            }
            
            // Feet
            const feetMat = new THREE.MeshLambertMaterial({ color: 0x5a5a5a });
            for (let side = -1; side <= 1; side += 2) {
                const foot = new THREE.Mesh(
                    new THREE.BoxGeometry(0.08, 0.04, 0.12),
                    feetMat
                );
                foot.position.set(side * 0.08, 0, 0.05);
                g.add(foot);
            }
            
            g.scale.setScalar(0.7);
            return g;
        }

        function createFrog() {
            const g = new THREE.Group();
            const skinMat = new THREE.MeshLambertMaterial({ color: 0x4a8a4a });
            const bellyMat = new THREE.MeshLambertMaterial({ color: 0x8aba8a });
            
            // Body
            const body = new THREE.Mesh(
                new THREE.SphereGeometry(0.15, 8, 8),
                skinMat
            );
            body.position.y = 0.1;
            body.scale.set(1, 0.7, 1.2);
            g.add(body);
            
            // Head
            const head = new THREE.Mesh(
                new THREE.SphereGeometry(0.12, 8, 8),
                skinMat
            );
            head.position.set(0, 0.12, 0.15);
            head.scale.set(1.2, 0.8, 1);
            g.add(head);
            
            // Eyes (bulging)
            for (let side = -1; side <= 1; side += 2) {
                const eyeBulge = new THREE.Mesh(
                    new THREE.SphereGeometry(0.05, 8, 8),
                    skinMat
                );
                eyeBulge.position.set(side * 0.08, 0.2, 0.18);
                g.add(eyeBulge);
                
                const eye = new THREE.Mesh(
                    new THREE.SphereGeometry(0.03, 8, 8),
                    new THREE.MeshBasicMaterial({ color: 0xffcc00 })
                );
                eye.position.set(side * 0.08, 0.22, 0.2);
                g.add(eye);
                
                const pupil = new THREE.Mesh(
                    new THREE.SphereGeometry(0.015, 6, 6),
                    new THREE.MeshBasicMaterial({ color: 0x000000 })
                );
                pupil.position.set(side * 0.08, 0.22, 0.22);
                g.add(pupil);
            }
            
            // Back legs
            for (let side = -1; side <= 1; side += 2) {
                const thigh = new THREE.Mesh(
                    new THREE.SphereGeometry(0.06, 6, 6),
                    skinMat
                );
                thigh.position.set(side * 0.12, 0.08, -0.1);
                thigh.scale.set(0.8, 1, 1.5);
                g.add(thigh);
                
                const shin = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.02, 0.025, 0.12, 6),
                    skinMat
                );
                shin.position.set(side * 0.18, 0.04, -0.08);
                shin.rotation.z = side * 0.8;
                g.add(shin);
                
                const foot = new THREE.Mesh(
                    new THREE.BoxGeometry(0.08, 0.02, 0.1),
                    skinMat
                );
                foot.position.set(side * 0.22, 0.01, -0.05);
                g.add(foot);
            }
            
            // Front legs
            for (let side = -1; side <= 1; side += 2) {
                const arm = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.015, 0.02, 0.1, 6),
                    skinMat
                );
                arm.position.set(side * 0.1, 0.05, 0.12);
                arm.rotation.z = side * 0.5;
                g.add(arm);
            }
            
            g.scale.setScalar(0.6);
            return g;
        }

        function startFalling() {
            if (State.phase === 'falling') return;
            State.phase = 'falling';
            State.canMove = false;
            State.keys = { w: false, a: false, s: false, d: false };
            State.velocity.set(0, 0, 0);
            targetPitch = 0;
            hidePrompt();
            colliders = [];
            fallProgress = 0;
            
            // Check off lookup task
            const task = document.getElementById('task-dream-lookup');
            task.classList.add('completed');
            task.querySelector('.checkbox').textContent = '‚úì';
        }

        function updateFalling(dt) {
            fallProgress += dt * 0.15;
            const fallDist = fallProgress * fallProgress * 8;
            groundObjects.forEach(obj => { obj.position.y = (obj.userData.startY || 0) - fallDist; });
            houseObjects.forEach(obj => { obj.position.y = (obj.userData.startY || 0) - fallDist; });
            if (scene.fog) scene.fog.density = Math.max(0, 0.008 - fallProgress * 0.002);
            if (fallProgress > 4) {
                groundObjects.forEach(obj => scene.remove(obj));
                houseObjects.forEach(obj => scene.remove(obj));
                groundObjects = [];
                houseObjects = [];
                animals = [];
                scene.fog = null;
                State.phase = 'floating';
                setTimeout(() => startStarDrawing(), 4000);
            }
        }

        function startStarDrawing() {
            State.phase = 'drawing';
            State.canMove = false;
            State.canLook = false;
            document.exitPointerLock();
            document.body.style.cursor = 'crosshair';
            showPrompt('Click to create stars in space');
            setTimeout(hidePrompt, 4000);
            
        }

        function addStar3D(screenX, screenY) {
            const ndcX = (screenX / window.innerWidth) * 2 - 1;
            const ndcY = -(screenY / window.innerHeight) * 2 + 1;
            
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera({ x: ndcX, y: ndcY }, camera);
            
            const distance = 10 + Math.random() * 290;
            
            const starPos = new THREE.Vector3();
            raycaster.ray.at(distance, starPos);
            
            const baseSize = 0.1 + Math.random() * 0.15;
            const size = baseSize * (1 + distance / 100);
            
            const colors = [0xffffee, 0xffffff, 0xffff66, 0xffffaa, 0xffcc44, 0xffee88];
            const starColor = colors[Math.floor(Math.random() * colors.length)];
            
            const star = new THREE.Mesh(
                new THREE.SphereGeometry(size, 8, 8),
                new THREE.MeshBasicMaterial({ color: starColor, transparent: true, opacity: 0.9 })
            );
            star.position.copy(starPos);
            scene.add(star);
            
            if (Math.random() < 0.2) {
                const light = new THREE.PointLight(starColor, 0.4, 15 + distance / 10);
                light.position.copy(starPos);
                scene.add(light);
            }
            
            star.userData.phase = Math.random() * Math.PI * 2;
            star.userData.twinkleSpeed = 2 + Math.random() * 3;
            stars2D.push(star);
            
            State.starCount++;
            document.getElementById('star-counter').textContent = State.starCount;
            playTwinkle();
            
            // Check off stars task when all 30 stars drawn
            if (State.starCount >= 30) {
                const task = document.getElementById('task-dream-stars');
                if (!task.classList.contains('completed')) {
                    task.classList.add('completed');
                    task.querySelector('.checkbox').textContent = '‚úì';
                }
            }
            
            if (State.starCount >= 30 && State.phase === 'drawing') {
                // Stop countryside audio when all stars drawn
                const countrysideAudio = document.getElementById('audio-countryside');
                if (countrysideAudio) {
                    countrysideAudio.pause();
                    countrysideAudio.currentTime = 0;
                }
                setTimeout(startSheepTransformation, 500);
            }
        }
        
        function startSheepTransformation() {
            State.phase = 'transforming';
            hidePrompt();
            
            // Blink transition - flash white
            scene.background = new THREE.Color(0xffffff);
            
            setTimeout(() => {
                // After blink, transform stars to sheep
                transformStarsToSheep();
            }, 150);
        }
        
        function transformStarsToSheep() {
            hidePrompt();
            
            // Collect all positions before removing objects
            const allPositions = [];
            
            // Get user-drawn star positions
            console.log('Stars drawn:', stars2D.length);
            stars2D.forEach(star => {
                allPositions.push(star.position.clone());
            });
            
            // Get firefly positions
            console.log('Fireflies:', fireflies.length);
            fireflies.forEach(ff => {
                allPositions.push(ff.position.clone());
            });
            
            console.log('Total positions for sheep:', allPositions.length);
            
            // Remove stars
            stars2D.forEach(star => scene.remove(star));
            stars2D = [];
            
            // Remove fireflies
            fireflies.forEach(ff => scene.remove(ff));
            fireflies = [];
            
            // Set up sheep field environment
            scene.background = new THREE.Color(0x1a2a1a);
            scene.fog = new THREE.FogExp2(0x1a2a1a, 0.008);  // Reduced fog
            
            // Extend camera far plane to see falling sheep
            camera.far = 200;
            camera.updateProjectionMatrix();
            
            // Add lighting for sheep
            scene.add(new THREE.AmbientLight(0x6a8a6a, 1.0));  // Brighter ambient
            const light1 = new THREE.DirectionalLight(0xffffee, 0.8);
            light1.position.set(50, 80, 50);
            scene.add(light1);
            const light2 = new THREE.DirectionalLight(0x8a8aaa, 0.4);
            light2.position.set(-50, 30, -50);
            scene.add(light2);
            
            // Create grass plane
            const grassGeo = new THREE.PlaneGeometry(200, 200, 50, 50);
            const grassMat = new THREE.MeshLambertMaterial({ color: 0x3a6a3a });
            
            // Add slight variation to grass
            const grassVerts = grassGeo.attributes.position.array;
            for (let i = 0; i < grassVerts.length; i += 3) {
                grassVerts[i + 2] = (Math.random() - 0.5) * 0.3;
            }
            grassGeo.attributes.position.needsUpdate = true;
            grassGeo.computeVertexNormals();
            
            const grassPlane = new THREE.Mesh(grassGeo, grassMat);
            grassPlane.rotation.x = -Math.PI / 2;
            grassPlane.position.y = 0;
            scene.add(grassPlane);
            
            // Add some grass clumps for visual interest
            const clumpMat = new THREE.MeshLambertMaterial({ color: 0x4a8a4a });
            for (let i = 0; i < 100; i++) {
                const clump = new THREE.Mesh(
                    new THREE.ConeGeometry(0.3, 0.6, 4),
                    clumpMat
                );
                clump.position.set(
                    (Math.random() - 0.5) * 180,
                    0.3,
                    (Math.random() - 0.5) * 180
                );
                clump.rotation.y = Math.random() * Math.PI;
                scene.add(clump);
            }
            
            camera.fov = 75;
            camera.updateProjectionMatrix();
            camera.position.set(0, 1.7, 30);
            cameraYaw = Math.PI;
            cameraPitch = 0;
            updateCamera();
            
            colliders = [];
            chaserSheep = null;
            
            // Create sheep - spawn at random positions in the sky above the field
            sheep = [];
            sheepDebugFrames = 0;  // Reset debug counter
            const numSheep = Math.max(30, allPositions.length);  // At least 30 sheep
            
            for (let i = 0; i < numSheep; i++) {
                const s = createSheep3D();
                // Start high in the sky above the grass field
                s.position.set(
                    (Math.random() - 0.5) * 100,
                    20 + Math.random() * 25,  // 20-45 units high
                    (Math.random() - 0.5) * 100
                );
                s.rotation.y = Math.random() * Math.PI * 2;
                // Falling velocity - must have negative Y!
                s.userData.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.02,
                    -0.2 - Math.random() * 0.15,  // Fall down: -0.2 to -0.35
                    (Math.random() - 0.5) * 0.02
                );
                s.userData.turnTimer = 20 + Math.random() * 40;
                s.userData.legPhase = Math.random() * Math.PI * 2;
                s.userData.onGround = false;
                s.userData.isChaser = false;
                scene.add(s);
                sheep.push(s);
            }
            console.log('Sheep created:', sheep.length, '- First sheep y:', sheep[0]?.position.y.toFixed(2), 
                        'vel.y:', sheep[0]?.userData.velocity.y.toFixed(3));
            
            // Spawn ONE chaser sheep after 15 seconds
            setTimeout(() => {
                if (State.phase === 'sheep' && !State.caught && !chaserSheep) {
                    spawnChaserSheep();
                }
            }, 15000);
            
            // Immediately enter sheep phase
            State.phase = 'sheep';
            State.canMove = true;
            State.canLook = true;
            State.canInteract = false;  // No bed/switch interactions in dream
            
            // Start sheep audio
            const sheepAudio = document.getElementById('audio-sheep');
            if (sheepAudio) {
                sheepAudio.volume = 0.5;
                sheepAudio.play().catch(e => console.log('Audio play failed:', e));
            }
            
            // Hide dream checklist, show sheep checklist
            document.getElementById('dream-checklist').classList.remove('visible');
            document.getElementById('sheep-checklist').classList.add('visible');
            
            if (document.getElementById('scene-indicator')) {
                document.getElementById('scene-indicator').style.display = 'none';
            }
            
            // Auto-request pointer lock after delay
            setTimeout(() => {
                document.body.requestPointerLock();
            }, 2000);
        }
        
        function spawnChaserSheep() {
            // Only spawn if no chaser exists
            if (chaserSheep) return;

            const s = createSheep3D();
            // Spawn behind the player on the ground
            const spawnAngle = cameraYaw + Math.PI;
            const spawnDist = 50;
            s.position.set(
                camera.position.x + Math.sin(spawnAngle) * spawnDist,
                0.8,  // On ground (bigger sheep)
                camera.position.z + Math.cos(spawnAngle) * spawnDist
            );
            s.userData.onGround = true;
            s.rotation.y = Math.random() * Math.PI * 2;
            s.userData.velocity = new THREE.Vector3(0, 0, 0);
            s.userData.legPhase = 0;
            s.userData.isChaser = true;
            s.scale.setScalar(3);  // BIG sheep!
            
            // Make chaser sheep red-tinted
            s.traverse(child => {
                if (child.isMesh && child.material.color) {
                    if (child.material.color.getHex() === 0xf5f5f0) {
                        child.material = child.material.clone();
                        child.material.color.setHex(0xffdddd);
                    }
                }
            });
            
            scene.add(s);
            sheep.push(s);
            chaserSheep = s;
        }
        
        function createSheep3D() {
            const g = new THREE.Group();
            const woolMat = new THREE.MeshLambertMaterial({ color: 0xf5f5f0 });
            const faceMat = new THREE.MeshLambertMaterial({ color: 0x3a3a3a });
            
            const body = new THREE.Mesh(new THREE.SphereGeometry(0.4, 8, 8), woolMat);
            body.position.y = 0.4;
            body.scale.set(1.2, 1, 1);
            g.add(body);
            
            for (let i = 0; i < 5; i++) {
                const fluff = new THREE.Mesh(new THREE.SphereGeometry(0.2, 6, 6), woolMat);
                fluff.position.set(
                    (Math.random() - 0.5) * 0.3,
                    0.4 + (Math.random() - 0.5) * 0.2,
                    (Math.random() - 0.5) * 0.3
                );
                g.add(fluff);
            }
            
            const head = new THREE.Mesh(new THREE.SphereGeometry(0.2, 8, 8), faceMat);
            head.position.set(0.5, 0.5, 0);
            g.add(head);
            
            const eyeMat = new THREE.MeshBasicMaterial({ color: 0x111111 });
            const eye1 = new THREE.Mesh(new THREE.SphereGeometry(0.05), eyeMat);
            eye1.position.set(0.65, 0.55, 0.1);
            g.add(eye1);
            const eye2 = new THREE.Mesh(new THREE.SphereGeometry(0.05), eyeMat);
            eye2.position.set(0.65, 0.55, -0.1);
            g.add(eye2);
            
            const ear1 = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.06, 0.15), faceMat);
            ear1.position.set(0.4, 0.6, 0.2);
            g.add(ear1);
            const ear2 = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.06, 0.15), faceMat);
            ear2.position.set(0.4, 0.6, -0.2);
            g.add(ear2);
            
            const legGeo = new THREE.CylinderGeometry(0.05, 0.05, 0.4);
            const leg1 = new THREE.Mesh(legGeo, faceMat);
            leg1.position.set(0.2, 0.2, 0.15);
            leg1.name = 'frontLeft';
            g.add(leg1);
            const leg2 = new THREE.Mesh(legGeo, faceMat);
            leg2.position.set(0.2, 0.2, -0.15);
            leg2.name = 'frontRight';
            g.add(leg2);
            const leg3 = new THREE.Mesh(legGeo, faceMat);
            leg3.position.set(-0.2, 0.2, 0.15);
            leg3.name = 'backLeft';
            g.add(leg3);
            const leg4 = new THREE.Mesh(legGeo, faceMat);
            leg4.position.set(-0.2, 0.2, -0.15);
            leg4.name = 'backRight';
            g.add(leg4);
            
            const tail = new THREE.Mesh(new THREE.SphereGeometry(0.1), woolMat);
            tail.position.set(-0.45, 0.4, 0);
            g.add(tail);
            
            return g;
        }
        
        function updateSheep(dt, time) {
            // Count sheep on ground for checklist
            let groundedCount = 0;
            
            sheep.forEach((s, idx) => {
                // Skip if no userData
                if (!s.userData || !s.userData.velocity) {
                    return;
                }
                
                if (s.userData.onGround && !s.userData.isChaser) {
                    groundedCount++;
                }
                
                // Animate legs based on movement
                const legSpeed = s.userData.onGround ? 5 : 0;
                const phase = (s.userData.legPhase || 0) + time * legSpeed;
                s.children.forEach(child => {
                    if (child.name === 'frontLeft' || child.name === 'backRight') {
                        child.rotation.x = Math.sin(phase) * 0.3;
                    } else if (child.name === 'frontRight' || child.name === 'backLeft') {
                        child.rotation.x = Math.sin(phase + Math.PI) * 0.3;
                    }
                });
                
                if (s.userData.isChaser) {
                    // BIG chaser sheep follows player on ground
                    const dx = camera.position.x - s.position.x;
                    const dz = camera.position.z - s.position.z;
                    const dist = Math.sqrt(dx * dx + dz * dz);
                    
                    // Look at player
                    s.rotation.y = Math.atan2(dx, dz) - Math.PI / 2;
                    s.rotation.x = 0;
                    s.rotation.z = 0;
                    
                    if (dist < 4 && !State.caught) {  // Bigger catch radius
                        State.caught = true;
                        sheepCaughtPlayer();
                    }
                    
                    // Move towards player on ground - faster!
                    if (dist > 1) {
                        const speed = 0.18;
                        s.position.x += (dx / dist) * speed;
                        s.position.z += (dz / dist) * speed;
                    }
                    s.position.y = 1.2;  // Bigger sheep sits higher
                } else {
                    // Non-chaser sheep behavior
                    if (!s.userData.onGround) {
                        // Falling - apply gravity
                        s.userData.velocity.y -= 0.015;  // Stronger gravity
                        
                        // Apply velocity
                        s.position.x += s.userData.velocity.x;
                        s.position.y += s.userData.velocity.y;
                        s.position.z += s.userData.velocity.z;
                        
                        // Tumble while falling
                        s.rotation.x += 0.03;
                        s.rotation.z += 0.02;
                        
                        // Check if landed
                        if (s.position.y <= 0.4) {
                            s.position.y = 0.4;
                            s.userData.onGround = true;
                            s.userData.velocity.x = (Math.random() - 0.5) * 0.03;
                            s.userData.velocity.y = 0;
                            s.userData.velocity.z = (Math.random() - 0.5) * 0.03;
                            s.rotation.x = 0;
                            s.rotation.z = 0;
                        }
                    } else {
                        // Walking on ground
                        s.userData.turnTimer -= dt * 60;
                        if (s.userData.turnTimer <= 0) {
                            s.userData.turnTimer = 60 + Math.random() * 120;
                            s.userData.velocity.set(
                                (Math.random() - 0.5) * 0.03,
                                0,
                                (Math.random() - 0.5) * 0.03
                            );
                        }
                        
                        // Apply velocity on ground
                        s.position.x += s.userData.velocity.x;
                        s.position.z += s.userData.velocity.z;
                        s.position.y = 0.4;  // Stay on ground
                        
                        // Face direction of movement
                        const vLen = Math.sqrt(s.userData.velocity.x ** 2 + s.userData.velocity.z ** 2);
                        if (vLen > 0.005) {
                            s.rotation.y = Math.atan2(s.userData.velocity.x, s.userData.velocity.z) - Math.PI / 2;
                        }
                        
                        // Keep sheep in bounds
                        if (Math.abs(s.position.x) > 90) {
                            s.userData.velocity.x *= -1;
                            s.position.x = Math.sign(s.position.x) * 90;
                        }
                        if (Math.abs(s.position.z) > 90) {
                            s.userData.velocity.z *= -1;
                            s.position.z = Math.sign(s.position.z) * 90;
                        }
                        
                        s.rotation.x = 0;
                        s.rotation.z = 0;
                    }
                }
            });
            
            // Check off sheep count task when enough have landed
            if (groundedCount >= 10) {
                const task = document.getElementById('task-sheep-count');
                if (task && !task.classList.contains('completed')) {
                    task.classList.add('completed');
                    task.querySelector('.checkbox').textContent = '‚úì';
                }
            }
        }
        
        function sheepCaughtPlayer() {
            // Stop sheep audio when caught
            const sheepAudio = document.getElementById('audio-sheep');
            if (sheepAudio) {
                sheepAudio.pause();
                sheepAudio.currentTime = 0;
            }

            State.canMove = false;
            State.canLook = false;

            // Check off escape task
            const task = document.getElementById('task-sheep-escape');
            task.classList.add('completed');
            task.querySelector('.checkbox').textContent = '‚úì';
            
            // Hide sheep checklist
            setTimeout(() => {
                document.getElementById('sheep-checklist').classList.remove('visible');
            }, 500);
            
            // White flash
            scene.background = new THREE.Color(0xffffff);
            
            // Fade to black then load ocean scene
            setTimeout(() => {
                document.getElementById('fade-overlay').classList.add('visible');
                
                // Remove all sheep
                sheep.forEach(s => scene.remove(s));
                sheep = [];
                chaserSheep = null;
                
                setTimeout(() => {
                    loadOceanScene();
                }, 1000);
            }, 800);
        }

        // ============ OCEAN STORM SCENE ============
        
        function loadOceanScene() {
            // Clear existing scene
            while(scene.children.length > 0) { 
                scene.remove(scene.children[0]); 
            }
            
            isOceanScene = true;
            isDreamScene = false;
            State.phase = 'ocean_calm';
            oceanPhase = 'calm';
            oceanTime = 0;
            stormIntensity = 0;
            waveAmplitude = 0.5;
            
            // Dark blue sky initially
            scene.background = new THREE.Color(0x1a2a3a);
            scene.fog = new THREE.FogExp2(0x1a2a3a, 0.008);
            
            // Lighting
            const ambient = new THREE.AmbientLight(0x4a5a6a, 0.4);
            ambient.name = 'oceanAmbient';
            scene.add(ambient);
            
            const moonLight = new THREE.DirectionalLight(0x6a7a9a, 0.3);
            moonLight.position.set(50, 80, -50);
            moonLight.name = 'moonLight';
            scene.add(moonLight);
            
            // Create ocean
            createOcean();
            
            // Create boat with player on it
            createBoat();
            
            // Create storm clouds (initially hidden/transparent)
            createStormClouds();
            
            // Lighthouse will be created during storm - not at start!
            lighthouseGroup = null;
            lighthouseBeam = null;
            
            // Create lightning flash (hidden)
            createLightning();
            
            // Create rain (hidden initially)
            createRain();
            
            // Position camera on boat (center of deck, standing position)
            // Deck is at y=1.6 in boat group, boat group at y=1.2, so deck world = 2.8
            // Eye level 1.7 above deck = 4.5
            camera.position.set(0, 4.5, 1);  // Slightly forward of center to see bow
            cameraYaw = Math.PI;  // Facing toward lighthouse (negative Z)
            cameraPitch = 0;
            camera.far = 500;
            camera.updateProjectionMatrix();
            scene.add(camera);
            
            State.canMove = false;
            State.canLook = true;
            
            // Show ocean checklist
            document.getElementById('ocean-checklist').classList.add('visible');
            
            // Start waves audio
            const wavesAudio = document.getElementById('audio-waves');
            if (wavesAudio) {
                wavesAudio.volume = 0.5;
                wavesAudio.play().catch(e => console.log('Audio play failed:', e));
            }
            
            // Fade in
            setTimeout(() => {
                document.getElementById('fade-overlay').classList.remove('visible');
                
                // Start storm sequence after a delay
                setTimeout(() => {
                    oceanPhase = 'storm_building';
                }, 12000);
            }, 500);
        }
        
        function createOcean() {
            const oceanGeo = new THREE.PlaneGeometry(400, 400, 100, 100);
            const oceanMat = new THREE.MeshPhongMaterial({ 
                color: 0x1a4a6a,
                shininess: 100,
                transparent: true,
                opacity: 0.9
            });
            
            oceanMesh = new THREE.Mesh(oceanGeo, oceanMat);
            oceanMesh.rotation.x = -Math.PI / 2;
            oceanMesh.position.y = 0;
            scene.add(oceanMesh);
            
            // Add foam layer
            const foamGeo = new THREE.PlaneGeometry(400, 400, 50, 50);
            const foamMat = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.1
            });
            const foam = new THREE.Mesh(foamGeo, foamMat);
            foam.rotation.x = -Math.PI / 2;
            foam.position.y = 0.1;
            foam.name = 'oceanFoam';
            scene.add(foam);
        }
        
        function createBoat() {
            boatGroup = new THREE.Group();
            
            const woodMat = new THREE.MeshLambertMaterial({ color: 0x5a4030 });
            const darkWoodMat = new THREE.MeshLambertMaterial({ color: 0x3a2a20 });
            const hullMat = new THREE.MeshLambertMaterial({ color: 0x4a3525 });
            
            // Hull - simple box shape sitting above water
            const hullGeo = new THREE.BoxGeometry(5, 1.5, 10);
            const hull = new THREE.Mesh(hullGeo, hullMat);
            hull.position.y = 0.75;
            boatGroup.add(hull);
            
            // Hull bottom (tapered)
            const keelGeo = new THREE.BoxGeometry(3, 0.5, 8);
            const keel = new THREE.Mesh(keelGeo, hullMat);
            keel.position.y = 0;
            boatGroup.add(keel);
            
            // Bow (front) - triangular
            const bowGeo = new THREE.ConeGeometry(2.5, 3, 4);
            const bow = new THREE.Mesh(bowGeo, hullMat);
            bow.rotation.x = Math.PI / 2;
            bow.rotation.z = Math.PI / 4;
            bow.position.set(0, 0.75, -6);
            boatGroup.add(bow);
            
            // Stern (back)
            const sternGeo = new THREE.BoxGeometry(5, 2, 0.3);
            const stern = new THREE.Mesh(sternGeo, darkWoodMat);
            stern.position.set(0, 1, 5);
            boatGroup.add(stern);
            
            // Deck
            const deckGeo = new THREE.BoxGeometry(4.8, 0.2, 9);
            const deck = new THREE.Mesh(deckGeo, woodMat);
            deck.position.y = 1.6;
            boatGroup.add(deck);
            
            // Deck planks (visual detail)
            for (let i = -4; i <= 4; i++) {
                const plankGeo = new THREE.BoxGeometry(4.6, 0.05, 0.15);
                const plank = new THREE.Mesh(plankGeo, darkWoodMat);
                plank.position.set(0, 1.73, i);
                boatGroup.add(plank);
            }
            
            // Mast
            const mastGeo = new THREE.CylinderGeometry(0.12, 0.18, 10, 8);
            const mast = new THREE.Mesh(mastGeo, darkWoodMat);
            mast.position.set(0, 6.7, -1);
            boatGroup.add(mast);
            
            // Cross beam
            const beamGeo = new THREE.CylinderGeometry(0.08, 0.08, 5, 6);
            const beam = new THREE.Mesh(beamGeo, darkWoodMat);
            beam.rotation.z = Math.PI / 2;
            beam.position.set(0, 9, -1);
            boatGroup.add(beam);
            
            // Sail
            const sailGeo = new THREE.PlaneGeometry(4.5, 6, 8, 8);
            const sailMat = new THREE.MeshLambertMaterial({ 
                color: 0xddddcc, 
                side: THREE.DoubleSide 
            });
            const sail = new THREE.Mesh(sailGeo, sailMat);
            sail.position.set(0, 7.5, -1);
            sail.name = 'sail';
            boatGroup.add(sail);
            
            // Railing - left side
            const railMat = new THREE.MeshLambertMaterial({ color: 0x3a2a1a });
            for (let i = -3; i <= 3; i++) {
                const postGeo = new THREE.CylinderGeometry(0.04, 0.04, 1, 6);
                const postL = new THREE.Mesh(postGeo, railMat);
                postL.position.set(-2.2, 2.2, i * 1.2);
                boatGroup.add(postL);
                const postR = new THREE.Mesh(postGeo, railMat);
                postR.position.set(2.2, 2.2, i * 1.2);
                boatGroup.add(postR);
            }
            
            // Railing top rails
            const topRailGeo = new THREE.BoxGeometry(0.06, 0.06, 8);
            const topRailL = new THREE.Mesh(topRailGeo, railMat);
            topRailL.position.set(-2.2, 2.7, 0);
            boatGroup.add(topRailL);
            const topRailR = new THREE.Mesh(topRailGeo, railMat);
            topRailR.position.set(2.2, 2.7, 0);
            boatGroup.add(topRailR);
            
            // Cabin (small shelter at back)
            const cabinGeo = new THREE.BoxGeometry(3, 2, 2.5);
            const cabin = new THREE.Mesh(cabinGeo, woodMat);
            cabin.position.set(0, 2.7, 3);
            boatGroup.add(cabin);
            
            // Cabin roof
            const roofGeo = new THREE.BoxGeometry(3.3, 0.15, 2.8);
            const roof = new THREE.Mesh(roofGeo, darkWoodMat);
            roof.position.set(0, 3.8, 3);
            boatGroup.add(roof);
            
            // Position boat to float properly above water
            boatGroup.position.y = 1.2;
            scene.add(boatGroup);
        }
        
        function createStormClouds() {
            stormClouds = [];
            const cloudMat = new THREE.MeshBasicMaterial({
                color: 0x2a2a3a,
                transparent: true,
                opacity: 0
            });
            
            for (let i = 0; i < 30; i++) {
                const cloudGroup = new THREE.Group();
                
                // Multiple spheres for fluffy look
                for (let j = 0; j < 5; j++) {
                    const size = 10 + Math.random() * 15;
                    const puff = new THREE.Mesh(
                        new THREE.SphereGeometry(size, 8, 8),
                        cloudMat.clone()
                    );
                    puff.position.set(
                        (Math.random() - 0.5) * 20,
                        (Math.random() - 0.5) * 5,
                        (Math.random() - 0.5) * 20
                    );
                    cloudGroup.add(puff);
                }
                
                cloudGroup.position.set(
                    (Math.random() - 0.5) * 300,
                    40 + Math.random() * 20,
                    (Math.random() - 0.5) * 300
                );
                cloudGroup.userData.baseY = cloudGroup.position.y;
                cloudGroup.userData.speed = 0.5 + Math.random() * 0.5;
                cloudGroup.userData.phase = Math.random() * Math.PI * 2;
                
                scene.add(cloudGroup);
                stormClouds.push(cloudGroup);
            }
        }
        
        function createLighthouse() {
            lighthouseGroup = new THREE.Group();
            
            const stoneMat = new THREE.MeshLambertMaterial({ color: 0x8a8a8a });
            const whiteMat = new THREE.MeshLambertMaterial({ color: 0xeeeeee });
            const redMat = new THREE.MeshLambertMaterial({ color: 0xaa3333 });
            
            // Base rock
            const rockGeo = new THREE.ConeGeometry(15, 8, 8);
            const rock = new THREE.Mesh(rockGeo, stoneMat);
            rock.position.y = 4;
            lighthouseGroup.add(rock);
            
            // Tower
            const towerGeo = new THREE.CylinderGeometry(3, 4, 25, 12);
            const tower = new THREE.Mesh(towerGeo, whiteMat);
            tower.position.y = 20;
            lighthouseGroup.add(tower);
            
            // Red stripes
            for (let i = 0; i < 3; i++) {
                const stripeGeo = new THREE.CylinderGeometry(3.1 + (2-i) * 0.3, 3.2 + (2-i) * 0.3, 2, 12);
                const stripe = new THREE.Mesh(stripeGeo, redMat);
                stripe.position.y = 12 + i * 8;
                lighthouseGroup.add(stripe);
            }
            
            // Lamp room
            const lampRoomGeo = new THREE.CylinderGeometry(4, 3.5, 5, 12);
            const lampRoom = new THREE.Mesh(lampRoomGeo, stoneMat);
            lampRoom.position.y = 35;
            lighthouseGroup.add(lampRoom);
            
            // Glass windows (the glowing part)
            const glassMat = new THREE.MeshBasicMaterial({ 
                color: 0xffffaa, 
                transparent: true, 
                opacity: 0  // Start off
            });
            const glassGeo = new THREE.CylinderGeometry(3.8, 3.3, 4, 12, 1, true);
            const glass = new THREE.Mesh(glassGeo, glassMat);
            glass.position.y = 35;
            glass.name = 'lighthouseGlass';
            lighthouseGroup.add(glass);
            
            // Roof
            const roofGeo = new THREE.ConeGeometry(4.5, 3, 12);
            const roof = new THREE.Mesh(roofGeo, redMat);
            roof.position.y = 39;
            lighthouseGroup.add(roof);
            
            // Main spotlight (very strong, pointing outward)
            const spotlight = new THREE.SpotLight(0xffffcc, 0, 300, Math.PI / 8, 0.3, 1);
            spotlight.position.set(0, 35, 0);
            spotlight.target.position.set(0, 35, 100);  // Point outward
            spotlight.name = 'lighthouseBulb';
            lighthouseGroup.add(spotlight);
            lighthouseGroup.add(spotlight.target);
            
            // Light beam cone (visual effect) - small end at lighthouse, spreads outward
            const beamGeo = new THREE.CylinderGeometry(2, 25, 200, 16, 1, true);
            const beamMat = new THREE.MeshBasicMaterial({
                color: 0xffffcc,
                transparent: true,
                opacity: 0,
                side: THREE.DoubleSide
            });
            lighthouseBeam = new THREE.Mesh(beamGeo, beamMat);
            lighthouseBeam.rotation.x = Math.PI / 2;  // Flipped to point narrow end at lighthouse
            lighthouseBeam.position.set(0, 35, 100);  // Extend outward from lamp
            lighthouseGroup.add(lighthouseBeam);
            
            // Position lighthouse closer so it's visible during storm
            lighthouseGroup.position.set(0, -4, -80);
            scene.add(lighthouseGroup);
        }
        
        function createLightning() {
            lightningFlash = new THREE.Mesh(
                new THREE.PlaneGeometry(500, 200),
                new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0,
                    side: THREE.DoubleSide
                })
            );
            lightningFlash.position.set(0, 60, -100);
            scene.add(lightningFlash);
        }
        
        function createRain() {
            raindrops = [];
            const rainMat = new THREE.MeshBasicMaterial({
                color: 0xaaaacc,
                transparent: true,
                opacity: 0
            });
            
            for (let i = 0; i < 500; i++) {
                const drop = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.02, 0.02, 0.5, 4),
                    rainMat.clone()
                );
                drop.position.set(
                    (Math.random() - 0.5) * 100,
                    Math.random() * 50,
                    (Math.random() - 0.5) * 100
                );
                drop.userData.speed = 0.5 + Math.random() * 0.5;
                scene.add(drop);
                raindrops.push(drop);
            }
        }
        
        function updateOceanScene(time, dt) {
            oceanTime += dt;
            
            // Update wave animation
            if (oceanMesh) {
                const positions = oceanMesh.geometry.attributes.position.array;
                for (let i = 0; i < positions.length; i += 3) {
                    const x = positions[i];
                    const z = positions[i + 1];
                    const wave1 = Math.sin(x * 0.05 + time * 2) * waveAmplitude;
                    const wave2 = Math.sin(z * 0.07 + time * 1.5) * waveAmplitude * 0.7;
                    const wave3 = Math.sin((x + z) * 0.03 + time * 2.5) * waveAmplitude * 0.5;
                    positions[i + 2] = wave1 + wave2 + wave3;
                }
                oceanMesh.geometry.attributes.position.needsUpdate = true;
            }
            
            // Boat bobbing
            if (boatGroup) {
                const boatBob = Math.sin(time * 2) * waveAmplitude * 0.5;
                const boatRoll = Math.sin(time * 1.5) * waveAmplitude * 0.08;
                const boatPitch = Math.sin(time * 1.8) * waveAmplitude * 0.06;
                boatGroup.position.y = 1.2 + boatBob;
                boatGroup.rotation.z = boatRoll;
                boatGroup.rotation.x = boatPitch;
                
                // Camera follows boat bob and tilt
                camera.position.y = 4.5 + boatBob;
            }
            
            // Phase-based progression
            if (oceanPhase === 'storm_building') {
                stormIntensity = Math.min(1, stormIntensity + dt * 0.025);  // Slower buildup
                waveAmplitude = 0.5 + stormIntensity * 2;
                
                // Darken sky gradually
                const skyColor = new THREE.Color(0x1a2a3a).lerp(new THREE.Color(0x0a0a1a), stormIntensity);
                scene.background = skyColor;
                scene.fog.color = skyColor;
                
                // Show clouds gradually
                stormClouds.forEach(cloud => {
                    cloud.children.forEach(puff => {
                        puff.material.opacity = stormIntensity * 0.7;
                    });
                });
                
                // Show rain gradually
                raindrops.forEach(drop => {
                    drop.material.opacity = stormIntensity * 0.4;
                });
                
                if (stormIntensity >= 1) {
                    oceanPhase = 'storm_peak';
                    oceanTime = 0;
                    
                    // Check off storm task
                    const task = document.getElementById('task-ocean-storm');
                    if (task && !task.classList.contains('completed')) {
                        task.classList.add('completed');
                        task.querySelector('.checkbox').textContent = '‚úì';
                    }
                }
            }
            
            if (oceanPhase === 'storm_peak') {
                waveAmplitude = 3 + Math.sin(time) * 0.8;
                
                // Spawn lighthouse at 7 seconds into storm - far away!
                if (oceanTime > 7 && !lighthouseGroup) {
                    createLighthouse();
                    lighthouseGroup.position.set(0, -4, -250);  // Very far away
                }
                
                // Control lighthouse if it exists
                if (lighthouseGroup) {
                    const bulb = lighthouseGroup.getObjectByName('lighthouseBulb');
                    const glass = lighthouseGroup.getObjectByName('lighthouseGlass');
                    if (bulb) bulb.intensity = 8;  // Strong light visible from far
                    if (glass) glass.material.opacity = 0.8;
                    if (lighthouseBeam) lighthouseBeam.material.opacity = 0.35;
                    lighthouseGroup.rotation.y = time * 0.4;  // Rotating beam
                }
                
                // Random lightning - more frequent
                if (Math.random() < 0.015) {
                    lightningFlash.material.opacity = 1;
                    // Thunder effect - shake camera slightly
                    const shakeX = (Math.random() - 0.5) * 0.1;
                    const shakeY = (Math.random() - 0.5) * 0.05;
                    cameraPitch += shakeY;
                    cameraYaw += shakeX;
                    
                    setTimeout(() => {
                        lightningFlash.material.opacity = 0.6;
                        setTimeout(() => {
                            lightningFlash.material.opacity = 0.2;
                            setTimeout(() => {
                                lightningFlash.material.opacity = 0;
                            }, 80);
                        }, 60);
                    }, 40);
                }
                
                // Move clouds dramatically
                stormClouds.forEach(cloud => {
                    cloud.position.x += Math.sin(time + cloud.userData.phase) * 0.3;
                    cloud.position.y = cloud.userData.baseY + Math.sin(time * cloud.userData.speed) * 4;
                });
                
                // After 20 seconds at peak, transition to lighthouse focus
                if (oceanTime > 12) {
                    oceanPhase = 'lighthouse';
                    oceanTime = 0;
                    
                    // Check off lighthouse task
                    const task = document.getElementById('task-ocean-lighthouse');
                    if (task && !task.classList.contains('completed')) {
                        task.classList.add('completed');
                        task.querySelector('.checkbox').textContent = '‚úì';
                    }
                }
            }
            
            if (oceanPhase === 'lighthouse') {
                if (!lighthouseGroup) return;
                
                // Very strong lighthouse light
                const bulb = lighthouseGroup.getObjectByName('lighthouseBulb');
                if (bulb) bulb.intensity = 10;  // Very strong
                
                const glass = lighthouseGroup.getObjectByName('lighthouseGlass');
                if (glass) glass.material.opacity = 0.9;
                
                // Strong rotating beam
                if (lighthouseBeam) lighthouseBeam.material.opacity = 0.5;
                lighthouseGroup.rotation.y = time * 0.35;
                
                // Storm still going but slightly less intense
                waveAmplitude = 2.5 + Math.sin(time) * 0.4;
                
                if (Math.random() < 0.008) {
                    lightningFlash.material.opacity = 0.7;
                    setTimeout(() => { lightningFlash.material.opacity = 0; }, 100);
                }
                
                // After 10 seconds, start calming
                if (oceanTime > 6) {
                    oceanPhase = 'calming';
                    oceanTime = 0;
                }
            }
            
            if (oceanPhase === 'calming') {
                stormIntensity = Math.max(0, stormIntensity - dt * 0.05);  // Slower calming
                waveAmplitude = 0.5 + stormIntensity * 2;
                
                // Brighten sky
                const skyColor = new THREE.Color(0x0a0a1a).lerp(new THREE.Color(0x3a5a7a), 1 - stormIntensity);
                scene.background = skyColor;
                scene.fog.color = skyColor;
                scene.fog.density = 0.008 - stormIntensity * 0.004;
                
                // Fade clouds
                stormClouds.forEach(cloud => {
                    cloud.children.forEach(puff => {
                        puff.material.opacity = stormIntensity * 0.7;
                    });
                });
                
                // Fade rain
                raindrops.forEach(drop => {
                    drop.material.opacity = stormIntensity * 0.4;
                });
                
                // Increase ambient light
                const ambient = scene.getObjectByName('oceanAmbient');
                if (ambient) ambient.intensity = 0.4 + (1 - stormIntensity) * 0.5;
                
                const moon = scene.getObjectByName('moonLight');
                if (moon) moon.intensity = 0.3 + (1 - stormIntensity) * 0.4;
                
                // Keep lighthouse going strong
                if (lighthouseGroup) {
                    const bulb = lighthouseGroup.getObjectByName('lighthouseBulb');
                    if (bulb) bulb.intensity = 8;
                    if (lighthouseBeam) lighthouseBeam.material.opacity = 0.4;
                    lighthouseGroup.rotation.y = time * 0.3;
                }
                
                if (stormIntensity <= 0) {
                    oceanPhase = 'dawn';
                    oceanTime = 0;
                }
            }
            
            if (oceanPhase === 'dawn') {
                // Transition to sunrise
                const dawnProgress = Math.min(1, oceanTime * 0.05);
                
                waveAmplitude = 0.4 + Math.sin(time * 0.3) * 0.1;
                
                // Sky colors transition
                const skyColor = new THREE.Color(0x3a5a7a).lerp(new THREE.Color(0x7a5a4a), dawnProgress);
                scene.background = skyColor;
                scene.fog.color = skyColor;
                
                // Sun rising effect
                const ambient = scene.getObjectByName('oceanAmbient');
                if (ambient) {
                    ambient.intensity = 0.9 + dawnProgress * 0.4;
                    ambient.color.lerp(new THREE.Color(0xffddaa), dawnProgress * 0.4);
                }
                
                // Lighthouse dims as sun rises
                if (lighthouseGroup) {
                    const bulb = lighthouseGroup.getObjectByName('lighthouseBulb');
                    if (bulb) bulb.intensity = 8 * (1 - dawnProgress * 0.7);
                    if (lighthouseBeam) lighthouseBeam.material.opacity = 0.4 * (1 - dawnProgress * 0.6);
                    lighthouseGroup.rotation.y = time * 0.2;
                }
                
                if (dawnProgress >= 1) {
                    oceanPhase = 'peaceful';
                    oceanTime = 0;
                    
                    // Check off dawn task
                    const task = document.getElementById('task-ocean-dawn');
                    if (task && !task.classList.contains('completed')) {
                        task.classList.add('completed');
                        task.querySelector('.checkbox').textContent = '‚úì';
                    }
                }
            }
            
            if (oceanPhase === 'peaceful') {
                // Gentle waves
                waveAmplitude = 0.25 + Math.sin(time * 0.3) * 0.08;
                
                // Keep lighthouse beam rotating slowly
                if (lighthouseGroup) {
                    lighthouseGroup.rotation.y = time * 0.15;
                    if (lighthouseBeam) lighthouseBeam.material.opacity = 0.15;
                }
                
                // Beautiful morning colors
                const sunriseProgress = Math.min(1, oceanTime * 0.04);
                const skyColor = new THREE.Color(0x7a5a4a).lerp(new THREE.Color(0x6a8aaa), sunriseProgress);
                scene.background = skyColor;
                
                // Warm sunlight
                const ambient = scene.getObjectByName('oceanAmbient');
                if (ambient) {
                    ambient.intensity = 1.3;
                    ambient.color.set(0xffeedd);
                }
                
                // Ocean turns beautiful blue
                if (oceanMesh) {
                    oceanMesh.material.color.lerp(new THREE.Color(0x2a6a9a), sunriseProgress * 0.02);
                }
                
                // After 15 seconds of peace, transition to Christmas
                if (oceanTime > 8) {
                    // Hide ocean checklist
                    document.getElementById('ocean-checklist').classList.remove('visible');
                    
                    // Stop waves audio
                    const wavesAudio = document.getElementById('audio-waves');
                    if (wavesAudio) {
                        wavesAudio.pause();
                        wavesAudio.currentTime = 0;
                    }
                    
                    document.getElementById('fade-overlay').style.background = '#ffffff';
                    document.getElementById('fade-overlay').classList.add('visible');
                    setTimeout(() => {
                        loadChristmasScene();
                    }, 1500);
                    oceanPhase = 'transitioning';
                }
            }
            
            // Update rain positions
            raindrops.forEach(drop => {
                drop.position.y -= drop.userData.speed * (1 + stormIntensity);
                if (drop.position.y < 0) {
                    drop.position.y = 50;
                    drop.position.x = camera.position.x + (Math.random() - 0.5) * 100;
                    drop.position.z = camera.position.z + (Math.random() - 0.5) * 100;
                }
            });
            
            // Camera look (free look like sheep phase)
            if (State.canLook) {
                // Free mouse look in ocean scene
            }
        }

        // ============ CHRISTMAS SCENE ============
        
        function loadChristmasScene() {
            while(scene.children.length > 0) { 
                scene.remove(scene.children[0]); 
            }
            
            isChristmasScene = true;
            isOceanScene = false;
            isDreamScene = false;
            State.phase = 'christmas';
            christmasPhase = 'dark';
            lightsOn = false;
            fireLit = false;
            holdingCocoa = false;
            drinkingCocoa = false;
            lyingDown = false;
            lookingAtStars = false;
            eyesClosed = false;
            
            scene.background = new THREE.Color(0x1a1a2a);
            scene.fog = new THREE.FogExp2(0x1a1a2a, 0.008);
            
            const ambient = new THREE.AmbientLight(0x3a3a5a, 0.4);
            ambient.name = 'christmasAmbient';
            scene.add(ambient);
            
            const moonLight = new THREE.DirectionalLight(0x6a6a8a, 0.5);
            moonLight.position.set(30, 50, -30);
            scene.add(moonLight);
            
            createSnowGround();
            createChristmasTree();
            createLightButton();
            createCampfire();
            createCocoaStation();
            createSnowfall();
            
            camera.position.set(0, 1.7, 25);
            cameraYaw = Math.PI;
            cameraPitch = 0;
            camera.far = 300;
            camera.updateProjectionMatrix();
            scene.add(camera);
            
            State.canMove = true;
            State.canLook = true;
            
            // Show checklist
            document.getElementById('christmas-checklist').classList.add('visible');
            
            setTimeout(() => {
                document.getElementById('fade-overlay').style.background = '#000000';
                document.getElementById('fade-overlay').classList.remove('visible');
            }, 500);
        }
        
        function createSnowGround() {
            const groundGeo = new THREE.PlaneGeometry(100, 100, 50, 50);
            const groundMat = new THREE.MeshLambertMaterial({ color: 0xeeeeff });
            
            const verts = groundGeo.attributes.position.array;
            for (let i = 0; i < verts.length; i += 3) {
                verts[i + 2] = Math.random() * 0.2;
            }
            groundGeo.attributes.position.needsUpdate = true;
            groundGeo.computeVertexNormals();
            
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = 0;
            scene.add(ground);
        }
        
        function createChristmasTree() {
            christmasTree = new THREE.Group();
            
            const trunkGeo = new THREE.CylinderGeometry(1.5, 2, 5, 8);
            const trunkMat = new THREE.MeshLambertMaterial({ color: 0x4a3020 });
            const trunk = new THREE.Mesh(trunkGeo, trunkMat);
            trunk.position.y = 2.5;
            christmasTree.add(trunk);
            
            const treeMat = new THREE.MeshLambertMaterial({ color: 0x1a4a1a });
            
            const layers = [
                { radius: 12, height: 14, y: 14 },
                { radius: 10, height: 12, y: 25 },
                { radius: 8, height: 10, y: 34 },
                { radius: 6, height: 8, y: 42 },
                { radius: 4, height: 6, y: 48 },
                { radius: 2.5, height: 5, y: 53 }
            ];
            
            layers.forEach(layer => {
                const coneGeo = new THREE.ConeGeometry(layer.radius, layer.height, 16);
                const cone = new THREE.Mesh(coneGeo, treeMat);
                cone.position.y = layer.y;
                christmasTree.add(cone);
            });
            
            const starMat = new THREE.MeshBasicMaterial({ color: 0xffdd44 });
            const starGeo = new THREE.OctahedronGeometry(2, 0);
            const star = new THREE.Mesh(starGeo, starMat);
            star.position.y = 58;
            star.name = 'treeStar';
            christmasTree.add(star);
            
            christmasLights = [];
            const warmYellow = 0xffdd66;
            
            for (let i = 0; i < 150; i++) {
                const y = 8 + Math.random() * 47;
                const treeProgress = (y - 8) / 47;
                const maxRadius = 12 - treeProgress * 10;
                const angle = Math.random() * Math.PI * 2;
                const radiusVariation = 0.3 + Math.random() * 0.7;
                const radius = maxRadius * radiusVariation;
                const depthFactor = 0.5 + Math.random() * 0.5;
                
                const x = Math.cos(angle) * radius * depthFactor;
                const z = Math.sin(angle) * radius * depthFactor;
                
                const lightBulbGeo = new THREE.SphereGeometry(0.15 + Math.random() * 0.1, 6, 6);
                const lightBulbMat = new THREE.MeshBasicMaterial({ 
                    color: 0x444433,
                    transparent: true,
                    opacity: 0.4
                });
                const lightBulb = new THREE.Mesh(lightBulbGeo, lightBulbMat);
                lightBulb.position.set(x, y, z);
                lightBulb.userData.onColor = warmYellow;
                lightBulb.userData.phase = Math.random() * Math.PI * 2;
                christmasTree.add(lightBulb);
                christmasLights.push(lightBulb);
            }
            
            christmasTree.position.set(0, 0, -15);
            scene.add(christmasTree);
        }
        
        function createLightButton() {
            lightButton = new THREE.Group();
            
            const postGeo = new THREE.CylinderGeometry(0.1, 0.1, 1.2, 8);
            const postMat = new THREE.MeshLambertMaterial({ color: 0x3a3a3a });
            const post = new THREE.Mesh(postGeo, postMat);
            post.position.y = 0.6;
            lightButton.add(post);
            
            const boxGeo = new THREE.BoxGeometry(0.4, 0.3, 0.2);
            const boxMat = new THREE.MeshLambertMaterial({ color: 0x2a2a2a });
            const box = new THREE.Mesh(boxGeo, boxMat);
            box.position.y = 1.3;
            lightButton.add(box);
            
            const buttonGeo = new THREE.CylinderGeometry(0.12, 0.12, 0.08, 16);
            const buttonMat = new THREE.MeshLambertMaterial({ color: 0xcc0000 });
            const button = new THREE.Mesh(buttonGeo, buttonMat);
            button.position.set(0, 1.35, 0.12);
            button.rotation.x = Math.PI / 2;
            button.name = 'lightButton';
            lightButton.add(button);
            
            lightButton.position.set(8, 0, 10);
            scene.add(lightButton);
        }
        
        function createCampfire() {
            campfire = new THREE.Group();
            
            const stoneMat = new THREE.MeshLambertMaterial({ color: 0x5a5a5a });
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                const stoneGeo = new THREE.BoxGeometry(0.4, 0.25, 0.3);
                const stone = new THREE.Mesh(stoneGeo, stoneMat);
                stone.position.set(Math.cos(angle) * 0.7, 0.12, Math.sin(angle) * 0.7);
                stone.rotation.y = angle;
                campfire.add(stone);
            }
            
            const logMat = new THREE.MeshLambertMaterial({ color: 0x3a2a1a });
            for (let i = 0; i < 4; i++) {
                const logGeo = new THREE.CylinderGeometry(0.1, 0.12, 0.8, 6);
                const log = new THREE.Mesh(logGeo, logMat);
                log.position.set(0, 0.15, 0);
                log.rotation.z = Math.PI / 2;
                log.rotation.y = (i / 4) * Math.PI;
                campfire.add(log);
            }
            
            fireLight = new THREE.PointLight(0xff6600, 0, 15);
            fireLight.position.y = 0.5;
            campfire.add(fireLight);
            
            fireParticles = [];
            const fireMat = new THREE.MeshBasicMaterial({ 
                color: 0xff4400, 
                transparent: true, 
                opacity: 0 
            });
            
            for (let i = 0; i < 20; i++) {
                const particleGeo = new THREE.SphereGeometry(0.08 + Math.random() * 0.1, 6, 6);
                const particle = new THREE.Mesh(particleGeo, fireMat.clone());
                particle.position.set(
                    (Math.random() - 0.5) * 0.3,
                    0.2 + Math.random() * 0.5,
                    (Math.random() - 0.5) * 0.3
                );
                particle.userData.baseY = particle.position.y;
                particle.userData.phase = Math.random() * Math.PI * 2;
                particle.userData.speed = 0.5 + Math.random() * 0.5;
                campfire.add(particle);
                fireParticles.push(particle);
            }
            
            campfire.position.set(-8, 0, 10);
            campfire.name = 'campfire';
            scene.add(campfire);
        }
        
        function createCocoaStation() {
            const station = new THREE.Group();
            
            const tableMat = new THREE.MeshLambertMaterial({ color: 0x5a4030 });
            const tableTopGeo = new THREE.CylinderGeometry(0.5, 0.5, 0.05, 12);
            const tableTop = new THREE.Mesh(tableTopGeo, tableMat);
            tableTop.position.y = 0.7;
            station.add(tableTop);
            
            const tableLegGeo = new THREE.CylinderGeometry(0.08, 0.08, 0.7, 8);
            const tableLeg = new THREE.Mesh(tableLegGeo, tableMat);
            tableLeg.position.y = 0.35;
            station.add(tableLeg);
            
            cocoaMug = new THREE.Group();
            const mugMat = new THREE.MeshLambertMaterial({ color: 0xcc2222 });
            
            const outerGeo = new THREE.CylinderGeometry(0.1, 0.08, 0.15, 16);
            const outer = new THREE.Mesh(outerGeo, mugMat);
            outer.position.y = 0.8;
            cocoaMug.add(outer);
            
            const innerMat = new THREE.MeshLambertMaterial({ color: 0x1a0a05 });
            const innerGeo = new THREE.CylinderGeometry(0.085, 0.068, 0.14, 16);
            const inner = new THREE.Mesh(innerGeo, innerMat);
            inner.position.y = 0.81;
            cocoaMug.add(inner);
            
            const rimGeo = new THREE.TorusGeometry(0.092, 0.008, 8, 24);
            const rimMat = new THREE.MeshLambertMaterial({ color: 0xdd3333 });
            const rim = new THREE.Mesh(rimGeo, rimMat);
            rim.rotation.x = Math.PI / 2;
            rim.position.y = 0.875;
            cocoaMug.add(rim);
            
            const handleGeo = new THREE.TorusGeometry(0.055, 0.012, 8, 16, Math.PI);
            const handle = new THREE.Mesh(handleGeo, mugMat);
            handle.position.set(0.1, 0.8, 0);
            handle.rotation.z = Math.PI / 2;
            cocoaMug.add(handle);
            
            const cocoaMat = new THREE.MeshLambertMaterial({ color: 0x3a1a0a });
            const cocoaGeo = new THREE.CylinderGeometry(0.08, 0.08, 0.02, 16);
            const cocoa = new THREE.Mesh(cocoaGeo, cocoaMat);
            cocoa.position.y = 0.855;
            cocoaMug.add(cocoa);
            
            const marshMat = new THREE.MeshLambertMaterial({ color: 0xffffff });
            for (let i = 0; i < 3; i++) {
                const marshGeo = new THREE.SphereGeometry(0.025, 8, 8);
                const marsh = new THREE.Mesh(marshGeo, marshMat);
                const angle = (i / 3) * Math.PI * 2 + 0.3;
                marsh.position.set(Math.cos(angle) * 0.04, 0.87, Math.sin(angle) * 0.04);
                marsh.scale.y = 0.6;
                cocoaMug.add(marsh);
            }
            
            cocoaMug.name = 'cocoaMug';
            station.add(cocoaMug);
            
            station.position.set(-8, 0, 8);
            scene.add(station);
        }
        
        function createSnowfall() {
            snowflakes = [];
            const snowMat = new THREE.MeshBasicMaterial({ 
                color: 0xffffff, 
                transparent: true, 
                opacity: 0.8 
            });
            
            for (let i = 0; i < 200; i++) {
                const snowGeo = new THREE.SphereGeometry(0.03 + Math.random() * 0.03, 4, 4);
                const flake = new THREE.Mesh(snowGeo, snowMat.clone());
                flake.position.set(
                    (Math.random() - 0.5) * 60,
                    Math.random() * 30,
                    (Math.random() - 0.5) * 60
                );
                flake.userData.speed = 0.02 + Math.random() * 0.03;
                flake.userData.drift = (Math.random() - 0.5) * 0.01;
                scene.add(flake);
                snowflakes.push(flake);
            }
        }
        
        function turnOnChristmasLights() {
            if (lightsOn) return;
            lightsOn = true;
            
            christmasLights.forEach(light => {
                light.material.color.setHex(light.userData.onColor);
                light.material.opacity = 1;
            });
            
            const star = christmasTree.getObjectByName('treeStar');
            if (star) {
                const starLight = new THREE.PointLight(0xffdd44, 3, 40);
                starLight.position.copy(star.position);
                christmasTree.add(starLight);
            }
            
            const treeGlow = new THREE.PointLight(0xffdd66, 1.5, 50);
            treeGlow.position.set(0, 30, 0);
            christmasTree.add(treeGlow);
            
            const glowPositions = [10, 20, 35, 45];
            glowPositions.forEach(y => {
                const glow = new THREE.PointLight(0xffdd66, 0.5, 25);
                glow.position.set(0, y, 0);
                christmasTree.add(glow);
            });
            
            christmasPhase = 'lights';
            
            const task = document.getElementById('task-lights');
            task.classList.add('completed');
            task.querySelector('.checkbox').textContent = '‚úì';
        }
        
        function lightCampfire() {
            if (fireLit) return;
            fireLit = true;
            
            fireLight.intensity = 3;
            
            fireParticles.forEach(p => {
                p.material.opacity = 0.9;
            });
            
            const ambient = scene.getObjectByName('christmasAmbient');
            if (ambient) ambient.intensity = 0.5;
            
            christmasPhase = 'fire';
            
            const task = document.getElementById('task-fire');
            task.classList.add('completed');
            task.querySelector('.checkbox').textContent = '‚úì';
        }
        
        function pickupCocoa() {
            if (holdingCocoa) return;
            holdingCocoa = true;
            
            cocoaMug.visible = false;
            
            cocoaInHand = new THREE.Group();
            
            const mugMat = new THREE.MeshLambertMaterial({ color: 0xcc2222 });
            
            const outerGeo = new THREE.CylinderGeometry(0.09, 0.07, 0.14, 16);
            const outer = new THREE.Mesh(outerGeo, mugMat);
            cocoaInHand.add(outer);
            
            const innerMat = new THREE.MeshLambertMaterial({ color: 0x1a0a05 });
            const innerGeo = new THREE.CylinderGeometry(0.075, 0.058, 0.13, 16);
            const inner = new THREE.Mesh(innerGeo, innerMat);
            inner.position.y = 0.01;
            cocoaInHand.add(inner);
            
            const bottomGeo = new THREE.CircleGeometry(0.058, 16);
            const bottom = new THREE.Mesh(bottomGeo, innerMat);
            bottom.rotation.x = -Math.PI / 2;
            bottom.position.y = -0.055;
            cocoaInHand.add(bottom);
            
            const rimGeo = new THREE.TorusGeometry(0.082, 0.008, 8, 24);
            const rimMat = new THREE.MeshLambertMaterial({ color: 0xdd3333 });
            const rim = new THREE.Mesh(rimGeo, rimMat);
            rim.rotation.x = Math.PI / 2;
            rim.position.y = 0.07;
            cocoaInHand.add(rim);
            
            const handleGeo = new THREE.TorusGeometry(0.05, 0.012, 8, 16, Math.PI);
            const handle = new THREE.Mesh(handleGeo, mugMat);
            handle.position.set(0.09, 0, 0);
            handle.rotation.z = Math.PI / 2;
            cocoaInHand.add(handle);
            
            const cocoaMat = new THREE.MeshLambertMaterial({ color: 0x3a1a0a });
            const cocoaGeo = new THREE.CylinderGeometry(0.072, 0.072, 0.02, 16);
            const cocoa = new THREE.Mesh(cocoaGeo, cocoaMat);
            cocoa.position.y = 0.05;
            cocoa.name = 'cocoaLiquid';
            cocoaInHand.add(cocoa);
            
            const marshMat = new THREE.MeshLambertMaterial({ color: 0xffffff });
            for (let i = 0; i < 3; i++) {
                const marshGeo = new THREE.SphereGeometry(0.022, 8, 8);
                const marsh = new THREE.Mesh(marshGeo, marshMat);
                const angle = (i / 3) * Math.PI * 2 + 0.3;
                marsh.position.set(Math.cos(angle) * 0.035, 0.065, Math.sin(angle) * 0.035);
                marsh.scale.y = 0.6;
                marsh.name = 'marshmallow';
                cocoaInHand.add(marsh);
            }
            
            const steamMat = new THREE.MeshBasicMaterial({ 
                color: 0xffffff, 
                transparent: true, 
                opacity: 0.2 
            });
            for (let i = 0; i < 5; i++) {
                const steamGeo = new THREE.SphereGeometry(0.01 + Math.random() * 0.01, 4, 4);
                const steam = new THREE.Mesh(steamGeo, steamMat.clone());
                steam.position.set(
                    (Math.random() - 0.5) * 0.04,
                    0.08 + Math.random() * 0.03,
                    (Math.random() - 0.5) * 0.04
                );
                steam.userData.phase = Math.random() * Math.PI * 2;
                steam.name = 'steam';
                cocoaInHand.add(steam);
            }
            
            cocoaInHand.position.set(0.28, -0.25, -0.45);
            camera.add(cocoaInHand);
            
            christmasPhase = 'holding';
            
            const task = document.getElementById('task-cocoa');
            task.classList.add('completed');
            task.querySelector('.checkbox').textContent = '‚úì';
        }
        
        function drinkCocoaChristmas() {
            if (drinkingCocoa || !holdingCocoa) return;
            drinkingCocoa = true;
            
            let drinkProgress = 0;
            const drinkInterval = setInterval(() => {
                drinkProgress += 0.02;
                
                if (drinkProgress < 0.5) {
                    cocoaInHand.position.y = -0.25 + drinkProgress * 0.55;
                    cocoaInHand.position.z = -0.45 + drinkProgress * 0.25;
                    cocoaInHand.rotation.x = drinkProgress * 0.5;
                }
                
                if (drinkProgress >= 0.5 && drinkProgress < 0.8) {
                    cocoaInHand.rotation.x = 0.25 + (drinkProgress - 0.5) * 3;
                    const liquid = cocoaInHand.getObjectByName('cocoaLiquid');
                    if (liquid) liquid.scale.y = Math.max(0, 1 - (drinkProgress - 0.5) * 3);
                    cocoaInHand.children.forEach(child => {
                        if (child.name === 'marshmallow') {
                            child.visible = drinkProgress < 0.65;
                        }
                        if (child.name === 'steam') {
                            child.visible = false;
                        }
                    });
                }
                
                if (drinkProgress >= 0.8) {
                    cocoaInHand.position.y = 0.02 - (drinkProgress - 0.8) * 1.4;
                    cocoaInHand.rotation.x = 1.15 - (drinkProgress - 0.8) * 5.5;
                }
                
                if (drinkProgress >= 1) {
                    clearInterval(drinkInterval);
                    
                    const task = document.getElementById('task-drink');
                    task.classList.add('completed');
                    task.querySelector('.checkbox').textContent = '‚úì';
                    
                    camera.remove(cocoaInHand);
                    cocoaInHand = null;
                    
                    setTimeout(lieDownChristmas, 2000);
                }
            }, 30);
        }
        
        function lieDownChristmas() {
            lyingDown = true;
            State.canMove = false;
            
            document.getElementById('crosshair').style.opacity = '0';
            
            let lieProgress = 0;
            const startY = camera.position.y;
            const startPitch = cameraPitch;
            
            const lieInterval = setInterval(() => {
                lieProgress += 0.015;
                
                camera.position.y = startY - lieProgress * (startY - 0.3);
                
                cameraPitch = startPitch + lieProgress * (Math.PI / 2.1 - startPitch);
                camera.rotation.order = 'YXZ';
                camera.rotation.x = cameraPitch;
                
                if (lieProgress >= 1) {
                    clearInterval(lieInterval);
                    camera.position.y = 0.3;
                    cameraPitch = Math.PI / 2.1;
                    camera.rotation.x = cameraPitch;
                    
                    lookingAtStars = true;
                    createStarFieldChristmas();
                    
                    const task = document.getElementById('task-rest');
                    task.classList.add('completed');
                    task.querySelector('.checkbox').textContent = '‚úì';
                    
                    setTimeout(closeEyesChristmas, 6000);
                }
            }, 30);
        }
        
        function createStarFieldChristmas() {
            starField = [];
            
            for (let i = 0; i < 300; i++) {
                const starGeo = new THREE.SphereGeometry(0.05 + Math.random() * 0.1, 4, 4);
                const starMat = new THREE.MeshBasicMaterial({ 
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.7
                });
                const star = new THREE.Mesh(starGeo, starMat);
                
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI * 0.4 + 0.1;
                const radius = 80 + Math.random() * 40;
                
                star.position.set(
                    radius * Math.sin(phi) * Math.cos(theta),
                    radius * Math.cos(phi),
                    radius * Math.sin(phi) * Math.sin(theta)
                );
                
                star.userData.twinklePhase = Math.random() * Math.PI * 2;
                star.userData.twinkleSpeed = 1 + Math.random() * 2;
                star.userData.baseOpacity = 0.5 + Math.random() * 0.5;
                
                scene.add(star);
                starField.push(star);
            }
            
            for (let i = 0; i < 20; i++) {
                const brightStarGeo = new THREE.SphereGeometry(0.15 + Math.random() * 0.1, 6, 6);
                const brightStar = new THREE.Mesh(brightStarGeo, new THREE.MeshBasicMaterial({ 
                    color: 0xffffee,
                    transparent: true,
                    opacity: 1
                }));
                
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI * 0.35 + 0.15;
                const radius = 70 + Math.random() * 30;
                
                brightStar.position.set(
                    radius * Math.sin(phi) * Math.cos(theta),
                    radius * Math.cos(phi),
                    radius * Math.sin(phi) * Math.sin(theta)
                );
                
                brightStar.userData.twinklePhase = Math.random() * Math.PI * 2;
                brightStar.userData.twinkleSpeed = 0.5 + Math.random();
                brightStar.userData.baseOpacity = 0.8;
                
                scene.add(brightStar);
                starField.push(brightStar);
            }
        }
        
        function closeEyesChristmas() {
            eyesClosed = true;
            
            document.getElementById('christmas-checklist').style.opacity = '0';
            
            const overlay = document.getElementById('fade-overlay');
            overlay.style.background = '#000000';
            overlay.style.transition = 'opacity 4s';
            overlay.classList.add('visible');

            // Notify parent that game has ended after fade completes
            setTimeout(function() {
                if (window.parent && window.parent !== window) {
                    window.parent.postMessage({ type: 'darknessGameEnd' }, '*');
                }
            }, 4500);
        }
        
        function updateChristmasScene(time, dt) {
            snowflakes.forEach(flake => {
                flake.position.y -= flake.userData.speed;
                flake.position.x += flake.userData.drift;
                
                if (flake.position.y < 0) {
                    flake.position.y = 30;
                    flake.position.x = camera.position.x + (Math.random() - 0.5) * 60;
                    flake.position.z = camera.position.z + (Math.random() - 0.5) * 60;
                }
            });
            
            if (lightsOn) {
                christmasLights.forEach(light => {
                    const twinkle = 0.7 + Math.sin(time * 3 + light.userData.phase) * 0.3;
                    light.material.opacity = twinkle;
                });
                
                const star = christmasTree.getObjectByName('treeStar');
                if (star) {
                    star.rotation.y = time * 0.5;
                }
            }
            
            if (fireLit) {
                fireParticles.forEach(p => {
                    p.position.y = p.userData.baseY + Math.sin(time * p.userData.speed * 10 + p.userData.phase) * 0.2;
                    p.position.x += Math.sin(time * 5 + p.userData.phase) * 0.002;
                    
                    const colorPhase = Math.sin(time * 3 + p.userData.phase);
                    if (colorPhase > 0.5) {
                        p.material.color.setHex(0xffaa00);
                    } else if (colorPhase > 0) {
                        p.material.color.setHex(0xff6600);
                    } else {
                        p.material.color.setHex(0xff4400);
                    }
                });
                
                fireLight.intensity = 2.5 + Math.sin(time * 10) * 0.5 + Math.random() * 0.3;
            }
            
            if (cocoaInHand && !drinkingCocoa) {
                cocoaInHand.children.forEach(child => {
                    if (child.name === 'steam') {
                        child.position.y = 0.08 + Math.sin(time * 2 + child.userData.phase) * 0.02;
                        child.position.x = (Math.random() - 0.5) * 0.04;
                        child.material.opacity = 0.15 + Math.sin(time * 3 + child.userData.phase) * 0.1;
                    }
                });
            }
            
            if (lookingAtStars) {
                starField.forEach(star => {
                    const twinkle = star.userData.baseOpacity + 
                        Math.sin(time * star.userData.twinkleSpeed + star.userData.twinklePhase) * 0.3;
                    star.material.opacity = Math.max(0.2, Math.min(1, twinkle));
                });
            }
            
            if (State.canMove && State.locked && !lyingDown) {
                State.velocity.multiplyScalar(0.9);
                const dir = new THREE.Vector3();
                if (State.keys.w) dir.z -= 1;
                if (State.keys.s) dir.z += 1;
                if (State.keys.a) dir.x -= 1;
                if (State.keys.d) dir.x += 1;
                dir.normalize();
                
                if (dir.length() > 0) {
                    const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
                    forward.y = 0;
                    forward.normalize();
                    const right = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
                    right.y = 0;
                    right.normalize();
                    
                    State.velocity.addScaledVector(forward, -dir.z * 0.03);
                    State.velocity.addScaledVector(right, dir.x * 0.03);
                }
                
                State.velocity.clampLength(0, 0.15);
                
                const newX = camera.position.x + State.velocity.x;
                const newZ = camera.position.z + State.velocity.z;
                
                camera.position.x = Math.max(-35, Math.min(35, newX));
                camera.position.z = Math.max(-35, Math.min(35, newZ));
                camera.position.y = 1.7;
            }
        }


        function updateDreamScene(time, dt) {
            // Handle falling phase
            if (State.phase === 'falling') {
                updateFalling(dt);
            }
            
            // Handle falling/floating camera pitch interpolation
            if (State.phase === 'falling' || State.phase === 'floating') {
                cameraPitch += (targetPitch - cameraPitch) * 0.05;
                updateCamera();
            }
            
            // Dream scene movement - sheep phase allows movement without pointer lock
            const canMoveNow = State.canMove && State.locked;
            if (canMoveNow) {
                State.velocity.multiplyScalar(0.9);
                const dir = new THREE.Vector3();
                if (State.keys.w) dir.z -= 1;
                if (State.keys.s) dir.z += 1;
                if (State.keys.a) dir.x -= 1;
                if (State.keys.d) dir.x += 1;
                dir.normalize();
                if (dir.length() > 0) {
                    const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
                    forward.y = 0;
                    forward.normalize();
                    const right = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
                    right.y = 0;
                    right.normalize();
                    const speed = State.phase === 'sheep' ? 0.04 : 0.02;
                    State.velocity.addScaledVector(forward, -dir.z * speed);
                    State.velocity.addScaledVector(right, dir.x * speed);
                }
                const maxV = State.phase === 'sheep' ? 0.2 : 0.1;
                State.velocity.clampLength(0, maxV);
                const newX = camera.position.x + State.velocity.x;
                const newZ = camera.position.z + State.velocity.z;
                let blocked = false;
                for (const c of colliders) {
                    if (Math.sqrt((newX - c.x) ** 2 + (newZ - c.z) ** 2) < c.r + 0.5) { blocked = true; break; }
                }
                if (!blocked && window.streamZ) {
                    const onBridge = Math.abs(newX - window.bridgeX) < window.bridgeHalfWidth;
                    const inStreamZone = Math.abs(newZ - window.streamZ) < 2.5;
                    if (inStreamZone && !onBridge) {
                        blocked = true;
                    }
                    if (inStreamZone && onBridge) {
                        const atRailingEdge = Math.abs(newX - window.bridgeX) > (window.bridgeHalfWidth - 0.5);
                        if (atRailingEdge) {
                            const currentlyOnBridge = Math.abs(camera.position.x - window.bridgeX) < window.bridgeHalfWidth;
                            if (currentlyOnBridge && Math.abs(newX) > Math.abs(camera.position.x)) {
                                blocked = true;
                            }
                        }
                    }
                }
                if (!blocked) {
                    camera.position.x = newX;
                    camera.position.z = newZ;
                    if (State.phase !== 'sheep') {
                        const onBridgeNow = window.streamZ && 
                            Math.abs(newX - window.bridgeX) < window.bridgeHalfWidth &&
                            Math.abs(newZ - window.streamZ) < window.bridgeHalfLength;
                        
                        let targetY;
                        if (onBridgeNow) {
                            const bridgeY = getTerrainHeight(window.bridgeX, window.streamZ) + 0.8;
                            targetY = bridgeY + 1.7;
                        } else {
                            targetY = getTerrainHeight(newX, newZ) + 1.7;
                        }
                        camera.position.y += (targetY - camera.position.y) * 0.1;
                    }
                    if (State.phase === 'sheep') {
                        // Walk on grass plane
                        camera.position.y = 1.7;
                        // Keep in bounds
                        camera.position.x = Math.max(-90, Math.min(90, camera.position.x));
                        camera.position.z = Math.max(-90, Math.min(90, camera.position.z));
                    }
                }
            }

            // Animate fireflies
            fireflies.forEach(ff => {
                if (!ff.userData.basePos) return;
                ff.position.y = ff.userData.basePos.y + Math.sin(time * ff.userData.speed + ff.userData.phase) * 0.4;
                ff.position.x = ff.userData.basePos.x + Math.sin(time * ff.userData.speed * 0.7 + ff.userData.phase) * 0.2;
                if (ff.children[1]) {
                    ff.children[1].material.opacity = 0.5 + Math.sin(time * 3 + ff.userData.phase) * 0.4;
                }
            });

            // Twinkle user-drawn 3D stars
            stars2D.forEach(star => {
                if (star.userData && star.userData.twinkleSpeed) {
                    const twinkle = 0.6 + Math.sin(time * star.userData.twinkleSpeed + star.userData.phase) * 0.4;
                    if (star.material) {
                        star.material.opacity = twinkle;
                    }
                }
            });

            // Animate animals
            animals.forEach(animal => {
                if (animal.userData.animalType === 'rabbit') {
                    animal.userData.hopTimer -= dt * 60;
                    if (animal.userData.hopTimer <= 0) {
                        animal.userData.hopTimer = 80 + Math.random() * 120;
                    }
                    const hopPhase = Math.max(0, 20 - animal.userData.hopTimer) / 20;
                    if (hopPhase > 0 && hopPhase < 1) {
                        animal.position.y = animal.userData.baseY + Math.sin(hopPhase * Math.PI) * 0.15;
                    }
                } else if (animal.userData.animalType === 'owl') {
                    animal.userData.blinkTimer -= dt * 60;
                    if (animal.userData.blinkTimer <= 0) {
                        animal.userData.blinkTimer = 150 + Math.random() * 200;
                    }
                    animal.rotation.y = Math.sin(time * 0.5) * 0.2;
                } else if (animal.userData.animalType === 'frog') {
                    const breathe = 1 + Math.sin(time * 2 + animal.userData.croakTimer) * 0.1;
                    animal.scale.y = 0.6 * breathe;
                }
            });

            // Animate stream ripples
            if (streamMesh && State.phase !== 'sheep') {
                const positions = streamMesh.geometry.attributes.position.array;
                const streamZ = 35;
                const segmentsX = 80;
                const segmentsZ = 4;
                
                let idx = 0;
                for (let iz = 0; iz <= segmentsZ; iz++) {
                    for (let ix = 0; ix <= segmentsX; ix++) {
                        const x = positions[idx];
                        const z = positions[idx + 2];
                        const baseY = getTerrainHeight(x, z) + 0.08;
                        const ripple = Math.sin(x * 0.3 + time * 2.5) * 0.06 + 
                                       Math.sin(x * 0.15 - time * 1.5) * 0.04 +
                                       Math.sin(z * 0.5 + time * 3) * 0.02;
                        positions[idx + 1] = baseY + ripple;
                        idx += 3;
                    }
                }
                streamMesh.geometry.attributes.position.needsUpdate = true;
            }

            // Update sheep - always run when sheep exist
            if (sheep.length > 0) {
                // Debug: Log sheep position for first 60 frames (1 second)
                sheepDebugFrames++;
                if (sheepDebugFrames <= 60) {
                    console.log('Frame', sheepDebugFrames, ': sheep[0].y =', sheep[0]?.position?.y?.toFixed(2),
                               'vel.y =', sheep[0]?.userData?.velocity?.y?.toFixed(3));
                }
                updateSheep(dt, time);
            }
        }

        function initAudio() {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            masterGain = audioCtx.createGain();
            masterGain.connect(audioCtx.destination);
            masterGain.gain.value = 0.3;
        }

        function playNoise(type, freq, vol) {
            if (!audioCtx) return;
            const buf = audioCtx.createBuffer(1, audioCtx.sampleRate * 2, audioCtx.sampleRate);
            const data = buf.getChannelData(0);
            for (let i = 0; i < data.length; i++) data[i] = Math.random() * 2 - 1;
            const src = audioCtx.createBufferSource();
            src.buffer = buf;
            src.loop = true;
            const flt = audioCtx.createBiquadFilter();
            flt.type = type;
            flt.frequency.value = freq;
            const gain = audioCtx.createGain();
            gain.gain.value = vol;
            src.connect(flt);
            flt.connect(gain);
            gain.connect(masterGain);
            src.start();
        }

        function playTwinkle() {
            if (!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = 'sine';
            osc.frequency.value = 800 + Math.random() * 400;
            gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
            osc.connect(gain);
            gain.connect(masterGain);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.2);
        }

        function showPrompt(text) {
            const el = document.getElementById('prompt');
            el.innerHTML = text;
            el.classList.add('visible');
        }

        function hidePrompt() {
            document.getElementById('prompt').classList.remove('visible');
        }

        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
